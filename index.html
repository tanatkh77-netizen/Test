<!DOCTYPE html> 
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#1a1a2e">
<link rel="manifest" id="manifest-link">
<title>Simulator</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-V7TV25SK5M"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-V7TV25SK5M');
</script>
<style>
    :root {
        --bg-color: #1a1a2e; --primary-color: #4b4b7c; --primary-hover-color: #6a6aff;
        --font-color: #e0e0e0; --border-color: #4b4b7c; --canvas-bg-color: #0f0f18;
        --font-display: 'Orbitron', sans-serif; --font-ui: 'Noto Sans JP', sans-serif;
    }
    html, body {
        margin: 0;
        padding: 0;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        -webkit-tap-highlight-color: transparent;
    }
    body {
        background-color: var(--bg-color);
        color: var(--font-color);
        font-family: var(--font-ui);
        display: flex;
        justify-content: center;
        align-items: center;
    }
    .main-container {
        text-align: center;
        transform-origin: center center;
    }
    #editor-container {
        display: flex; flex-direction: column; gap: 15px; background-color: rgba(15, 15, 24, 0.8);
        padding: 20px; border-radius: 10px; border: 2px solid var(--border-color);
        width: 100%; max-width: 1200px; margin-bottom: 20px;
    }
    #game-container { display: none; }
    canvas {
        background-color: var(--canvas-bg-color); border-radius: 8px;
        border: 2px solid var(--border-color);
    }
    h2 {
        font-family: var(--font-display); color: var(--primary-hover-color); margin: 0 0 10px 0;
        border-bottom: 2px solid var(--primary-color); padding-bottom: 5px; text-align: center;
    }
    .button, button, label.button {
        background-color: var(--primary-color); color: var(--font-color); border: none;
        padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 14px;
        font-family: var(--font-display); transition: background-color 0.2s;
        text-align: center; display: inline-block;
    }
    .button:hover, button:hover, label.button:hover { background-color: var(--primary-hover-color); }
    input[type="file"] { display: none; }

    .edit-section { background-color: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; }
    .top-controls { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px; }
    .mode-selection { display: flex; gap: 10px; align-items: center;}
    .mode-selection .button.active { background-color: var(--primary-hover-color); box-shadow: 0 0 10px var(--primary-hover-color);
    }
#p1-touch-mode-selection .button.active {
    background-color: var(--primary-hover-color);
    box-shadow: 0 0 10px var(--primary-hover-color);
}

    .player-editors { display: flex; justify-content: space-around; gap: 20px; flex-wrap: nowrap; margin-top: 15px;
    }
    .editor-column { flex: 1; min-width: 320px; display: flex; flex-direction: column; gap: 15px; }

    .mino-icons, .color-palette { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; }
    .mino-icon, .color-swatch {
        width: 40px; height: 40px; border-radius: 4px; cursor: pointer;
        border: 2px solid transparent; transition: all 0.2s; box-sizing: border-box;
    }
    .mino-icon:hover, .color-swatch:hover { transform: scale(1.1); }
    .color-swatch.active { border-color: #fff; box-shadow: 0 0 8px #fff; }

    .next-queue-display {
        background-color: rgba(0,0,0,0.3); padding: 8px; border-radius: 5px; min-height: 38px;
        display: flex; gap: 5px; flex-wrap: wrap; border: 1px solid var(--primary-color);
    }
    .next-queue-display .mino-icon { cursor: default; }
    .editor-column .button-group { display: flex; gap: 10px; justify-content: center; margin-top: 10px; }

    .field-editor canvas { margin-bottom: 10px; cursor: crosshair; touch-action: none; }
    .field-controls { display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;}

    #startGameBtn { font-size: 24px; padding: 12px 25px; background-color: #00a000; }
    #startGameBtn:hover { background-color: #00c000; }

    #scan-instructions {
        position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8); color: white; padding: 10px 20px;
        border-radius: 10px; font-size: 18px; z-index: 100;
    }
    
#settings-modal {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0, 0, 0, 0.75);
        display: none; justify-content: center; align-items: center; z-index: 200;
    }
.modal-content {
    background-color: var(--bg-color);
    padding: 25px;
    border-radius: 10px;
    border: 2px solid var(--primary-color);
    width: 90%;
    max-width: 500px;
    font-family: var(--font-ui);
    max-height: 95vh;
    overflow-y: auto;
    box-sizing: border-box;
}


    .modal-content h2, .modal-content h3 { font-size: 24px; }
    .modal-content h3 { font-size: 20px; margin-top: 25px; border-top: 1px solid var(--primary-color); padding-top: 15px; }
#settings-list, .key-config-list-container { display: flex; flex-direction: column; gap: 12px; margin: 20px 0; }
    .key-config-item, .setting-item { display: flex; justify-content: space-between; align-items: center; padding: 5px; border-radius: 4px; }
    .key-config-item:nth-child(odd), .setting-item:nth-child(odd) { background-color: rgba(255,255,255,0.05); }
    .key-config-item span, .setting-item span, .setting-item label { font-size: 16px; color: var(--font-color); }
    .key-config-item button, .setting-item input { min-width: 150px; text-align: center; }
    .setting-item input[type="number"] { background-color: var(--primary-color); color: var(--font-color); border: 1px solid var(--border-color); padding: 5px; border-radius: 4px; font-family: var(--font-display); }
    .setting-item input[type="checkbox"] { width: 20px; height: 20px; min-width: 20px; }
    .setting-item label { display: flex; align-items: center; gap: 10px; }
    .modal-controls { text-align: center; margin-top: 15px; }

    #share-modal {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0, 0, 0, 0.75);
        display: none; justify-content: center; align-items: center; z-index: 200;
    }
    .share-section h3 {
        font-family: var(--font-display);
        color: var(--primary-hover-color);
        margin-top: 0;
        margin-bottom: 10px;
        border-bottom: 1px solid var(--primary-color);
        padding-bottom: 5px;
    }
    .share-item {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
    }
    #share-modal .modal-content input, #share-modal .modal-content textarea {
        background-color: var(--primary-color);
        color: var(--font-color);
        border: 1px solid var(--border-color);
        padding: 8px;
        border-radius: 4px;
        font-family: var(--font-ui);
    }
    
   
    #virtual-controller-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 150;
        display: none;
    }
    #virtualControllerCanvas {
        display: block;
        width: 100%;
        height: 100%;
        background-color: transparent;
        border: none;
    }
    #vc-edit-controls {
        position: fixed;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 151;
        background: rgba(50, 50, 50, 0.9);
        padding: 10px 20px;
        border-radius: 8px;
        display: flex;
        gap: 15px;
        align-items: center;
    }

.modal-tabs {
    display: flex;
    border-bottom: 2px solid var(--primary-color);
    margin-bottom: 10px;
}
.tab-button {
    flex: 1;
    padding: 10px 15px;
    cursor: pointer;
    background-color: transparent;
    border: none;
    color: var(--font-color);
    font-family: var(--font-display);
    font-size: 16px;
    border-bottom: 3px solid transparent;
    transition: background-color 0.2s, border-color 0.2s;
}
.tab-button:hover {
    background-color: rgba(255, 255, 255, 0.1);
}
.tab-button.active {
    color: var(--primary-hover-color);
    border-bottom: 3px solid var(--primary-hover-color);
}
.tab-content {
    display: none;
}
.tab-content.active {
    display: block;
    animation: fadeIn 0.3s ease-in-out;
}
@keyframes fadeIn {
    from { opacity: 0;
}
    to { opacity: 1; }
}

#debug-console-overlay {
    position: fixed; top: 0;
    left: 0; width: 100%; height: 200px;
    background: rgba(0,0,0,0.8); color: #ff4444; z-index: 9999;
    overflow-y: scroll; font-family: monospace; font-size: 12px;
    pointer-events: none;
    /* クリックを下の要素に通す */
    white-space: pre-wrap; padding: 10px; border-bottom: 2px solid red;
    display: none;
}
#analysis-modal {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.9);
    display: none; justify-content: center; align-items: center; z-index: 250;
}
#analysis-content {
    background-color: var(--bg-color); width: 95%; height: 90%;
    padding: 20px; border-radius: 10px; border: 2px solid var(--primary-color);
    display: flex; flex-direction: column;
}
#analysis-canvas-container {
    flex: 1; position: relative; width: 100%; min-height: 0;
    background-color: #000; border: 1px solid #444; margin-top: 10px;
}
#analysis-stats {
    display: flex; gap: 20px; color: var(--font-color); font-family: monospace; font-size: 14px;
    margin-bottom: 10px; flex-wrap: wrap;
}
</style>
</head>
<body>
<div id="debug-console-overlay"></div>
<script>
    // エラーを画面に表示する仕組み
    (function(){
        const consoleDiv = document.getElementById('debug-console-overlay');
        function logError(msg) {
            consoleDiv.textContent += "ERROR: " + msg + "\n----------------\n";
            consoleDiv.style.display = 'block';
        }
        window.onerror = function(msg, url, line, col, error) {
            logError(`${msg}\nAt: ${line}:${col}\n${error ? error.stack : ''}`);
            return false;
        };
        window.onunhandledrejection = function(e) {
            logError(`Unhandled Promise Rejection: ${e.reason}`);
        };
    })();
</script>

<div class="main-container">
    <div id="editor-container">
        <div class="edit-section top-controls">
<div class="mode-selection">
    <h2>MODE</h2>
    <div class="button active" id="mode-1p">1P</div>
    <div class="button" id="mode-2p">2P</div>
    <button id="settingsBtn" class="button" style="margin-left: 15px;">設定</button>
     <button id="shareBtn" class="button" style="margin-left: 5px;">共有</button>
     <button id="ruleBtn" class="button" style="margin-left: 5px;">ルール</button>
     <button id="swapBtn" class="button" style="margin-left: 5px; display: none;">入れ替え</button>
</div>
            <button id="startGameBtn" class="button">START GAME</button>
        </div>

<div class="player-editors">
            <div class="editor-column" id="p1-editor-col">
                <div class="edit-section next-editor">
                    <h2>PLAYER 1 - NEXT</h2>
                    <div class="mino-icons" id="p1-next-icons"></div>
                    <div class="next-queue-display" id="p1-next-queue"></div>
                    <div class="button-group">
                        <button class="button" id="p1-next-delete-left">Delete</button>
                        <button class="button" id="p1-next-clear">Clear</button>
                    </div>
                </div>
                <div class="edit-section field-editor">
                    <h2>PLAYER 1 - FIELD</h2>
                    <div class="color-palette" id="p1-palette"></div>

<canvas id="field-editor-canvas-p1"></canvas>
                    <div class="field-controls">
                        <button class="button" id="p1-field-shift-up">↑ Up</button>
                        <button class="button" id="p1-field-shift-down">↓ Down</button>
                        <button class="button" id="p1-field-clear">Clear</button>
                        <button class="button" id="p1-field-line-clear">Line Clear</button>
                        <label for="imageLoader-p1" class="button">Img</label>
                        <input type="file" id="imageLoader-p1" data-player="p1" accept="image/*">
                        <label for="pptLoader-p1" class="button">PPT</label>
                        <input type="file" id="pptLoader-p1" data-player="p1" accept="image/*">
                    </div>
<div class="key-config-controls" style="margin-top: 15px; text-align: center; display: flex; justify-content: center; align-items: center; gap: 10px;">
                        <label class="setting-item" style="padding:0; margin:0;">
                            <input type="checkbox" id="p1-ai-toggle">
                            <span>AI</span>
                        </label>
                        <button class="button" id="p1-key-config-btn">操作設定</button>
                    </div>
                </div>
            </div>
<div class="editor-column" id="p2-editor-col" style="display: none;">
                <div class="edit-section next-editor">
                    <h2>PLAYER 2 - NEXT</h2>
                    <div class="mino-icons" id="p2-next-icons"></div>
                    <div class="next-queue-display" id="p2-next-queue"></div>
                    <div class="button-group">
                        <button class="button" id="p2-next-delete-left">Delete</button>
                        <button class="button" id="p2-next-clear">Clear</button>
                    </div>
                </div>
                <div class="edit-section field-editor">
                    <h2>PLAYER 2 - FIELD</h2>
                    <div class="color-palette" id="p2-palette"></div>
<canvas id="field-editor-canvas-p2"></canvas>
                    <div class="field-controls">
                        <button class="button" id="p2-field-shift-up">↑ Up</button>
                        <button class="button" id="p2-field-shift-down">↓ Down</button>
                        <button class="button" id="p2-field-clear">Clear</button>
                        <button class="button" id="p2-field-line-clear">Line Clear</button>
                        <label for="imageLoader-p2" class="button">Img</label>
                        <input type="file" id="imageLoader-p2" data-player="p2" accept="image/*">
                        <label for="pptLoader-p2" class="button">PPT</label>
                        <input type="file" id="pptLoader-p2" data-player="p2" accept="image/*">
                    </div>
<div class="key-config-controls" style="margin-top: 15px; text-align: center; display: flex; justify-content: center; align-items: center; gap: 10px;">
                        <label class="setting-item" style="padding:0; margin:0;">
                            <input type="checkbox" id="p2-ai-toggle">
                            <span>AI</span>
                        </label>
                        <button class="button" id="p2-key-config-btn">操作設定</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

<div id="game-container">
<div id="rule-description-display" style="display: none; position: absolute; z-index: 155; color: var(--font-color); background: rgba(26, 26, 46, 0.9); padding: 15px; border-radius: 10px; border: 2px solid #4b4b7c; font-family: var(--font-ui); font-size: 14px; max-width: 200px; max-height: 400px; overflow-y: auto; box-sizing: border-box; word-wrap: break-word; backdrop-filter: blur(4px);"></div>
<div id="ai-debug-display" style="display: none; position: absolute; z-index: 156; color: white; background: rgba(0,0,0,0.7); padding: 5px; font-family: monospace; font-size: 10px; left: 10px; top: 300px; max-height: 400px; overflow: auto;"></div>

<div id="ai-debug-controls" style="display: none; position: absolute; z-index: 156; color: white; background: rgba(0,0,0,0.7); padding: 5px; font-family: monospace; font-size: 12px;
left: 10px; top: 150px;">
    <input id="ai-debug-piece" placeholder="Piece (T)" size="3">
    <input id="ai-debug-x" placeholder="X" size="2">
    <input id="ai-debug-y" placeholder="Y" size="2">
    <input id="ai-debug-rot" placeholder="Rot" size="2">
    <button id="ai-debug-execute">Execute</button>
</div>
<div id="ai-tree-debug-display" style="display: none; position: fixed; z-index: 157; color: white; background: rgba(0,0,0,0.7); padding: 5px; font-family: monospace; font-size: 12px; left: 10px; top: 10px;"></div>
<canvas id="mainCanvas"></canvas>
<div id="scan-instructions" style="display: none;"></div>

        <div id="scan-controls" style="display: none; margin-top: 15px; gap: 10px; justify-content:center;">
             <button id="scanConfirmBtn" class="button">次へ</button>
             <button id="scanCancelBtn" class="button">キャンセル</button>
        </div>
    </div>
</div>

<div id="game-controls" style="display: none;
position: fixed; top: 10px; right: 10px; z-index: 160; gap: 10px;">
     <button id="analyzeBtn" class="button">分析</button>
     <button id="exportFumenBtn" class="button">記録</button>
     <button id="retryBtn" class="button">リトライ</button>
     <button id="gameSettingsBtn" class="button">設定</button>
     <button id="backToEditorBtn" class="button">戻る</button>
</div>

<div id="analysis-modal">
    <div id="analysis-content">
        <div style="display:flex; justify-content:space-between; align-items:center;">
            <h2>分析</h2>
            <button id="analysis-close" class="button">閉じる</button>
        </div>
        <div id="analysis-stats"></div>
        <div id="analysis-canvas-container">
            <canvas id="analysisCanvas"></canvas>
        </div>
    </div>
</div>

<div id="virtual-controller-container">

    <div id="vc-edit-controls" style="display: none;">
        <button id="vc-save-and-close-btn" class="button">保存して閉じる</button>
    </div>
    <canvas id="virtualControllerCanvas"></canvas>
</div>

<div id="settings-modal">
    <div class="modal-content">
<div class="modal-tabs">
            <button class="tab-button active" data-tab="general">基本設定</button>
            <button class="tab-button" data-tab="p1-keys">1P操作設定</button>
            <button class="tab-button" data-tab="p2-keys" id="p2-keys-tab-btn" style="display: none;">2P操作設定</button>
            <button class="tab-button" data-tab="layout-settings">描画設定</button>
            <button class="tab-button" data-tab="ai-settings">AI設定</button>
        </div>

        <div class="tab-content active" id="tab-content-general">
             <h2 style="margin-top: 20px;"></h2>
             <p></p>
             <div id="settings-list"></div>
        </div>

        <div class="tab-content" id="tab-content-p1-keys">
            <h2 style="margin-top: 20px;">PLAYER 1 - 操作設定</h2>
            <p></p>
            <div id="p1-key-config-list" class="key-config-list-container"></div>
            
            <h3><br>タッチ操作設定 (P1)</h3>
            <p></p>
                        <div id="p1-touch-mode-selection" style="display: flex;
justify-content: center; gap: 10px; margin-bottom: 15px;">
                <button class="button active" data-touch-mode="button">Button</button>
                <button class="button" data-touch-mode="draw">Draw</button>
            </div>
            <div id="p1-touch-draw-controls" style="display: none; margin-top: 15px; justify-content: center;">
                 <div class="setting-item" style="padding: 5px 15px; max-width: 300px;">
                    <label for="draw-move-delay-input">操作間隔 (ms)</label>
                    <input type="number" id="draw-move-delay-input" min="0" max="200" step="1" style="width: 80px; min-width: 80px;">
                </div>
            </div>
            <div class="modal-controls" id="p1-touch-button-controls" style="display: flex;
justify-content: center; gap: 10px; flex-wrap: wrap;">
                <button id="vc-edit-layout-btn" class="button">ボタン配置モードへ</button>
                <button id="vc-copy-layout-btn" class="button">配置をコピー</button>

                <button id="vc-paste-layout-btn" class="button">配置をインポート</button>
            </div>
        </div>
        
        <div class="tab-content" id="tab-content-p2-keys">
         <h2 style="margin-top: 20px;">PLAYER 2 - 操作設定</h2>
            <p></p>
            <div id="p2-key-config-list" class="key-config-list-container"></div>
        </div>

        <div class="tab-content" id="tab-content-layout-settings">
            <h2 style="margin-top: 20px;">描画設定</h2>
            <p></p>
            <div id="layout-settings-list" class="key-config-list-container"></div>
        </div>

        <div class="tab-content" id="tab-content-ai-settings">
            <h2 style="margin-top: 20px;">AI設定</h2>
            <p></p>
            <div id="ai-settings-list" class="key-config-list-container"></div>
        </div>
        
        <div class="modal-controls" style="border-top: 1px solid var(--primary-color); padding-top: 15px; margin-top: 20px;">
            <button id="settings-close" class="button">保存して閉じる</button>
        </div>
    </div>
</div>

<div id="share-modal">
    <div class="modal-content">
        <h2>共有</h2>
        
        <div class="share-section">
            <h3>エクスポート</h3>
            <p></p>
            <div class="share-item">
                <span>共有リンク</span>
                <input type="text" id="share-link-input" readonly style="width: 100%; margin-top: 5px; margin-bottom: 5px; box-sizing: border-box;">
                <div style="display: flex; gap: 10px; margin-top: 5px;">
                    <button id="copy-link-btn" class="button">リンクをコピー</button>
                    <button id="advanced-link-btn" class="button">詳細なリンク生成</button>
                </div>
            </div>
            <div id="advanced-link-options" style="display: none; margin-top: 15px; padding: 10px; background-color: rgba(255,255,255,0.05); border-radius: 5px;">
                <div class="setting-item">
                    <label>
                        <input type="checkbox" id="start-sim-checkbox">
                        <span>シミュレーションを即スタート</span>
                    </label>
                </div>
<div class="setting-item">
                    <label>
                        <input type="checkbox" id="no-hold-checkbox">
                        <span>ホールドを禁止</span>
                    </label>
                </div>
                <div class="setting-item">
                    <label>
                        <input type="checkbox" id="hide-back-btn-checkbox" disabled>
                        <span>戻るボタンを非表示</span>
                    </label>
                </div>
                 <button id="generate-advanced-link-btn" class="button" style="margin-top: 10px;">リンクを再生成</button>
            </div>
        </div>
        
        <hr style="border-color: var(--primary-color); margin: 20px 0;">
        

        <div class="share-section">
            <h3>インポート</h3>
            <p></p>
            <button id="import-from-data-btn" class="button">クリップボードからインポート</button>
        </div>


        <div class="modal-controls">
            <button id="share-close" class="button">閉じる</button>
        </div>
    </div>
</div>

<div id="rule-modal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.75); display: none; justify-content: center; align-items: center; z-index: 200;">
    <div class="modal-content" style="width: 90%; max-width: 700px;">
        <h2>カスタムルール</h2>
        
        <div class="rule-section" style="margin-bottom: 20px;">
            <h3>説明</h3>
            <p style="font-size: 14px; color: #ccc; margin-top: 5px; margin-bottom: 10px;">ここに記述した内容は、ゲーム画面の左側（ホールドの下）に表示されます。</p>
            <textarea id="rule-description-input" style="width: 100%; height: 100px; background-color: var(--primary-color); color: var(--font-color); border: 1px solid var(--border-color); padding: 8px; border-radius: 4px; font-family: var(--font-ui); box-sizing: border-box; resize: vertical;"></textarea>
        </div>

        <div class="rule-section">
            <h3>コード (JS)</h3>
            <p style="font-size: 14px; color: #ccc; margin-top: 5px; margin-bottom: 10px;">ゲームのクリア・オーバー条件などをプログラムで定義します。</p>
            <textarea id="rule-code-input" style="width: 100%; height: 250px; background-color: var(--primary-color); color: var(--font-color); border: 1px solid var(--border-color); padding: 8px; border-radius: 4px; font-family: monospace; box-sizing: border-box; resize: vertical;"></textarea>
        </div>

        <div class="modal-controls" style="border-top: 1px solid var(--primary-color); padding-top: 15px; margin-top: 20px;">
            <button id="rule-save-close" class="button">保存して閉じる</button>
            <button id="rule-close" class="button">キャンセル</button>
        </div>
    </div>
</div>

<script>

const aiWorkerScript = `
const StandardWeights = {
    //盤面評価系
    back_to_back: 52,
    bumpiness: -24,
    bumpiness_sq: -7,
    row_transitions: -5,
    height: -39,
    top_half: -150,
    top_quarter: -511,
    jeopardy: -11,
    cavity_cells: -173,
    cavity_cells_sq: -3,
    overhang_cells: -34,
    overhang_cells_sq: -1,
    covered_cells: -17,
    covered_cells_sq: -1,
    tslot: [8, 148, 192, 407],
    well_depth: 57,
    max_well_depth: 17,
    well_column: [20, 23, 20, 50, 59, 21, 59, 10, -10, 24],

    // 行動評価系
    b2b_clear: 104,
    clear1: -263,
    clear2: -220,
    clear3: -178,
    clear4: 270,
    tspin1: 1,
    tspin2: 290,
    tspin3: 482,
    mini_tspin1: -158,
    mini_tspin2: -93,
    perfect_clear: 999,
    combo_garbage: 150,
    wasted_t: -152,

    //REN
    COMBO_GARBAGE: [0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 4, 5],
};

const weights = StandardWeights;
const MOVE_DIGITS = 5;
const MAX_SEARCH_DEPTH = 15;
const PLAYFIELD_HEIGHT = 20;

//ホールド判定(おそらく全てのホールドに対応)
function judgeAvailableMinos(
    originalMinoSequence,
    usedMinos
) {
    const judge = [...originalMinoSequence];
    const remainingMinos = [...originalMinoSequence];
    for (const used_mino of usedMinos) {
        const it_index = remainingMinos.indexOf(used_mino);
        if (it_index !== -1) {
            remainingMinos.splice(it_index, 1); //最初に合致したものだけ削除
        }
    }

    //残ったミノの先頭2つを返す
    const available = [];
    if (remainingMinos.length > 0) available.push(remainingMinos[0]);
    if (remainingMinos.length >= 2) available.push(remainingMinos[1]);

    return available;
}

function makeID(baseID, moveIndex) {
  return baseID + String(moveIndex).padStart(MOVE_DIGITS, '0');
}

class TetrisBoard {
    static WIDTH = 10;
    static HEIGHT = 40;

    constructor(initialRows = null) {
        this.rows = new Uint16Array(TetrisBoard.HEIGHT).fill(0);
        if (initialRows) {
            for (let i = 0; i < TetrisBoard.HEIGHT; ++i) {
                this.rows[i] = initialRows[i];
            }
        }
    }

    clone() {
        const newBoard = new TetrisBoard();
        newBoard.rows.set(this.rows);
        return newBoard;
    }

    isFilled(row, col) {
        if (row < 0 || row >= TetrisBoard.HEIGHT || col < 0 || col >= TetrisBoard.WIDTH) return true;
        return (this.rows[row] & (1 << col)) !== 0;
    }

    fill(row, col) {
        if (row >= 0 && row < TetrisBoard.HEIGHT && col >= 0 && col < TetrisBoard.WIDTH) {
            this.rows[row] |= (1 << col);
        }
    }

    clear(row, col) {
        if (row >= 0 && row < TetrisBoard.HEIGHT && col >= 0 && col < TetrisBoard.WIDTH) {
            this.rows[row] &= ~(1 << col);
        }
    }

    isLineFull(row) {
        if (row < 0 || row >= TetrisBoard.HEIGHT) return false;
        return (this.rows[row] & ((1 << TetrisBoard.WIDTH) - 1)) === ((1 << TetrisBoard.WIDTH) - 1);
    }

    clearLine(targetRow) {
        if (targetRow < 0 || targetRow >= TetrisBoard.HEIGHT) return;
        for (let r = targetRow; r < TetrisBoard.HEIGHT - 1; ++r) {
            this.rows[r] = this.rows[r + 1];
        }
        this.rows[TetrisBoard.HEIGHT - 1] = 0;
    }

    clearFullLines() {
        let cleared = 0;
        let r = 0;
        while (r < TetrisBoard.HEIGHT) {
            if (this.isLineFull(r)) {
                this.clearLine(r);
                cleared++;
            } else {
                r++;
            }
        }
        return cleared;
    }
}


// Placement, Node are defined as plain objects.

let nodeMap = new Map();
let searchStartTime = 0;
let bestNodeIDAtDepth1 = "";
let maxEvaluationAtDepth1 = -Number.MAX_VALUE;

function propagateEvaluation(nodeID) {
    let currentPropagateTargetID = nodeID;

    while (nodeMap.has(currentPropagateTargetID)) {
        const S = nodeMap.get(currentPropagateTargetID);

        if (isDepthLevel(currentPropagateTargetID, 1)) {
            if (S.acc_eval + S.transient_eval > maxEvaluationAtDepth1) {
                maxEvaluationAtDepth1 = S.acc_eval + S.transient_eval;
                bestNodeIDAtDepth1 = currentPropagateTargetID;
            }
        }

        const parentID = S.parentID;
        if (parentID === undefined || !nodeMap.has(parentID)) {
            break;
        }

        const P = nodeMap.get(parentID);
        let max_value_from_children = -Number.MAX_VALUE;
        let parent_has_valid_children = false;

        if (P.childrenIDs.length > 0) {
            for (const child_id_of_P of P.childrenIDs) {
                if (nodeMap.has(child_id_of_P)) {
                    const child_node = nodeMap.get(child_id_of_P);
                    max_value_from_children = Math.max(max_value_from_children, child_node.acc_eval + child_node.transient_eval);
                    parent_has_valid_children = true;
                }
            }
        }

        if (parent_has_valid_children) {
            if (P.transient_eval < max_value_from_children) {
                P.transient_eval = max_value_from_children;
                currentPropagateTargetID = parentID;
            } else {
                break;
            }
        } else {
            break;
        }
    }
}

function getMinoShape(pieceType, rotation) {
    rotation = rotation % 4;
    switch (pieceType) { //間違えて(y,x)で作ってしまったので、後に辻褄合わせをしてある
        case 'I':
            if (rotation == 1|| rotation == 3) {
                return [[0,0], [0, 1], [0, 2], [0,3]];
            } else {
                return [[0,0], [1, 0], [2, 0], [3, 0]];
            }
        case 'O':
            return [[0,0], [1, 0], [0, 1], [1, 1]];
        case 'T':
            if (rotation == 1) return [[0,0], [0, -1], [0, 1], [1, 0]];
            if (rotation == 2) return [[0,0], [1, 0], [-1, 0], [0, -1]];
            if (rotation == 3) return [[0,0], [0, -1], [0, 1], [-1, 0]];
            if (rotation == 0) return [[0,0], [1, 0], [-1, 0], [0, 1]];
            break;
        case 'S':
            if (rotation == 1 || rotation == 3) return [[0,0], [1, -1], [1, 0], [0, 1]];
            if (rotation == 0 || rotation == 2) return [[0,0], [-1, 0], [1, 1], [0, 1]];
            break;
        case 'Z':
            if (rotation == 1 || rotation == 3) return [[0,0], [-1, -1], [-1, 0], [0, 1]];
            if (rotation == 0 || rotation == 2) return [[0,0], [1, 0], [-1, 1], [0, 1]];
            break;
        case 'J':
            if (rotation == 0) return [[0,0], [-1, 0], [1, 0], [-1, 1]];
            if (rotation == 1) return [[0,0], [0, -1], [1, 1], [0, 1]];
            if (rotation == 2) return [[0,0], [1, 0], [-1, 0], [1, -1]];
            if (rotation == 3) return [[0,0], [0, -1], [-1, -1], [0, 1]];
            break;
        case 'L':
            if (rotation == 0) return [[0,0], [-1, 0], [1, 0], [1, 1]];
            if (rotation == 1) return [[0,0], [0, -1], [1, -1], [0, 1]];
            if (rotation == 2) return [[0,0], [1, 0], [-1, 0], [-1, -1]];
            if (rotation == 3) return [[0,0], [0, -1], [-1, 1], [0, 1]];
            break;
        default:
            return [[0,0]];
    }
    return [[0,0]];
}

function checkCollision(board, pieceType, rotation, x_pivot, y_pivot) {
    const shapeWithPivot = getMinoShape(pieceType, rotation);

    for (const blockOffset of shapeWithPivot) {
        const blockY = y_pivot + blockOffset[1]; //辻褄合わせの為second(1)とfirst(0)を逆にしてるけどこれで正しい
        const blockX = x_pivot + blockOffset[0];

        if (board.isFilled(blockY, blockX)) {
            return true;
        }
    }
    return false;
}

function placeMinoOnBoard(board, pieceType, p) {
    const shapeWithPivot = getMinoShape(pieceType, p.rotation);
    for(const offset of shapeWithPivot) {
        board.fill(p.y + offset[1], p.x + offset[0]);//逆にしてるけどこれが正しい
    }
}

function getColumnHeights(board) {
    const heights = new Array(TetrisBoard.WIDTH).fill(0);
    for (let c = 0; c < TetrisBoard.WIDTH; ++c) {
        for (let r = TetrisBoard.HEIGHT - 1; r >= 0; --r) {
            if (board.isFilled(r, c)) {
                heights[c] = r + 1;
                break;
            }
        }
    }
    return heights;
}

function calculateBumpiness(board, wellColumn) {
    const heights = getColumnHeights(board);
    let bumpiness_val = 0;
    let bumpiness_sq_val = 0;
    let prev_col_idx;
    if (wellColumn === 0) {
        prev_col_idx = 1;
    } else {
        prev_col_idx = 0;
    }

    while (prev_col_idx < TetrisBoard.WIDTH && prev_col_idx === wellColumn) {
        prev_col_idx++;
    }
    if (prev_col_idx >= TetrisBoard.WIDTH) {
        return [0, 0];
    }
    let current_height = heights[prev_col_idx];

    for (let i = prev_col_idx + 1; i < TetrisBoard.WIDTH; ++i) {
        if (i === wellColumn) {
            continue;
        }
        const dh = Math.abs(heights[i] - current_height);
        bumpiness_val += dh;
        bumpiness_sq_val += dh * dh;
        current_height = heights[i];
    }
    return [bumpiness_val, bumpiness_sq_val];
}

function calculateCavitiesAndOverhangs(board) {
    const heights = getColumnHeights(board);
    let cavities = 0;
    let overhangs = 0;

    let max_board_height = 0;
    for (const h of heights) {
        max_board_height = Math.max(max_board_height, h);
    }
    if (max_board_height === 0) return [0,0];

    for (let y = 0; y < max_board_height; ++y) {
        for (let x = 0; x < TetrisBoard.WIDTH; ++x) {
            if (board.isFilled(y, x) || y >= heights[x]) {
                continue;
            }
            let counted_as_overhang = false;
            if (x > 1) {
                if (heights[x - 1] <= y && heights[x - 2] <= (y + 1)) {
                    overhangs++;
                    counted_as_overhang = true;
                }
            }
            if (counted_as_overhang) continue;
            if (x < TetrisBoard.WIDTH - 2) {
                if (heights[x + 1] <= y && heights[x + 2] <= (y + 1)) {
                    overhangs++;
                    counted_as_overhang = true;
                }
            }
            if (counted_as_overhang) continue;
            cavities++;
        }
    }
    return [cavities, overhangs];
}

function calculateCoveredCells(board) {
    const heights = getColumnHeights(board);
    let covered = 0;
    let covered_sq = 0;

    for (let x = 0; x < TetrisBoard.WIDTH; ++x) {
        if (heights[x] <= 1) {
            continue;
        }
        for (let y = heights[x] - 2; y >= 0; --y) {
            if (!board.isFilled(y, x)) {
                const cells_above_hole = heights[x] - (y + 1);
                const actual_cells_counted = Math.min(6, cells_above_hole);
                covered += actual_cells_counted;
                covered_sq += actual_cells_counted * actual_cells_counted;
            }
        }
    }
    return [covered, covered_sq];
}

function countSetBits(n) {
    let count = 0;
    while (n > 0) {
        n &= (n - 1);
        count++;
    }
    return count;
}

function calculateRowTransitions(board) {
     let rust_transitions = 0;
     for (let y = 0; y < TetrisBoard.HEIGHT; ++y) {
         const r = board.rows[y];
         const d = (r | (1 << TetrisBoard.WIDTH)) ^ (1 | (r << 1));
         rust_transitions += countSetBits(d);
     }
     return rust_transitions;
}

function calculateWell(board) {
    const heights = getColumnHeights(board);
    let well_col = -1;
    let min_h = TetrisBoard.HEIGHT + 1;

    for (let c = 0; c < TetrisBoard.WIDTH; ++c) {
        if (heights[c] < min_h) {
            min_h = heights[c];
            well_col = c;
        }
    }

    let depth = 0;
    if (well_col !== -1) {
        for (let y = heights[well_col]; y < TetrisBoard.HEIGHT; ++y) {
            let is_well_row = true;
            for (let x = 0; x < TetrisBoard.WIDTH; ++x) {
                if (x !== well_col && !board.isFilled(y, x)) {
                    is_well_row = false;
                    break;
                }
            }
            if (is_well_row) {
                depth++;
            } else {
                break;
            }
        }
    }
    depth = Math.min(depth, weights.max_well_depth);
    return [depth, well_col];
}

function check_sides(board, x, y) {
    for (let dx = 1; dx <= 9; ++dx) {
        if (x - dx < 0 || x + dx >= TetrisBoard.WIDTH) return false;
        if (!board.isFilled(y, x - dx) || !board.isFilled(y, x + dx)) {
            return false;
        }
    }
    return true;
}

function check_top(board, x, y) {
    for (let check_y = y + 1; check_y < 25; ++check_y) {
        if (board.isFilled(check_y, x)) {
            return false;
        }
    }
    return true;
}

function get_tslot_score(count) {
    if (count >= 3) return weights.tslot[3];
    if (count === 2) return weights.tslot[2];
    if (count === 1) return weights.tslot[1];
    return weights.tslot[0];
}

function calculateTslots(board) {
    let t_slot_score = 0.0;
    for (let y = 0; y < TetrisBoard.HEIGHT; ++y) {
        for (let x = 0; x < TetrisBoard.WIDTH; ++x) {
            const is_filled = (dx, dy) => {
                return board.isFilled(y + dy, x + dx);
            };

            // TSD
            if (!is_filled(-1, 0) && is_filled(1, -1) && is_filled(-1, -1) && is_filled(-1, 1)) {
                if (check_top(board, x, y) && check_top(board, x + 1, y)) {
                    let count = 0;
                    if (check_sides(board, x, y)) count++;
                    if (check_sides(board, x, y - 1)) count++;
                    t_slot_score += (count === 2) ? weights.tslot[2] : ((count === 1) ? weights.tslot[1] : weights.tslot[0]);
                }
            }
            // TSD
            if (!is_filled(1, 0) && is_filled(1, -1) && is_filled(-1, -1) && is_filled(1, 1)) {
                if (check_top(board, x, y) && check_top(board, x - 1, y)) {
                    let count = 0;
                    if (check_sides(board, x, y)) count++;
                    if (check_sides(board, x, y - 1)) count++;
                     t_slot_score += (count === 2) ? weights.tslot[2] : ((count === 1) ? weights.tslot[1] : weights.tslot[0]);
                }
            }
        }
    }
    return t_slot_score;
}

function isPerfectClear(board){
    return board.rows[0] === 0;
}

function evaluate(
    board,
    lastPlacement,
    linesCleared,
    isKick,
    softDropCount,
    currentCombo,
    currentB2BActive
){
    let acc_eval = 0.0;
    let transient_eval = 0.0;
    
    if (isPerfectClear(board) === true) acc_eval += weights.perfect_clear;

    if (true) {
        if (currentB2BActive && linesCleared > 0) {
            acc_eval += weights.b2b_clear;
        }
        if (currentCombo > 0) {
            const combo_idx = Math.min(currentCombo, weights.COMBO_GARBAGE.length - 1);
            acc_eval += weights.combo_garbage * weights.COMBO_GARBAGE[combo_idx];
        }

        if (isKick && lastPlacement.pieceType === 'T') {
            if (linesCleared === 1) acc_eval += weights.tspin1;
            else if (linesCleared === 2) acc_eval += weights.tspin2;
            else if (linesCleared === 3) acc_eval += weights.tspin3;
        } else if (isKick ) {
            if (linesCleared === 1) acc_eval += weights.clear1;
            else if (linesCleared === 2) acc_eval += weights.clear2;
            else if (linesCleared === 3) acc_eval += weights.clear3;
        }
        else {
            if (linesCleared === 1) acc_eval += weights.clear1;
            else if (linesCleared === 2) acc_eval += weights.clear2;
            else if (linesCleared === 3) acc_eval += weights.clear3;
            else if (linesCleared === 4) acc_eval += weights.clear4;
        }
    }

    if (lastPlacement.pieceType === 'T' && (linesCleared === 0 || !isKick)) {
        acc_eval += weights.wasted_t;
    }

    if (currentB2BActive) {
        transient_eval += weights.back_to_back;
    }

    const heights = getColumnHeights(board);
    let highest_point = 0;
    for(const h of heights) highest_point = Math.max(highest_point, h);

    transient_eval += weights.top_quarter * Math.max(0, highest_point - 15);
    transient_eval += weights.top_half * Math.max(0, highest_point - 10);
    transient_eval += weights.height * highest_point;
    transient_eval += weights.jeopardy * Math.max(0, highest_point - 10);
    transient_eval += calculateTslots(board);

    const [well_d, well_c] = calculateWell(board);
    transient_eval += weights.well_depth * well_d;
    if (well_d > 0 && well_c >= 0 && well_c < weights.well_column.length) {
        transient_eval += weights.well_column[well_c];
    }

    transient_eval += weights.row_transitions * calculateRowTransitions(board);

    const [bump, bump_sq] = calculateBumpiness(board, well_c);
    transient_eval += bump * weights.bumpiness;
    transient_eval += bump_sq * weights.bumpiness_sq;

    const [cav, over] = calculateCavitiesAndOverhangs(board);
    transient_eval += weights.cavity_cells * cav;
    transient_eval += weights.cavity_cells_sq * cav * cav;
    transient_eval += weights.overhang_cells * over;
    transient_eval += weights.overhang_cells_sq * over * over;

    const [cov, cov_sq] = calculateCoveredCells(board);
    transient_eval += weights.covered_cells * cov;
    transient_eval += weights.covered_cells_sq * cov_sq;

    return [acc_eval, transient_eval];
}

function createAndAddChildNode(
    parentNodeID,
    boardStateAtParent,
    p,
    isKick,
    childrenGenerated
) {
    if (!nodeMap.has(parentNodeID)) return;
    const parentNode = nodeMap.get(parentNodeID);
    
    const childID = makeID(parentNodeID, parentNode.childrenIDs.length);

    const childNode = {
        board: null,
        acc_eval: 0.0,
        transient_eval: -Number.MAX_VALUE,
        place: p,
        expanded: false,
        childrenIDs: [],
        parentID: parentNodeID,
        softDropCount: 0,
        comboCount: 0,
        B2B: false,
    };

    if (p.y >= PLAYFIELD_HEIGHT) childNode.softDropCount = 0;
    else childNode.softDropCount = Math.max(0, (PLAYFIELD_HEIGHT - 1) - p.y);

    const boardAfterPlace = boardStateAtParent.clone();
    placeMinoOnBoard(boardAfterPlace, p.pieceType, p);
    const linesCleared = boardAfterPlace.clearFullLines();

    childNode.board = boardAfterPlace;

    const parentActualNode = nodeMap.get(parentNodeID);

    if (linesCleared > 0) {
        childNode.comboCount = parentActualNode.comboCount + 1;
    } else {
        childNode.comboCount = 0;
    }

    const moveWasSpecialForB2B = (isKick && p.pieceType === 'T' && linesCleared > 0) || (linesCleared >= 4);
    if (moveWasSpecialForB2B) {
        childNode.B2B = true;
    } else {
        childNode.B2B = (linesCleared > 0) ? false : parentActualNode.B2B;
    }

    const [acc_val, transient_val] = evaluate(
        boardAfterPlace,
        p,
        linesCleared,
        isKick,
        childNode.softDropCount,
        childNode.comboCount,
        childNode.B2B
    );
    childNode.acc_eval = acc_val;
    childNode.transient_eval = transient_val;

    nodeMap.set(childID, childNode);
    nodeMap.get(parentNodeID).childrenIDs.push(childID);
    childrenGenerated.push([childID, p]);

    propagateEvaluation(childID);
}

function checkRotationKicks(
    board,
    x_pivot,
    y_pivot,
    pieceType,
    currentRotation,
    parentNodeID,
    childrenGenerated
) {
    let kickNodeCreated = false;
    const is_filled = (dx, dy) => {
        return board.isFilled(y_pivot + dy, x_pivot + dx);
    };

    if (pieceType === 'L' && currentRotation === 3) {
        if ((is_filled(0, -2) || is_filled(-1, -2) || is_filled(-2, -2))&& !is_filled(-2, -1) && !is_filled(-1, -1) && is_filled(-1, 0)) {
            createAndAddChildNode(parentNodeID, board, {x: x_pivot - 1, y: y_pivot - 1, rotation: 0, pieceType: 'L'}, true, childrenGenerated);
            kickNodeCreated = true;
        }
    }

    if (pieceType === 'J' && currentRotation === 1) {
        if ((is_filled(0, -2) || is_filled(1, -2) || is_filled(2, -2))&& !is_filled(2, -1) && !is_filled(1, -1) && is_filled(1, 0)) {
            createAndAddChildNode(parentNodeID, board, {x: x_pivot + 1, y: y_pivot - 1, rotation: 0, pieceType: 'J'}, true, childrenGenerated);
            kickNodeCreated = true;
        }
    }
    if (pieceType === 'S' && currentRotation === 0) {
        if (is_filled(1, 0) && is_filled(0, -1) && is_filled(0, -4) &&
            !is_filled(-1, -1) && !is_filled(-1, -2) && !is_filled(0, -2) && !is_filled(0, -3)) {
            createAndAddChildNode(parentNodeID, board, {x: x_pivot - 1, y: y_pivot - 2, rotation: 1, pieceType: 'S'}, true, childrenGenerated);
            kickNodeCreated = true;
        }
    }
    if (pieceType === 'Z' && currentRotation === 0) {
        if (is_filled(-1, 0) && is_filled(0, -1) && is_filled(0, -4) &&
            !is_filled(1, -1) && !is_filled(1, -2) && !is_filled(0, -2) && !is_filled(0, -3)) {
            createAndAddChildNode(parentNodeID, board, {x: x_pivot + 1, y: y_pivot - 2, rotation: 1, pieceType: 'Z'}, true, childrenGenerated);
            kickNodeCreated = true;
        }
    }
    if (pieceType === 'S' && currentRotation === 1) {
        if (is_filled(0, -1) && (is_filled(0, -3) || is_filled(1, -3)) &&
            !is_filled(0, -2) && !is_filled(1, -2) && !is_filled(2, -1)) {
            createAndAddChildNode(parentNodeID, board, {x: x_pivot + 1, y: y_pivot - 2, rotation: 0, pieceType: 'S'}, true, childrenGenerated);
            kickNodeCreated = true;
        }
    }
    if (pieceType === 'Z' && currentRotation === 1) {
        if (is_filled(0, -1) && (is_filled(0, -3) || is_filled(-1, -3)) &&
            !is_filled(0, -2) && !is_filled(-1, -2) && !is_filled(-2, -1)) {
            createAndAddChildNode(parentNodeID, board, {x: x_pivot - 1, y: y_pivot - 2, rotation: 0, pieceType: 'Z'}, true, childrenGenerated);
            kickNodeCreated = true;
        }
    }
    if (pieceType === 'T' && currentRotation === 1) {
        if (!is_filled(-1, 0) && is_filled(1, -1) && is_filled(-1, -1) && is_filled(-1, 1)) {
            createAndAddChildNode(parentNodeID, board, {x: x_pivot, y: y_pivot, rotation: 2, pieceType: 'T'}, true, childrenGenerated);
            createAndAddChildNode(parentNodeID, board, {x: x_pivot, y: y_pivot, rotation: 0, pieceType: 'T'}, true, childrenGenerated);
            kickNodeCreated = true;
        }
    }
    if (pieceType === 'T' && currentRotation === 3) {
        if (!is_filled(1, 0) && is_filled(1, -1) && is_filled(-1, -1) && is_filled(1, 1)) {
            createAndAddChildNode(parentNodeID, board, {x: x_pivot, y: y_pivot, rotation: 2, pieceType: 'T'}, true, childrenGenerated);
            createAndAddChildNode(parentNodeID, board, {x: x_pivot, y: y_pivot, rotation: 0, pieceType: 'T'}, true, childrenGenerated);
            kickNodeCreated = true;
        }
    }
    if (pieceType === 'T' && currentRotation === 0) {
        if (!is_filled(2, -1) && !is_filled(2, -2) && !is_filled(2, -3) && !is_filled(1, -2) &&
            is_filled(2, 1) && is_filled(1, -1) && is_filled(2, -4)) {
            createAndAddChildNode(parentNodeID, board, {x: x_pivot + 2, y: y_pivot - 2, rotation: 3, pieceType: 'T'}, true, childrenGenerated);
            kickNodeCreated = true;
        }
        if (!is_filled(-2, -1) && !is_filled(-2, -2) && !is_filled(-2, -3) && !is_filled(-1, -2) &&
            is_filled(-2, 1) && is_filled(-1, -1) && is_filled(-2, -4)) {
            createAndAddChildNode(parentNodeID, board, {x: x_pivot - 2, y: y_pivot - 2, rotation: 1, pieceType: 'T'}, true, childrenGenerated);
            kickNodeCreated = true;
        }
    }
    if (pieceType === 'T' && currentRotation === 1) { // TST Wall East
        if (!is_filled(2, -2) && !is_filled(2, -3) && !is_filled(2, -4) && !is_filled(1, -3) && !is_filled(2, -1) && !is_filled(1, -1) &&
            is_filled(2, 0) && is_filled(-1, 0) && is_filled(1, -2) && is_filled(2,-5)) {
            createAndAddChildNode(parentNodeID, board, {x: x_pivot + 2, y: y_pivot - 3, rotation: 3, pieceType: 'T'}, true, childrenGenerated);
            kickNodeCreated = true;
        }
    }
    if (pieceType === 'T' && currentRotation === 3) { // TST Wall West
        if (!is_filled(-2, -2) && !is_filled(-2, -3) && !is_filled(-2, -4) && !is_filled(-1, -3) && !is_filled(-2, -1) && !is_filled(-1, -1) &&
            is_filled(-2, 0) && is_filled(1, 0) && is_filled(-1, -2) && is_filled(-2,-5)) {
            createAndAddChildNode(parentNodeID, board, {x: x_pivot - 2, y: y_pivot - 3, rotation: 1, pieceType: 'T'}, true, childrenGenerated);
            kickNodeCreated = true;
        }
    }
    return kickNodeCreated;
}

function expand(
    parentNodeID,
    boardStateAtParent,
    pieceToPlace,
    pathPlacementsToParent
) {
    const childrenGenerated = [];
    if (!nodeMap.has(parentNodeID)) return childrenGenerated;

    for (let x_pivot = -2; x_pivot < TetrisBoard.WIDTH + 2; ++x_pivot) {
        for (let r = 0; r < 4; ++r) {
            let skip_this_x_r_combination = false;

            if (pieceToPlace === 'O' && r > 0) continue;
            if ((pieceToPlace === 'I' || pieceToPlace === 'S' || pieceToPlace === 'Z') && r > 1) continue;

            let landing_y = -1;
            let max_relative_y = 0;
            for(const offset of getMinoShape(pieceToPlace, r)){
                if(offset[1] > max_relative_y) max_relative_y = offset[1];
            }
            let initial_y_candidate = PLAYFIELD_HEIGHT + max_relative_y;

            for (let y_candidate = initial_y_candidate; y_candidate >= -(TetrisBoard.HEIGHT - PLAYFIELD_HEIGHT) ; --y_candidate) {
                if (!checkCollision(boardStateAtParent, pieceToPlace, r, x_pivot, y_candidate)) {
                    if (checkCollision(boardStateAtParent, pieceToPlace, r, x_pivot, y_candidate - 1)) {
                        landing_y = y_candidate;
                        break;
                    }
                } else {
                    let all_blocks_above_playfield = true;
                    for(const offset of getMinoShape(pieceToPlace, r)){
                        if (y_candidate + offset[1] < PLAYFIELD_HEIGHT){
                            all_blocks_above_playfield = false;
                            break;
                        }
                    }
                    if (all_blocks_above_playfield && y_candidate >= PLAYFIELD_HEIGHT -1 - max_relative_y) {
                    } else if (y_candidate >= PLAYFIELD_HEIGHT -1 - max_relative_y) {
                        skip_this_x_r_combination = true;
                        break;
                    }
                }
            }

            if (skip_this_x_r_combination || landing_y === -1) {
                continue;
            }

            const kickNodeWasCreated = checkRotationKicks(
                boardStateAtParent,
                x_pivot,
                landing_y,
                pieceToPlace,
                r,
                parentNodeID,
                childrenGenerated
            );

            if (!kickNodeWasCreated) {
                 const currentPlacement = {x: x_pivot, y: landing_y, rotation: r, pieceType: pieceToPlace};
                 createAndAddChildNode(
                    parentNodeID,
                    boardStateAtParent,
                    currentPlacement,
                    false,
                    childrenGenerated
                 );
            }
        }
    }
    
    const parentNode = nodeMap.get(parentNodeID);
    if (parentNode && parentNode.childrenIDs.length > 0) {
        parentNode.expanded = true;
    }
    return childrenGenerated;
}

function isDepthLevel(id, depth) {
    return id.length === depth * MOVE_DIGITS;
}

function select(parentNodeID) {
    if (!nodeMap.has(parentNodeID)) {
        return "";
    }

    const children_ids = nodeMap.get(parentNodeID).childrenIDs;
    if (children_ids.length === 0) {
        return "";
    }

    const child_evals = [];
    let Emin = Number.MAX_VALUE;
    let first_valid_child = true;

    for (const id of children_ids) {
        if (nodeMap.has(id)) {
            const child_node = nodeMap.get(id);
            const current_eval = child_node.acc_eval + child_node.transient_eval;
            child_evals.push({id: id, eval: current_eval});
            if (first_valid_child) {
                Emin = current_eval;
                first_valid_child = false;
            } else {
                if (current_eval < Emin) {
                    Emin = current_eval;
                }
            }
        }
    }

    if (child_evals.length === 0) {
        return "";
    }

    child_evals.sort((a, b) => b.eval - a.eval);

    const weights_for_selection = [];
    let totalWeight = 0.0;

    for (let i = 0; i < child_evals.length; ++i) {
        const E_I = child_evals[i].eval;
        const rank_I = i + 1.0;
        const numerator = Math.pow(E_I - Emin + 1.0, 2) + 10.0;
        const denominator = Math.pow(rank_I - 1.0, 2) + 1.0;
        const weight_val = numerator / denominator;
        weights_for_selection.push(weight_val);
        totalWeight += weight_val;
    }

    if (totalWeight === 0.0 || child_evals.length === 0) {
        if (child_evals.length === 0) return "";
        return child_evals[0].id;
    }

    const r = Math.random() * totalWeight;

    let cumulativeWeight = 0.0;
    for (let i = 0; i < child_evals.length; ++i) {
        cumulativeWeight += weights_for_selection[i];
        if (r <= cumulativeWeight) {
            return child_evals[i].id;
        }
    }
    if (child_evals.length > 0) return child_evals[child_evals.length - 1].id;
    return "";
}

function runAI(initialBoard, minoSequence, isB2B, ren) {
    bestNodeIDAtDepth1 = "";
    maxEvaluationAtDepth1 = -Number.MAX_VALUE;
    searchStartTime = performance.now();

    const rootID = "";

    if (!nodeMap.has(rootID)) {
        const rootNodeSpecs = {
            board: null,
            acc_eval: 0.0,
            transient_eval: -Number.MAX_VALUE,
            place: {},
            expanded: false,
            childrenIDs: [],
            parentID: undefined,
            softDropCount: 0,
            comboCount: ren,
            B2B: isB2B,
        };
        nodeMap.set(rootID, rootNodeSpecs);
    }

    nodeMap.get(rootID).board = initialBoard;
    
    const availableMinos = judgeAvailableMinos(minoSequence, []);
    const expandedMinos = {};
    if(nodeMap.has(rootID)){
        for(const childId of nodeMap.get(rootID).childrenIDs){
            if(nodeMap.has(childId)){
                expandedMinos[nodeMap.get(childId).place.pieceType] = true;
            }
        }
    }
    for (const pieceForExpansion of availableMinos) {
        if (!expandedMinos[pieceForExpansion]) {
            expand(rootID, initialBoard, pieceForExpansion, []);
        }
    }

    if (nodeMap.has(rootID)) {
        for (const childID of nodeMap.get(rootID).childrenIDs) {
            if (nodeMap.has(childID)) {
                const childNode = nodeMap.get(childID);
                const current_child_eval = childNode.acc_eval + childNode.transient_eval;
                
                if (current_child_eval > maxEvaluationAtDepth1) {
                    maxEvaluationAtDepth1 = current_child_eval;
                    bestNodeIDAtDepth1 = childID;
                }
            }
        }
    }
}

function pruneAndReroot(chosenNodeID) {
    if (chosenNodeID === "" || !nodeMap.has(chosenNodeID)) {
        nodeMap.clear();
        return;
    }

    const new_nodeMap = new Map();
    const q = [chosenNodeID]; // Queue simulation

    const newRootNode = { ...nodeMap.get(chosenNodeID) };
    const newRootID = "";
    newRootNode.parentID = undefined; 
    
    const newChildrenIDs = [];
    for (const oldChildID of newRootNode.childrenIDs) {
        if (nodeMap.has(oldChildID)) {
            newChildrenIDs.push(oldChildID.substring(chosenNodeID.length));
        }
    }
    newRootNode.childrenIDs = newChildrenIDs;
    new_nodeMap.set(newRootID, newRootNode);

    while (q.length > 0) {
        const oldParentID = q.shift();
        const oldParentNode = nodeMap.get(oldParentID);

        for (const oldChildID of oldParentNode.childrenIDs) {
            if (!nodeMap.has(oldChildID)) {
                continue;
            }
            
            const newChildID = oldChildID.substring(chosenNodeID.length);
            const newParentID = oldParentID.substring(chosenNodeID.length);
            
            const newNode = { ...nodeMap.get(oldChildID) };
            newNode.parentID = newParentID;
            
            const newGrandChildrenIDs = [];
            for(const oldGrandChildID of newNode.childrenIDs) {
                 if (nodeMap.has(oldGrandChildID)) {
                    newGrandChildrenIDs.push(oldGrandChildID.substring(chosenNodeID.length));
                }
            }
            newNode.childrenIDs = newGrandChildrenIDs;
            
            new_nodeMap.set(newChildID, newNode);
            
            q.push(oldChildID);
        }
    }
    

    nodeMap = new_nodeMap;
}

function boardsAreEqual(board1, board2) {
    if (!board1 || !board2) return false;
    for (let i = 0; i < TetrisBoard.HEIGHT; i++) {
        if (board1.rows[i] !== board2.rows[i]) {
            return false;
        }
    }
    return true;
}

let isThinking = false;
let currentMinoSequence = [];

function thinkingLoop() {
    if (!isThinking) return;

    for (let i = 0; i < 100; i++) {
        const rootID = "";
        let selectedNodeID = rootID;
        let depthOfSelectedNode = 0;
        let placementsToSelectedNode = [];
        let usedMinosOnPath = [];
        while (nodeMap.has(selectedNodeID) && nodeMap.get(selectedNodeID).expanded) {
            if (depthOfSelectedNode >= MAX_SEARCH_DEPTH) {
                break;
            }
            const childNodeID = select(selectedNodeID);
            if (childNodeID === "" || !nodeMap.has(childNodeID)) {
                break;
            }
            placementsToSelectedNode.push(nodeMap.get(childNodeID).place);
            usedMinosOnPath.push(nodeMap.get(childNodeID).place.pieceType);
            selectedNodeID = childNodeID;
            depthOfSelectedNode++;
        }
        
        const selectedNode = nodeMap.get(selectedNodeID);
        if (selectedNode && !selectedNode.expanded) {
            if (depthOfSelectedNode < MAX_SEARCH_DEPTH) {
                const boardStateForExpansion = selectedNode.board;
                const availableMinosForExpand = judgeAvailableMinos(currentMinoSequence, usedMinosOnPath);
                if (availableMinosForExpand.length > 0) {
                    for (const pieceForExpansion of availableMinosForExpand) {
                        expand(selectedNodeID, boardStateForExpansion, pieceForExpansion, placementsToSelectedNode);
}
                }
            }
        }
    }

    self.postMessage({ type: 'nodeCount', count: nodeMap.size });
    setTimeout(thinkingLoop, 0);
}

self.onmessage = (e) => {
    const { type, boardString, nextString, isB2B, ren } = e.data;
if (type === 'start') {
        const createBoardFromLayout = (layout) => {
            const board = new TetrisBoard();
            const layoutHeight = layout.length;
            const boardHeight = TetrisBoard.HEIGHT;
            const width = TetrisBoard.WIDTH;
            for (let layoutY = 0; layoutY < layoutHeight; layoutY++) {
                const boardY = (boardHeight - 1) - layoutY;
                if (boardY < 0) continue;

                let rowValue = 0;
                const layoutRow = layout[layoutY];
                if (!layoutRow || !Array.isArray(layoutRow)) {
                    continue;
                }

                for (let x = 0; x < width; x++) {
                    if (layoutRow[x] !== null) {
                        rowValue |= (1 << x);
                    }
                }
                board.rows[boardY] = rowValue;
            }
            return board;
        };
        
        let initialLayout;
        try {
            initialLayout = JSON.parse(boardString);
        } catch (e) {
            console.error("Failed to parse boardString:", e);
            initialLayout = Array(TetrisBoard.HEIGHT).fill(null).map(() => Array(TetrisBoard.WIDTH).fill(null));
        }
        
                const board = createBoardFromLayout(initialLayout);
        
        const chosenNodeID = bestNodeIDAtDepth1;
        pruneAndReroot(chosenNodeID);

        const rootNode = nodeMap.get("");
        if (rootNode && rootNode.board && boardsAreEqual(rootNode.board, board)) {
            self.postMessage({type: 'debug', message: '探索木を引き継ぎました'});
        } else {
            nodeMap.clear();
            self.postMessage({type: 'debug', message: '探索木をリセットしました'});
        }
        currentMinoSequence = nextString.split('');
        runAI(board, currentMinoSequence, isB2B, ren);
        
        if (!isThinking) {
            isThinking = true;
            thinkingLoop();
        }


} else if (type === 'stop') {
        let bestMove = null;
        if (bestNodeIDAtDepth1 !== "" && nodeMap.has(bestNodeIDAtDepth1)) {
            bestMove = nodeMap.get(bestNodeIDAtDepth1).place;
            
            const rootNode = nodeMap.get("");
            if (rootNode) {
                for (const childId of rootNode.childrenIDs) {
                    if (nodeMap.has(childId)) {
                        const childNode = nodeMap.get(childId);
                        if (childId === bestNodeIDAtDepth1) {
                            childNode.acc_eval += 999999;
                        } else {
                            childNode.acc_eval -= 999999;
                        }
                    }
                }
            }
        } else {
            const rootNode = nodeMap.get("");
            if (rootNode && rootNode.childrenIDs.length > 0) {
                let bestFallbackID = "";
                let maxEvalFallback = -Number.MAX_VALUE;
                for(const childID of rootNode.childrenIDs){
                    if(nodeMap.has(childID)){
                        const child_node = nodeMap.get(childID);
                        const current_total_eval = child_node.acc_eval + child_node.transient_eval;
                        if(current_total_eval > maxEvalFallback){
                            maxEvalFallback = current_total_eval;
                            bestFallbackID = childID;
                        }
                    }
                }
                if(bestFallbackID !== ""){
                    bestMove = nodeMap.get(bestFallbackID).place;
                }
            }
        }
        
        if (bestMove && bestMove.pieceType !== ' ') {
            let finalX;
            let finalY;
            if (bestMove.pieceType === 'I' && bestMove.rotation === 1) {
                finalX = bestMove.x - 2;
                finalY = 37 - bestMove.y;
            } 
            else if (bestMove.pieceType === 'Z' && bestMove.rotation === 1) {
                finalX = bestMove.x - 1;
                finalY = 39 - bestMove.y;
            } 
            else {
                finalX = bestMove.x;
                finalY = 39 - bestMove.y;
            }
            self.postMessage({
                piece: bestMove.pieceType,
                x: finalX,
                y: finalY,
                rotation: bestMove.rotation,
            });
        } else {
            self.postMessage(null);
        }
    }

};
`;

const aiWorkerScript_Simplified = `
/* --- AI 6: Cold Clear (Simplified & Optimized) --- */
/* Optimizations Applied:
   1. Vectorization: nodeMap uses Array (continuous memory) instead of Object.
   2. Integer IDs: Replaced string IDs with simple integer counters.
   3. Zobrist Hashing: Replaced string-based board hashing with XOR-based integer hashing.
*/

// --- Constants ---
const WIDTH = 10;
const BOARD_HEIGHT = 40;
const SEARCH_ITERATION_LIMIT = 500000; // 最適化により探索数を増やしても高速動作可能

// --- Precomputed Zobrist Table ---
// 40行 x 1024パターン(10bit) の乱数テーブル
const ZOBRIST_TABLE = new Int32Array(BOARD_HEIGHT * 1024);
for (let i = 0; i < ZOBRIST_TABLE.length; i++) {
    // 32bit signed integer range
    ZOBRIST_TABLE[i] = (Math.random() * 0xFFFFFFFF) |
0;
}

const TEMPLATES = [
    {
        name: 'meisou_1st',
        type: 'meisou',
        board: [[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],["G",null,null,null,null,null,null,null,null,null],["G","G","G",null,"G",null,null,"G",null,null],["G","G","G","G","G","G",null,"G","G","G"],["G","G","G","G","G",null,"G","G","G","G"]],
        moves: [
            {t:'L', x:1, y:38, r:1},
            {t:'J', x:7, y:38, r:3},
            {t:'T', x:4, y:38, r:1},
            {t:'O', x:8, y:39, r:0},
            {t:'I', x:0, y:37, r:3},
            {t:'S', x:2, y:38, r:1}
        ],
        trigger: (board, queue, hold) => {
            // 1. ミノ列の取得 (Hold + Queueから計7個分)
            const minos = [];
            if (hold) minos.push(hold);
            for (const p of queue) {
                if (minos.length >= 7) break;
                minos.push(p);
            }

            // 2. 重複チェック
            const counts = {};
            for (const m of minos) {
                counts[m] = (counts[m] || 0) + 1;
                if (counts[m] > 1) return false;
            }

    const lIndex = minos.indexOf('L');
    const sIndex = minos.indexOf('S');
    const iIndex = minos.indexOf('I');

    return lIndex !== -1 && sIndex !== -1 && iIndex !== -1 && !(lIndex > sIndex && lIndex > iIndex);
        }
    },
        {
        name: 'meisou_2nd_pattern1',
        type: 'meisou',
        startBoard: [[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],["G",null,null,null,null,null,null,null,null,null],["G","G","G",null,"G",null,null,"G",null,null],["G","G","G","G","G","G",null,"G","G","G"],["G","G","G","G","G",null,"G","G","G","G"]],
        board: [[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,"G","G","G","G"],["G",null,null,"G",null,null,"G","G","G","G"],["G","G","G","G",null,null,null,"G","G","G"],["G","G","G","G","G","G",null,"G","G","G"],["G","G","G","G","G",null,null,"G","G","G"],["G","G","G","G","G","G",null,"G","G","G"],["G","G","G","G","G",null,"G","G","G","G"]],
        moves: [
            {t:'Z', x:8, y:37, r:0},
            {t:'L', x:4, y:36, r:2},
            {t:'J', x:8, y:34, r:3},
            {t:'S', x:0, y:35, r:1},
            {t:'O', x:6, y:34, r:0},
            {t:'I', x:8, y:34, r:1},
            {t:'Z', x:2, y:35, r:1}
        ],
        trigger: (board, queue, hold) => {
            if (hold !== 'Z') return false;
            const checkQueue = queue.slice(0, 7);
            const qCounts = {};
            for (const m of checkQueue) {
                if (qCounts[m]) return false;
                qCounts[m] = true;
            }

            // 1. ミノ列の取得 (Hold + Queueから計8個分)
            const minos = [];
            if (hold) minos.push(hold);
            for (const p of queue) {
                if (minos.length >= 8) break;
                minos.push(p);
            }

    const jIndex = minos.indexOf('J');
    const oIndex = minos.indexOf('O');
    return jIndex !== -1 && oIndex !== -1 && oIndex > jIndex;
        }
    },
        {
        name: 'meisou_2nd_pattern2',
        type: 'meisou',
        startBoard: [[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],["G",null,null,null,null,null,null,null,null,null],["G","G","G",null,"G",null,null,"G",null,null],["G","G","G","G","G","G",null,"G","G","G"],["G","G","G","G","G",null,"G","G","G","G"]],
        board: [[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,"G",null,null,null,null,null,null,null],[null,"G","G",null,null,null,null,null,null,null],[null,"G","G","G",null,null,"G","G","G","G"],["G","G","G","G",null,null,null,"G","G","G"],["G","G","G","G","G","G",null,"G","G","G"],["G","G","G","G","G",null,null,"G","G","G"],["G","G","G","G","G","G",null,"G","G","G"],["G","G","G","G","G",null,"G","G","G","G"]],
        moves: [
            {t:'Z', x:1, y:36, r:0},
            {t:'I', x:8, y:35, r:1},
            {t:'L', x:4, y:36, r:2},
            {t:'J', x:7, y:34, r:2},
            {t:'S', x:7, y:36, r:1},
            {t:'O', x:2, y:35, r:0},
            {t:'Z', x:1, y:33, r:1}
        ],
        trigger: (board, queue, hold) => {
            if (hold !== 'Z') return false;
            const checkQueue = queue.slice(0, 7);
            const qCounts = {};
            for (const m of checkQueue) {
                if (qCounts[m]) return false;
                qCounts[m] = true;
            }

            // 1. ミノ列の取得 (Hold + Queueから計8個分)
            const minos = [];
            if (hold) minos.push(hold);
            for (const p of queue) {
                if (minos.length >= 8) break;
                minos.push(p);
            }

    const jIndex = minos.indexOf('J');
    const sIndex = minos.indexOf('S');
    return jIndex !== -1 && sIndex !== -1 && sIndex < jIndex;
    }
    },
       {
        name: 'meisou_2nd_pattern3',
        type: 'meisou',
        startBoard: [[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],["G",null,null,null,null,null,null,null,null,null],["G","G","G",null,"G",null,null,"G",null,null],["G","G","G","G","G","G",null,"G","G","G"],["G","G","G","G","G",null,"G","G","G","G"]],
        board: [[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,"G","G",null,null,null,null,null,null,null],[null,"G","G",null,null,null,null,null,null,"G"],[null,"G","G","G",null,null,"G","G",null,"G"],[null,"G","G","G",null,null,null,"G","G","G"],["G","G","G","G","G","G",null,"G","G","G"],["G","G","G","G","G",null,null,"G","G","G"],["G","G","G","G","G","G",null,"G","G","G"],["G","G","G","G","G",null,"G","G","G","G"]],
        moves: [
            {t:'Z', x:8, y:37, r:0},
            {t:'I', x:8, y:34, r:1},
            {t:'L', x:4, y:36, r:2},
            {t:'O', x:1, y:36, r:0},
            {t:'Z', x:7, y:35, r:0},
            {t:'J', x:1, y:33, r:1},
            {t:'S', x:2, y:34, r:1}
        ],
        trigger: (board, queue, hold) => {
            if (hold !== 'Z') return false;
            const checkQueue = queue.slice(0, 7);
            const qCounts = {};
            for (const m of checkQueue) {
                if (qCounts[m]) return false;
                qCounts[m] = true;
            }

            // 1. ミノ列の取得 (Hold + Queueから計8個分)
 
            const minos = [];
            if (hold) minos.push(hold);
            for (const p of queue) {
                if (minos.length >= 8) break;
                minos.push(p);
            }

    const jIndex = minos.indexOf('J');
    const sIndex = minos.indexOf('S');
    const oIndex = minos.indexOf('O');
    return !(jIndex !== -1 && oIndex !== -1 && oIndex > jIndex) && !(jIndex !== -1 && sIndex !== -1 && sIndex < jIndex)
        }
    },
    // 1. 山岳2号右 (1巡目)
    {
        name: 'sangaku_2_right_1st',
        type: 'sangaku_2',
        board: [[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,"G","G"],[null,null,"G",null,null,null,null,"G","G","G"],["G","G","G","G","G","G",null,"G","G","G"],["G","G","G","G","G",null,"G","G","G","G"]],
        moves: [
            {t:'Z', x:7, y:37, r:1},
            {t:'I', x:8, y:37, r:1},
            {t:'T', x:2, y:38, r:1},
            {t:'O', x:0, y:39, r:0},
            {t:'S', x:4, y:39, r:0},
            {t:'L', x:7, y:39, r:0}
        ],
        trigger: (board, queue, hold) => {
            // 1. ミノ列の取得 (Hold + Queueから計7個分)
            const minos = [];
            if (hold) minos.push(hold);
            for (const p of queue) {
                if (minos.length >= 7) break;
                minos.push(p);
            }

            // 2. 重複チェック
            const counts = {};
            for (const m of minos) {
                counts[m] = (counts[m] || 0) + 1;
                if (counts[m] > 1) return false;
            }

            // 3. 順序チェック (LがJより先)
            const lIndex = minos.indexOf('L');
            const jIndex = minos.indexOf('J');
            // 両方存在し、かつLのインデックスがJより小さい(速い)場合のみtrue
            return lIndex !== -1 && jIndex !== -1 && lIndex <= jIndex;
        }
    },

    // 2. 山岳2号左 (1巡目)
    {
        name: 'sangaku_2_left_1st',
        type: 'sangaku_2',
        board: [[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],["G","G",null,null,null,null,null,null,null,null],["G","G","G",null,null,null,null,"G",null,null],["G","G","G",null,"G","G","G","G","G","G"],["G","G","G","G",null,"G","G","G","G","G"]
        ],
        moves: [
        {t:'I', x:0, y:37, r:3},
        {t:'S', x:1, y:37, r:1},
        {t:'T', x:7, y:38, r:3},
        {t:'J', x:2, y:39, r:0},
        {t:'Z', x:5, y:39, r:0},
        {t:'O', x:8, y:39, r:0}

        ],
        // 条件: 直近でJがLより速い かつ ホールド含めた直近7ミノに重複がない
        trigger: (board, queue, hold) => {
            // 1. ミノ列の取得 (Hold + Queueから計7個分)
            const minos = [];
            if (hold) minos.push(hold);
            for (const p of queue) {
                if (minos.length >= 7) break;
                minos.push(p);
            }

            // 2. 重複チェック
            const counts = {};
            for (const m of minos) {
                counts[m] = (counts[m] || 0) + 1;
                if (counts[m] > 1) return false;
            }

            // 3. 順序チェック (JがLより先)
            const jIndex = minos.indexOf('J');
            const lIndex = minos.indexOf('L');
            return jIndex !== -1 && lIndex !== -1 && jIndex < lIndex;
        }
    },

    // 3. 山岳2号右の二巡目① (Z < O)
    {
        name: 'sangaku_2_right_2nd_pattern1',
        type: 'sangaku_2',
        startBoard: [[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,"G","G"],[null,null,"G",null,null,null,null,"G","G","G"],["G","G","G","G","G","G",null,"G","G","G"],["G","G","G","G","G",null,"G","G","G","G"]
        ],
        board: [[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,"G","G","G","G"],["G",null,null,"G",null,null,"G","G","G","G"],["G","G","G","G",null,null,null,"G","G","G"],["G","G","G","G","G","G",null,"G","G","G"],["G","G","G","G","G",null,null,"G","G","G"],["G","G","G","G","G","G",null,"G","G","G"],["G","G","G","G","G",null,"G","G","G","G"]
        
        ],
        moves: [ 
            {t:'J', x:3, y:35, r:3},
            {t:'O', x:6, y:34, r:0},
            {t:'L', x:9, y:34, r:3},
            {t:'I', x:0, y:35, r:3},
            {t:'Z', x:7, y:35, r:1},
            {t:'J', x:1, y:36, r:1},
            {t:'S', x:4, y:37, r:0}
        ],
        trigger: (board, queue, hold) => {
            if (hold !== 'J') return false;
            const checkQueue = queue.slice(0, 7);
            const qCounts = {};
            for (const m of checkQueue) {
                if (qCounts[m]) return false;
                qCounts[m] = true;
            }

            // 1. ミノ列の取得 (Hold + Queueから計8個分)
            const minos = [];
            if (hold) minos.push(hold);
            for (const p of queue) {
                if (minos.length >= 8) break;
                minos.push(p);
            }

            // 2. 順序チェック (ZがOより先)
            const zIndex = minos.indexOf('Z');
            const oIndex = minos.indexOf('O');
            // ※2巡目は盤面形状(startBoard)でフィルタされる前提のため重複チェックは省略し順序のみ判定
            return zIndex !== -1 && oIndex !== -1 && zIndex < oIndex;
            }
    },

    // 4. 山岳2号右の二巡目② (O < Z)
    {
        name: 'sangaku_2_right_2nd_pattern2',
        type: 'sangaku_2',
        startBoard: [[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,"G","G"],[null,null,"G",null,null,null,null,"G","G","G"],["G","G","G","G","G","G",null,"G","G","G"],["G","G","G","G","G",null,"G","G","G","G"]
        ],
        board: [[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,"G"],[null,null,null,null,null,null,null,null,null,"G"],[null,null,null,null,null,null,null,null,null,"G"],[null,null,null,null,null,null,null,null,null,"G"],[null,null,null,null,null,null,"G","G","G","G"],[null,null,null,null,null,null,"G","G","G","G"],[null,"G","G",null,null,null,null,"G","G","G"],["G","G","G","G","G","G",null,"G","G","G"],["G","G","G","G","G",null,null,"G","G","G"],["G","G","G","G","G","G",null,"G","G","G"],["G","G","G","G","G",null,"G","G","G","G"]],
        moves: [
            {t:'J', x:9, y:34, r:3},
            {t:'O', x:0, y:37, r:0},
            {t:'L', x:7, y:33, r:2},
            {t:'L', x:7, y:35, r:3},
            {t:'J', x:7, y:35, r:1},
            {t:'J', x:7, y:33, r:2},
            {t:'Z', x:2, y:36, r:0},
            {t:'S', x:4, y:37, r:0},
            {t:'I', x:8, y:30, r:1}
        ],
        trigger: (board, queue, hold) => {
            if (hold !== 'J') return false;
            const checkQueue = queue.slice(0, 7);
            const qCounts = {};
            for (const m of checkQueue) {
                if (qCounts[m]) return false;
                qCounts[m] = true;
            }

            // 1. ミノ列の取得 (Hold + Queueから計8個分)
            const minos = [];
            if (hold) minos.push(hold);
            for (const p of queue) {
                if (minos.length >= 8) break;
                minos.push(p);
            }
            
    const oIndex = minos.indexOf('O');
    const zIndex = minos.indexOf('Z');
    const iIndex = minos.indexOf('I');

    return oIndex !== -1 && zIndex !== -1 && iIndex !== -1 && oIndex < zIndex && iIndex < oIndex;
}
    },

        // 4. 山岳2号右の二巡目3 (O < Z)
    {
        name: 'sangaku_2_right_2nd_pattern3',
        type: 'sangaku_2',
        startBoard: [[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,"G","G"],[null,null,"G",null,null,null,null,"G","G","G"],["G","G","G","G","G","G",null,"G","G","G"],["G","G","G","G","G",null,"G","G","G","G"]
        ],
        board: [[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],["G",null,null,null,null,null,null,null,null,null],["G",null,null,null,null,null,"G","G","G","G"],["G",null,null,null,null,null,"G","G","G","G"],["G","G","G",null,null,null,null,"G","G","G"],["G","G","G","G","G","G",null,"G","G","G"],["G","G","G","G","G",null,null,"G","G","G"],["G","G","G","G","G","G",null,"G","G","G"],["G","G","G","G","G",null,"G","G","G","G"]],
        moves: [
            {t:'J', x:9, y:34, r:3},
            {t:'O', x:0, y:37, r:0},
            {t:'L', x:7, y:33, r:2},
            {t:'L', x:7, y:35, r:3},
            {t:'J', x:7, y:35, r:1},
            {t:'J', x:7, y:33, r:2},
            {t:'Z', x:2, y:36, r:0},
            {t:'S', x:4, y:37, r:0},
            {t:'I', x:0, y:33, r:3}
        ],
        trigger: (board, queue, hold) => {
            if (hold !== 'J') return false;
            const checkQueue = queue.slice(0, 7);
            const qCounts = {};
            for (const m of checkQueue) {
                if (qCounts[m]) return false;
                qCounts[m] = true;
            }

            // 1. ミノ列の取得 (Hold + Queueから計8個分)
            const minos = [];
            if (hold) minos.push(hold);
            for (const p of queue) {
                if (minos.length >= 8) break;
                minos.push(p);
            }


    const oIndex = minos.indexOf('O');
    const zIndex = minos.indexOf('Z');
    const iIndex = minos.indexOf('I');
    // 3. 順序チェック
    // すべてのミノが存在し、かつ O < Z と O < I を満たす
    return oIndex !== -1 && zIndex !== -1 && iIndex !== -1 && oIndex < zIndex && oIndex < iIndex;
}
    },

    // 5. 山岳2号左の二巡目① (S < O)
    {
        name: 'sangaku_2_left_2nd_pattern1',
        type: 'sangaku_2',
        startBoard:[[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],["G","G",null,null,null,null,null,null,null,null],["G","G","G",null,null,null,null,"G",null,null],["G","G","G",null,"G","G","G","G","G","G"],["G","G","G","G",null,"G","G","G","G","G"]],
        board: [[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],["G","G","G","G",null,null,null,null,null,null],["G","G","G","G",null,null,"G",null,null,"G"],["G","G","G",null,null,null,"G","G","G","G"],["G","G","G",null,"G","G","G","G","G","G"],["G","G","G",null,null,"G","G","G","G","G"],["G","G","G",null,"G","G","G","G","G","G"],["G","G","G","G",null,"G","G","G","G","G"]],
        moves: [
            {t:'Z', x:5, y:37, r:0},
            {t:'S', x:1, y:35, r:1},
            {t:'L', x:6, y:35, r:1},
            {t:'J', x:0, y:34, r:1},
            {t:'O', x:2, y:34, r:0},
            {t:'I', x:8, y:35, r:1},
            {t:'L', x:8, y:36, r:3}     
        ],
        trigger: (board, queue, hold) => {
            if (hold !== 'L') return false;
            const checkQueue = queue.slice(0, 7);
            const qCounts = {};
            for (const m of checkQueue) {
                if (qCounts[m]) return false;
                qCounts[m] = true;
            }

            // 1. ミノ列の取得 (Hold + Queueから計8個分)
            const minos = [];
            if (hold) minos.push(hold);
            for (const p of queue) {
                if (minos.length >= 8) break;
                minos.push(p);
            }

            // 2. 順序チェック (SがOより先)
            const sIndex = minos.indexOf('S');
            const oIndex = minos.indexOf('O');
            return sIndex !== -1 && oIndex !== -1 && sIndex < oIndex;
}
    },

    // 6. 山岳2号左の二巡目② (O < S)
    {
        name: 'sangaku_2_left_2nd_pattern2',
        type: 'sangaku_2',
        startBoard:[[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],["G","G",null,null,null,null,null,null,null,null],["G","G","G",null,null,null,null,"G",null,null],["G","G","G",null,"G","G","G","G","G","G"],["G","G","G","G",null,"G","G","G","G","G"]],
        board:[[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],["G",null,null,null,null,null,null,null,null,null],["G",null,null,null,null,null,null,null,null,null],["G",null,null,null,null,null,null,null,null,null],["G",null,null,null,null,null,null,null,null,null],["G","G","G","G",null,null,null,null,null,null],["G","G","G","G",null,null,null,null,null,null],["G","G","G",null,null,null,null,"G","G",null],["G","G","G",null,"G","G","G","G","G","G"],["G","G","G",null,null,"G","G","G","G","G"],["G","G","G",null,"G","G","G","G","G","G"],["G","G","G","G",null,"G","G","G","G","G"]],
        moves: [
            {t:'L', x:0, y:34, r:1},
            {t:'O', x:8, y:37, r:0},
            {t:'L', x:2, y:35, r:3},
            {t:'L', x:2, y:33, r:2},
            {t:'J', x:2, y:33, r:2},
            {t:'J', x:2, y:35, r:1},
            {t:'Z', x:5, y:37, r:0},
            {t:'S', x:7, y:36, r:0},
            {t:'I', x:0, y:30, r:3}
        ],
        trigger: (board, queue, hold) => {
            if (hold !== 'L') return false;
            const checkQueue = queue.slice(0, 7);
            const qCounts = {};
            for (const m of checkQueue) {
                if (qCounts[m]) return false;
                qCounts[m] = true;
            }

            // 1. ミノ列の取得 (Hold + Queueから計8個分)
            const minos = [];
            if (hold) minos.push(hold);
            for (const p of queue) {
                if (minos.length >= 8) break;
                minos.push(p);
            }

            const oIndex = minos.indexOf('O');
            const sIndex = minos.indexOf('S');
            const iIndex = minos.indexOf('I');
            return oIndex !== -1 && sIndex !== -1 && iIndex !== -1 && oIndex < sIndex && oIndex > iIndex;
}
    },
    {
        name: 'sangaku_2_left_2nd_pattern3',
        type: 'sangaku_2',
        startBoard:[[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],["G","G",null,null,null,null,null,null,null,null],["G","G","G",null,null,null,null,"G",null,null],["G","G","G",null,"G","G","G","G","G","G"],["G","G","G","G",null,"G","G","G","G","G"]],
        board: [[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null,null,"G"],["G","G","G","G",null,null,null,null,null,"G"],["G","G","G","G",null,null,null,null,null,"G"],["G","G","G",null,null,null,null,"G","G","G"],["G","G","G",null,"G","G","G","G","G","G"],["G","G","G",null,null,"G","G","G","G","G"],["G","G","G",null,"G","G","G","G","G","G"],["G","G","G","G",null,"G","G","G","G","G"]],
        moves: [
            {t:'L', x:0, y:34, r:1},
            {t:'O', x:8, y:37, r:0},
            {t:'L', x:2, y:35, r:3},
            {t:'L', x:2, y:33, r:2},
            {t:'J', x:2, y:33, r:2},
            {t:'J', x:2, y:35, r:1},
            {t:'Z', x:5, y:37, r:0},
            {t:'S', x:7, y:36, r:0},
            {t:'I', x:8, y:33, r:1}
        ],
// 修正後
        trigger: (board, queue, hold) => {
            if (hold !== 'L') return false;
            const checkQueue = queue.slice(0, 7);
            const qCounts = {};
            for (const m of checkQueue) {
                if (qCounts[m]) return false;
                qCounts[m] = true;
            }

            // 1. ミノ列の取得 (Hold + Queueから計8個分)
            const minos = [];
            if (hold) minos.push(hold);
            for (const p of queue) {
                if (minos.length >= 8) break;
                minos.push(p);
            }

            const oIndex = minos.indexOf('O');
            const sIndex = minos.indexOf('S');
            const iIndex = minos.indexOf('I');
            return oIndex !== -1 && sIndex !== -1 && iIndex !== -1 && oIndex < sIndex && oIndex < iIndex;
}
    }
];

// --- Mino Definitions ---
const MINO_DEFS = {
    'I': [[[0,0], [-1,0], [1,0], [2,0]], [[1,0], [1,-1], [1,1], [1,2]], [[0,1], [-1,1], [1,1], [2,1]], [[0,0], [0,-1], [0,1], [0,2]]],
    'O': [[[0,0], [1,0], [0,-1], [1,-1]], [[0,0], [1,0], [0,-1], [1,-1]], [[0,0], [1,0], [0,-1], [1,-1]], [[0,0], [1,0], [0,-1], [1,-1]]],
    'T': [[[0,0], [-1,0], [1,0], [0,-1]], [[0,0], [0,-1], [1,0], [0,1]], [[0,0], [1,0], [-1,0], [0,1]], [[0,0], [0,1], [-1,0], [0,-1]]],
    'S': [[[0,0], [-1,0], [0,-1], [1,-1]], [[0,0], [0,-1], [1,0], [1,1]], [[0,0], [1,0], [0,1], [-1,1]], [[0,0], [0,1], [-1,0], [-1,-1]]],
    'Z': [[[0,0], [1,0], [0,-1], [-1,-1]], [[0,0], [0,1], [1,0], [1,-1]], [[0,0], [-1,0], [0,1], [1,1]], [[0,0], [0,-1], [-1,0], [-1,1]]],
    'J': [[[0,0], [-1,0], [1,0], [-1,-1]], [[0,0], [0,-1], [0,1], [1,-1]], [[0,0], [1,0], [-1,0], [1,1]], [[0,0], [0,1], [0,-1], [-1,1]]],
    'L': [[[0,0], [1,0], [-1,0], [1,-1]], [[0,0], [0,1], [0,-1], [1,1]], [[0,0], [-1,0], [1,0], [-1,1]], [[0,0], [0,-1], [0,1], [-1,-1]]]
};
const SRS_OFFSETS_RAW = {
    common: {
        '0->1': [[0,0], [-1,0], [-1,1], [0,-2], [-1,-2]], '1->0': [[0,0], [1,0], [1,-1], [0,2], [1,2]],
        '1->2': [[0,0], [1,0], [1,-1], [0,2], [1,2]], '2->1': [[0,0], [-1,0], [-1,1], [0,-2], [-1,-2]],
        '2->3': [[0,0], [1,0], [1,1], [0,-2], [1,-2]], '3->2': [[0,0], [-1,0], [-1,-1], [0,2], [-1,2]],
        '3->0': [[0,0], [-1,0], [-1,-1], [0,2], [-1,2]], '0->3': [[0,0], [1,0], [1,1], [0,-2], [1,-2]],
    },
    I: {
        '0->1': [[0,0], [-2,0], [1,0], [-2,-1], [1,2]], '1->0': [[0,0], [2,0], [-1,0], [2,1], [-1,-2]],
        '1->2': [[0,0], [-1,0], [2,0], [-1,2], [2,-1]], '2->1': [[0,0], [1,0], [-2,0], [1,-2], [-2,1]],
        '2->3': [[0,0], [2,0], [-1,0], [2,1], [-1,-2]], '3->2': [[0,0], [-2,0], [1,0], [-2,-1], [1,2]],
        '3->0': [[0,0], [1,0], [-2,0], [1,-2], [-2,1]], '0->3': [[0,0], [-1,0], [2,0], [-1,2], [2,-1]],
    }
};
const SPAWN_X = 4;
const SPAWN_Y = 19;
const SPAWN_ROT = 0;

// グローバルキャッシュ (Mapキーを整数にするため高速)
let lfgCache = new Map();
let evaluationCache = new Map();

// --- Classes ---
class StandardWeights {
    constructor() {
        this.back_to_back = 52;
        this.bumpiness = -24;
        this.bumpiness_sq = -7;
        this.row_transitions = -5;
        this.height = -39;
        this.top_half = -150;
        this.top_quarter = -511;
        this.jeopardy = -11;
        this.cavity_cells = -173;
        this.cavity_cells_sq = -3;
        this.overhang_cells = -34;
        this.overhang_cells_sq = -1;
        this.covered_cells = -17;
        this.covered_cells_sq = -1;
        this.tslot = [8, 148, 192, 407];
        this.well_depth = 57;
        this.max_well_depth = 17;
        this.well_column = [20, 23, 20, 50, 59, 21, 59, 10, -10, 24];
        this.b2b_clear = 104;
        this.clear1 = -320;
        this.clear2 = -200;
        this.clear3 = -178;
        this.clear4 = 270;
        this.tspin1 = 1;
        this.tspin2 = 290;
        this.tspin3 = 482;
        this.mini_tspin1 = -158;
        this.mini_tspin2 = -93;
        this.perfect_clear = 999;
        this.combo_garbage = 150;
        this.wasted_t = -152;
        this.soft_drop = -100;
        this.COMBO_GARBAGE = [0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 4, 5];
    }
}


class TetrisBoard {
    constructor(baseBoard = null) {
        if (baseBoard) {
            // 高速コピー
            this.rows = baseBoard.rows.slice();
        } else {
            this.rows = new Array(BOARD_HEIGHT).fill(0);
        }
        this.zobristHash = 0; // ハッシュをキャッシュする場合はここで保持も可能だが、計算が速いので都度計算する
    }

    static fromSimulatorBoard(layout) {
        const board = new TetrisBoard();
        const layoutHeight = layout.length;
        const width = WIDTH;
        for (let y = 0; y < layoutHeight; y++) {
            const internalY = y + (BOARD_HEIGHT - layoutHeight);
            if (internalY < 0) continue;
            let rowValue = 0;
            const row = layout[y];
            for (let x = 0; x < width; x++) {
                if (row[x] !== null && row[x] !== 'null') {
                    rowValue |= (1 << x);
                }
            }
            board.rows[internalY] = rowValue;
        }
        return board;
    }

    // Zobrist Hashing Implementation
    getHash() {
        let h = 0;
        for (let y = 0; y < BOARD_HEIGHT; y++) {
            // rows[y] は 0-1023 の整数。
            // ZOBRIST_TABLE は 1次元配列なので、y * 1024 + rowValue でインデックス計算
            h ^= ZOBRIST_TABLE[(y << 10) + this.rows[y]];
        }
        return h;
    }

    isFilled(row, col) {
        if (col < 0 || col >= WIDTH) return true;
        if (row < 0) return false; 
        if (row >= BOARD_HEIGHT) return true;
        return (this.rows[row] & (1 << col)) !== 0;
    }
    
    isFilledXY(x, y) { return this.isFilled(y, x); }

    placeMino(placement) {
        const newBoard = new TetrisBoard(this);
        const shapeCoords = getMinoCoords(placement.pieceType, placement.rotation);
        for (const [dx, dy] of shapeCoords) {
            const boardX = placement.x + dx;
            const boardY = placement.y + dy;
            if (boardY >= 0 && boardY < BOARD_HEIGHT && boardX >= 0 && boardX < WIDTH) {
                newBoard.rows[boardY] |= (1 << boardX);
            }
        }
        return newBoard;
    }

    clearLines() {
        let newBoard = new TetrisBoard(null); // 空作成
        let linesCleared = 0;
        // 高速化のため直接配列操作
        let writePtr = BOARD_HEIGHT - 1;
        const fullLineMask = (1 << WIDTH) - 1;
        
        for (let readPtr = BOARD_HEIGHT - 1; readPtr >= 0; readPtr--) {
            const row = this.rows[readPtr];
            if (row === fullLineMask) {
                linesCleared++;
            } else {
                newBoard.rows[writePtr--] = row;
            }
        }
        // 残りは0で埋める (constructorで0埋めされているが、writePtrより上は0のままなのでOK)
        return { newBoard, linesCleared };
    }

    getColumnHeights() {
        const heights = new Int8Array(WIDTH).fill(0); // Int8Arrayでメモリ削減
        for (let c = 0; c < WIDTH; c++) {
            for (let y = 0; y < BOARD_HEIGHT; y++) {
                if ((this.rows[y] & (1 << c)) !== 0) {
                    heights[c] = BOARD_HEIGHT - y;
                    break;
                }
            }
        }
        return heights;
    }

    getBumpiness(wellColumn, heights) {
        let bumpiness_val = 0;
        let bumpiness_sq_val = 0;
        let prev_col_idx = (wellColumn === 0) ? 1 : 0;
        while (prev_col_idx < WIDTH && prev_col_idx === wellColumn) prev_col_idx++;
        if (prev_col_idx >= WIDTH) return { bumpiness: 0, bumpiness_sq: 0 };
        let current_height = heights[prev_col_idx];
        for (let i = prev_col_idx + 1; i < WIDTH; ++i) {
            if (i === wellColumn) continue;
            const dh = Math.abs(heights[i] - current_height);
            bumpiness_val += dh;
            bumpiness_sq_val += dh * dh;
            current_height = heights[i];
        }
        return { bumpiness: bumpiness_val, bumpiness_sq: bumpiness_sq_val };
    }

    getCavitiesAndOverhangs(heights) {
        let cavities = 0;
        let overhangs = 0;
        let max_board_height = 0;
        for(let i=0; i<WIDTH; i++) if(heights[i] > max_board_height) max_board_height = heights[i];
        
        if (max_board_height === 0) return { cavities: 0, overhangs: 0 };
        
        for (let y_cpp = 0; y_cpp < max_board_height; ++y_cpp) {
            const y_js = BOARD_HEIGHT - 1 - y_cpp;
            for (let x = 0; x < WIDTH; ++x) {
                if (this.isFilledXY(x, y_js) || y_cpp >= heights[x]) continue;
                let counted_as_overhang = false;
                if (x > 1) {
                    if (heights[x - 1] <= y_cpp && heights[x - 2] <= (y_cpp + 1)) {
                        overhangs++;
                        counted_as_overhang = true;
                    }
                }
                if (counted_as_overhang) continue;
                if (x < WIDTH - 2) {
                    if (heights[x + 1] <= y_cpp && heights[x + 2] <= (y_cpp + 1)) {
                        overhangs++;
                        counted_as_overhang = true;
                    }
                }
                if (counted_as_overhang) continue;
                cavities++;
            }
        }
        return { cavities, overhangs };
    }

    getCoveredCells(heights) {
        let covered = 0;
        let covered_sq = 0;
        for (let x = 0; x < WIDTH; ++x) {
            if (heights[x] <= 1) continue;
            for (let y_cpp = heights[x] - 2; y_cpp >= 0; --y_cpp) {
                const y_js = BOARD_HEIGHT - 1 - y_cpp;
                if (!this.isFilledXY(x, y_js)) {
                    const cells_above_hole = heights[x] - (y_cpp + 1);
                    const actual_cells_counted = Math.min(6, cells_above_hole);
                    covered += actual_cells_counted;
                    covered_sq += actual_cells_counted * actual_cells_counted;
                }
            }
        }
        return { covered, covered_sq };
    }

    getWell(weights, heights) {
        let well_col = -1;
        let min_h = BOARD_HEIGHT + 1;
        for (let c = 0; c < WIDTH; ++c) {
            if (heights[c] < min_h) { min_h = heights[c]; well_col = c; }
        }
        let depth = 0;
        if (well_col !== -1) {
            const start_y_cpp = heights[well_col];
            for (let y_cpp = start_y_cpp; y_cpp < BOARD_HEIGHT; ++y_cpp) {
                const y_js = BOARD_HEIGHT - 1 - y_cpp;
                if (y_js < 0) break;
                let is_well_row = true;
                for (let x = 0; x < WIDTH; ++x) {
                    if (x !== well_col && !this.isFilledXY(x, y_js)) { is_well_row = false; break; }
                }
                if (is_well_row) depth++;
                else break;
            }
        }
        depth = Math.min(depth, weights.max_well_depth);
        return { depth, well_col };
    }
    
    check_sides(x, y_js) {
        for (let dx = 1; dx <= 9; ++dx) {
            if (x - dx < 0 || x + dx >= WIDTH) return false;
            if (!this.isFilledXY(x - dx, y_js) || !this.isFilledXY(x + dx, y_js)) return false;
        }
        return true;
    }
    
    check_top(x, y_js) {
        const y_limit_js = BOARD_HEIGHT - 1 - 25;
        for (let check_y_js = y_js - 1; check_y_js >= y_limit_js; --check_y_js) {
            if (check_y_js < 0) break;
            if (this.isFilledXY(x, check_y_js)) return false;
        }
        return true;
    }

    getTslotsAndRowTransitions(weights) {
        let t_slot_score = 0.0;
        let rowTransitions = 0; 
        for (let y_js = 0; y_js < BOARD_HEIGHT; ++y_js) {
            const r = this.rows[y_js];
            const d = (r | (1 << WIDTH)) ^ (1 | (r << 1));
            // Population Count
            let count = 0;
            let n = d;
            while (n > 0) { n &= (n - 1); count++; }
            rowTransitions += count;

            // T-Slot Detection
            for (let x = 0; x < WIDTH; ++x) {
                // Inline isFilled logic for speed
                const is_filled = (dx, dy) => {
                    const ny = y_js + dy;
                    if (ny < 0 || ny >= BOARD_HEIGHT) return true;
                    const nx = x + dx;
                    if (nx < 0 || nx >= WIDTH) return true;
                    return (this.rows[ny] & (1 << nx)) !== 0;
                };

                if (!is_filled(-1, 0) && is_filled(1, 1) && is_filled(-1, 1) && is_filled(-1, -1)) {
                    if (this.check_top(x, y_js) && this.check_top(x + 1, y_js)) {
                        let c = 0;
                        if (this.check_sides(x, y_js)) c++;
                        if (this.check_sides(x, y_js - 1)) c++;
                        t_slot_score += (c == 2) ? weights.tslot[2] : ((c == 1) ? weights.tslot[1] : weights.tslot[0]);
                    }
                }
                if (!is_filled(1, 0) && is_filled(1, 1) && is_filled(-1, 1) && is_filled(1, -1)) {
                     if (this.check_top(x, y_js) && this.check_top(x - 1, y_js)) {
                        let c = 0;
                        if (this.check_sides(x, y_js)) c++;
                        if (this.check_sides(x, y_js - 1)) c++;
                        t_slot_score += (c == 2) ? weights.tslot[2] : ((c == 1) ? weights.tslot[1] : weights.tslot[0]);
                    }
                }
            }
        }
        return { t_slot_score, rowTransitions };
    }
    
    isPerfectClear() { return this.rows[BOARD_HEIGHT - 1] === 0; }
}

class Placement {
    constructor(x, y, rotation, pieceType, isTspin = false, isMiniTspin = false) {
        this.x = x;
        this.y = y; 
        this.rotation = rotation; 
        this.pieceType = pieceType; 
        this.isTspin = isTspin; 
        this.isMiniTspin = isMiniTspin;
    }
}

class Node {
    // Integer IDs for vector-like access
    constructor(id, board, place, parentID, depth, comboCount = 0, b2b = false, holdPiece = null, holdUsedThisTurn = false) {
        this.id = id; // Integer
        this.board = board; 
        this.place = place; 
        this.parentID = parentID; // Integer (or -1 for null)
        this.depth = depth;
        this.acc_eval = 0; 
        this.transient_eval = 0;
        this.expanded = false; 
        this.childrenIDs = []; // Array of Integers
        this.comboCount = comboCount; 
        this.b2b = b2b;
        this.holdPiece = holdPiece; 
        this.holdUsedThisTurn = holdUsedThisTurn;
    }
    getTotalEval() { return this.acc_eval + this.transient_eval; }
}

// --- LFG Helpers ---
// 既存のまま、ビットボード演算による高速化がされている
const LFG_WIDTH = WIDTH; 
const LFG_HEIGHT = BOARD_HEIGHT;
const LFG_FULL_WIDTH_MASK = (1 << LFG_WIDTH) - 1;
function lfg_create() { return new Int32Array(LFG_HEIGHT).fill(0); } // TypedArray
function lfg_clone(board) { return new Int32Array(board); }
function lfg_set(board, x, y, value = true) { 
    if (y < 0 || y >= LFG_HEIGHT || x < 0 || x >= LFG_WIDTH) return;
    if (value) board[y] |= (1 << x); else board[y] &= ~(1 << x);
}
function lfg_get(board, x, y) { 
    if (y < 0 || y >= LFG_HEIGHT || x < 0 || x >= LFG_WIDTH) return false;
    return (board[y] & (1 << x)) !== 0; 
}
function lfg_shiftLeft(board) { const nb = lfg_create(); for (let y = 0; y < LFG_HEIGHT; y++) nb[y] = (board[y] >> 1); return nb; }
function lfg_shiftRight(board) { const nb = lfg_create(); for (let y = 0; y < LFG_HEIGHT; y++) nb[y] = (board[y] << 1) & LFG_FULL_WIDTH_MASK; return nb; }
function lfg_shiftDown(board) { 
    const nb = lfg_create();
    nb[0] = 0;
    for(let y=1; y<LFG_HEIGHT; y++) nb[y] = board[y-1];
    return nb;
}
function lfg_shiftUp(board) { 
    const nb = lfg_create();
    for(let y=0; y<LFG_HEIGHT-1; y++) nb[y] = board[y+1];
    nb[LFG_HEIGHT-1] = 0;
    return nb;
}
function lfg_shift(board, dx, dy) {
    let nb = lfg_clone(board);
    if (dy > 0) for (let i = 0; i < dy; i++) nb = lfg_shiftDown(nb);
    if (dy < 0) for (let i = 0; i < -dy; i++) nb = lfg_shiftUp(nb);
    if (dx > 0) for (let i = 0; i < dx; i++) nb = lfg_shiftRight(nb);
    if (dx < 0) for (let i = 0; i < -dx; i++) nb = lfg_shiftLeft(nb);
    return nb;
}
function lfg_and(a, b) { const nb = lfg_create(); for (let y = 0; y < LFG_HEIGHT; y++) nb[y] = a[y] & b[y]; return nb; }
function lfg_or(a, b) { const nb = lfg_create(); for (let y = 0; y < LFG_HEIGHT; y++) nb[y] = a[y] | b[y]; return nb; }
function lfg_not(b) { const nb = lfg_create(); for (let y = 0; y < LFG_HEIGHT; y++) nb[y] = (~b[y]) & LFG_FULL_WIDTH_MASK; return nb; }
function lfg_equals(a, b) { for (let y = 0; y < LFG_HEIGHT; y++) if (a[y] !== b[y]) return false; return true; }
function lfg_isEmpty(b) { for (let y = 0; y < LFG_HEIGHT; y++) if (b[y] !== 0) return false; return true; }

function getMinoCoords(type, rot) { return MINO_DEFS[type][rot]; }
function getSrsOffsets(type, r1, r2) {
    const key = r1 + "->" + r2;
    const source = (type === 'I' || type === 'O') ? SRS_OFFSETS_RAW.I : SRS_OFFSETS_RAW.common;
    if (type === 'O') return [[0,0]];
    const offsets = source[key];
    if (!offsets) return [[0,0]];
    return offsets.map(([dx, dy]) => [dx, -dy]);
}

function applySrsRotation(sourceBits, targetPrecomputed, srsOffsets) {
    let currentTestBits = lfg_clone(sourceBits);
    let newTargetBits = lfg_create();
    for (const [dx, dy] of srsOffsets) {
        if (lfg_isEmpty(currentTestBits)) break;
        const shiftedSource = lfg_shift(currentTestBits, dx, dy);
        const successful = lfg_and(shiftedSource, targetPrecomputed);
        newTargetBits = lfg_or(newTargetBits, successful);
        const successfulOriginal = lfg_shift(successful, -dx, -dy);
        currentTestBits = lfg_and(currentTestBits, lfg_not(successfulOriginal));
    }
    return newTargetBits;
}

function findLegalMoves(gameBoard, minoType, spawnX, spawnY, spawnRot) {
    const precomputed = [lfg_create(), lfg_create(), lfg_create(), lfg_create()];
    for (let r = 0; r < 4; r++) {
        const coords = getMinoCoords(minoType, r);
        for (let y = 0; y < BOARD_HEIGHT; y++) {
            for (let x = 0; x < WIDTH; x++) {
                let collision = false;
                for (const [dx, dy] of coords) {
                    if (gameBoard.isFilled(y + dy, x + dx)) { collision = true; break; }
                }
                if (!collision) lfg_set(precomputed[r], x, y);
            }
        }
    }

    let reachable = [lfg_create(), lfg_create(), lfg_create(), lfg_create()];
    if (lfg_get(precomputed[spawnRot], spawnX, spawnY)) {
         lfg_set(reachable[spawnRot], spawnX, spawnY);
    }

    let iteration = 0;
    while (true) {
        iteration++;
        let changed = false;
        let nextReachable = reachable.map(b => lfg_clone(b));
        const currentReachableForRotation = reachable.map(b => lfg_clone(b));
        for (let r = 0; r < 4; r++) {
            const r_left = lfg_and(lfg_shiftLeft(reachable[r]), precomputed[r]);
            const r_right = lfg_and(lfg_shiftRight(reachable[r]), precomputed[r]);
            const r_down = lfg_and(lfg_shiftDown(reachable[r]), precomputed[r]);
            nextReachable[r] = lfg_or(nextReachable[r], lfg_or(r_left, lfg_or(r_right, r_down)));
        }
        
        for (let r_from = 0; r_from < 4; r_from++) {
            if (lfg_isEmpty(currentReachableForRotation[r_from])) continue;
            const r_to_cw = (r_from + 1) % 4;
            const srs_cw = getSrsOffsets(minoType, r_from, r_to_cw);
            const new_cw_bits = applySrsRotation(currentReachableForRotation[r_from], precomputed[r_to_cw], srs_cw);
            nextReachable[r_to_cw] = lfg_or(nextReachable[r_to_cw], new_cw_bits);

            const r_to_ccw = (r_from + 3) % 4;
            const srs_ccw = getSrsOffsets(minoType, r_from, r_to_ccw);
            const new_ccw_bits = applySrsRotation(currentReachableForRotation[r_from], precomputed[r_to_ccw], srs_ccw);
            nextReachable[r_to_ccw] = lfg_or(nextReachable[r_to_ccw], new_ccw_bits);
        }

        for (let r = 0; r < 4; r++) {
            if (!lfg_equals(reachable[r], nextReachable[r])) { changed = true; break; }
        }
        reachable = nextReachable;
                if (!changed || iteration > (WIDTH * BOARD_HEIGHT)) break;
    }

    const hard_drop_reachable = [lfg_create(), lfg_create(), lfg_create(), lfg_create()];
    for (let r = 0; r < 4; r++) {
        let runningMask = LFG_FULL_WIDTH_MASK;
        for (let y = 0; y < BOARD_HEIGHT; y++) {
            runningMask &= precomputed[r][y];
            hard_drop_reachable[r][y] = runningMask & reachable[r][y];
        }
    }

    const landed = [lfg_create(), lfg_create(), lfg_create(), lfg_create()];
    for (let r = 0; r < 4; r++) {
        const canMoveDown = lfg_and(lfg_shiftDown(reachable[r]), precomputed[r]);
        const canMoveDown_ShiftedUp = lfg_shiftUp(canMoveDown);
        landed[r] = lfg_and(reachable[r], lfg_not(canMoveDown_ShiftedUp));
    }

    const landed_tspin = [lfg_create(), lfg_create(), lfg_create(), lfg_create()];
    if (minoType === 'T') {
        for (let r = 0; r < 4; r++) {
            if (lfg_isEmpty(landed[r])) continue;
            for (let y = 0; y < BOARD_HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    if (lfg_get(landed[r], x, y)) {
                        const corners = [
                             gameBoard.isFilled(y - 1, x - 1), gameBoard.isFilled(y - 1, x + 1),
                             gameBoard.isFilled(y + 1, x - 1), gameBoard.isFilled(y + 1, x + 1)
                        ];
                        const filledCorners = corners.filter(Boolean).length;
                        if (filledCorners >= 3) {
                            let frontCornersFilled = false;
                            switch (r) {
                                case 0: frontCornersFilled = corners[0] && corners[1]; break;
                                case 1: frontCornersFilled = corners[1] && corners[3]; break;
                                case 2: frontCornersFilled = corners[2] && corners[3]; break;
                                case 3: frontCornersFilled = corners[0] && corners[2]; break;
                            }
                            if (frontCornersFilled) {
                                lfg_set(landed_tspin[r], x, y);
                                lfg_set(landed[r], x, y, false);
                            }
                        }
                    }
                }
            }
        }
    }
    return { reachable, landed, landed_tspin, hard_drop_reachable };
}

class AIAgent {
    constructor() {
        this.weights = new StandardWeights();
        // Vectorization: Fixed size array for node storage (faster than Object)
        this.nodeMap = new Array(SEARCH_ITERATION_LIMIT + 1000);
        this.nodeIdCounter = 0;
        this.rootID = -1;
        this.totalNodesInSearch = 0;
        this.bestNodeIDAtDepth1 = -1;
        
        this.activeTemplate = null;
        this.activeTemplateOffset = 0;
        // 現在有効なテンプレート
    }

    // makeID: Simple integer increment
    makeID() { return this.nodeIdCounter++; }
    
    clearCaches() {
        lfgCache.clear();
        evaluationCache.clear();
    }

            // ★引数 enabledTemplates を追加★
            initSearch(currentBoard, pieceQueue, currentHoldPiece, isB2B, combo, enabledTemplates) {
        const wasTemplateActive = this.activeTemplate !== null;
        if (this.activeTemplate) {
            let foundValidOffset = -1;
            let isCompleted = false;

            for (let offset = 0; offset <= 12; offset++) {
                let valid = true;
                let completed = true;
                let hasTargets = false;
                const tempBoard = this.activeTemplate.board;

                if (tempBoard && tempBoard.length === BOARD_HEIGHT) {
                    for (let y = 0; y < BOARD_HEIGHT; y++) {
                        const templateY = y + offset;
                        const row = currentBoard.rows[y];

                        if (templateY >= BOARD_HEIGHT) {
                            let filledCount = 0;
                            for (let x = 0; x < WIDTH; x++) {
                                if ((row & (1 << x)) !== 0) filledCount++;
                            }
                            if (filledCount < 9) valid = false;
                            if (!valid) break;
                            continue;
                        }

                        for (let x = 0; x < WIDTH; x++) {
                            const isFilled = (row & (1 << x)) !== 0;
                            const tempCell = tempBoard[templateY][x];

                            if (tempCell === null) {
                                if (isFilled) valid = false;
                            } else {
                                hasTargets = true;
                                if (!isFilled) completed = false;
                            }
                        }
                        if (!valid) break;
                    }
                }

                if (valid) {
                    if (hasTargets && completed) {
                        isCompleted = true;
                        foundValidOffset = -1;
                    } else {
                        foundValidOffset = offset;
                    }
                    break;
                }
            }

            if (isCompleted) {
                this.activeTemplate = null;
                this.activeTemplateOffset = 0;
                self.postMessage({ type: 'debug', message: 'Template: Completed' });
            } else if (foundValidOffset !== -1) {
                this.activeTemplateOffset = foundValidOffset;
                const offsetMsg = foundValidOffset > 0 ? ' (Offset: ' + foundValidOffset + ')' : '';
                self.postMessage({ type: 'debug', message: 'Template: Cont. ' + this.activeTemplate.name + offsetMsg });
            } else {
                this.activeTemplate = null;
                this.activeTemplateOffset = 0;
                self.postMessage({ type: 'debug', message: 'Template: Cancelled (Mismatch)' });
            }
        }

                if (!this.activeTemplate) {
            this.activeTemplateOffset = 0;
            for (const temp of TEMPLATES) {
                if (enabledTemplates && temp.type && !enabledTemplates[temp.type]) continue;

                let match = true;
                // A. 開始盤面パターン (startBoard) のチェック
                if (temp.startBoard) {
                    // startBoardがある場合: パターン完全一致チェック
                    for (let y = 0; y < BOARD_HEIGHT; y++) {
                        if (!match) break;
                        const row = currentBoard.rows[y];
                        for (let x = 0; x < WIDTH; x++) {
                            const isFilled = (row & (1 << x)) !== 0;
                            // nullなら空、それ以外(G等)ならブロックがあること
                            const isPatternNull = temp.startBoard[y][x] === null;
                            if (isPatternNull && isFilled) { match = false; break; }
                            if (!isPatternNull && !isFilled) { match = false; break; }
                        }
                    }
                } else {
                    // B. startBoardがない場合 (略記法): 「盤面が空」であることを条件とする
                    for (let y = 0; y < BOARD_HEIGHT; y++) {
                        if (currentBoard.rows[y] !== 0) { match = false; break; }
                    }
                }

                // C. 追加条件 (trigger関数) のチェック
                if (match && temp.trigger) {
                    if (!temp.trigger(currentBoard, pieceQueue, currentHoldPiece)) {
                        match = false;
                    }
                }

                if (match) {
                    this.activeTemplate = temp;
                    self.postMessage({ type: 'debug', message: 'Template: Active (' + temp.name + ')' });
                    break;
                }
            }
        }
        
        // ----------------------

        let reuseTree = false;
        // 探索木の再利用チェック
        // テンプレートが「現在アクティブ」または「直前までアクティブだった」場合はリセットする
        if (!this.activeTemplate && !wasTemplateActive && this.rootID !== -1 && this.nodeMap[this.rootID]) {
            const rootNode = this.nodeMap[this.rootID];
            // Zobrist Hash Compare
            const hashCurrent = currentBoard.getHash();
            const hashRoot = rootNode.board.getHash();
            
            if (hashCurrent === hashRoot && rootNode.holdPiece === currentHoldPiece) {
                reuseTree = true;
                rootNode.b2b = isB2B;
                rootNode.comboCount = combo;
            }
        }

        if (!reuseTree) {
            // Reset Vector
            this.nodeIdCounter = 0;
            this.rootID = this.makeID();
            
            const rootNode = new Node(this.rootID, currentBoard, null, -1, 0, combo, isB2B, currentHoldPiece, false);
            this.nodeMap[this.rootID] = rootNode;
            
            const { transient_eval } = this.evaluate(rootNode, { 
                linesCleared: 0, isTspin: false, isMiniTspin: false, 
                b2bActive: isB2B, combo: combo, holdUsed: false, wastedT: false, 
                perfectClear: rootNode.board.isPerfectClear() 
            });
            rootNode.transient_eval = transient_eval;
            
            this.clearCaches();
            this.totalNodesInSearch = 1;
            self.postMessage({ type: 'debug', message: 'Tree RESET (New Search)' });
        } else {
            self.postMessage({ type: 'debug', message: 'Tree REUSED (Continuing)' });
            // nodeMapの有効な要素数を数え直すのはコストが高いので概算またはそのまま
            // pruneAndRerootでtotalNodesはリセットされているはず
        }
        
        const rootNode = this.nodeMap[this.rootID];
        if (!rootNode.expanded && pieceQueue.length >= 2) {
            this.expand(this.rootID, pieceQueue[0], pieceQueue[1]);
        }
        
        // 配列なのでlengthではなくCounterを使う
        this.totalNodesInSearch = this.nodeIdCounter;
    }

    searchStep(iterations, pieceQueue) {
        if (this.rootID === -1 || !this.nodeMap[this.rootID]) return;
        let count = 0;
        while (count < iterations && this.totalNodesInSearch < SEARCH_ITERATION_LIMIT) {
            const selectedNode = this.select(this.rootID);
            
            // テンプレートモード時は深さ1以上（ルートの子ノード以降）を展開しない
            if (this.activeTemplate && selectedNode.depth >= 1) break;

            if (selectedNode.expanded) break; 
            
            const depth = selectedNode.depth;
            const pieceForExpand = pieceQueue[depth];
            const nextPieceForExpand = pieceQueue[depth + 1];
            if (pieceForExpand && nextPieceForExpand) {
                this.expand(selectedNode.id, pieceForExpand, nextPieceForExpand);
            } else {
                break;
            }
            count++;
        }
    }
    
    getBestMove() {
        this.bestNodeIDAtDepth1 = this.findBestChildNodeID(this.rootID);
        if (this.bestNodeIDAtDepth1 === -1) {
            const root = this.nodeMap[this.rootID];
            if (root && root.childrenIDs.length > 0) {
                return this.nodeMap[root.childrenIDs[0]].place;
            }
            return null;
        }
        return this.nodeMap[this.bestNodeIDAtDepth1].place;
    }
    
    advanceTreeToBestMove() {
        if (this.bestNodeIDAtDepth1 !== -1) {
            this.pruneAndReroot(this.bestNodeIDAtDepth1);
        }
    }

    expand(nodeID, pieceToPlace, nextPiece) {
        const parentNode = this.nodeMap[nodeID];
        if (!parentNode || parentNode.expanded || !pieceToPlace || !nextPiece) return;
        parentNode.expanded = true;
        
        let nodesAddedThisExpand = 0;
        const { placements: placementsNoHold } = this.getLegalPlacements(parentNode.board, pieceToPlace);
        for (const placement of placementsNoHold) {
            this.createAndAddChildNode(parentNode, placement, false, parentNode.holdPiece);
            nodesAddedThisExpand++;
        }

        if (parentNode.holdUsedThisTurn) {
            this.totalNodesInSearch += nodesAddedThisExpand;
            return; 
        }

        let pieceForHoldMove = null;
        let newHoldPiece = null;
        if (parentNode.holdPiece === null) {
            pieceForHoldMove = nextPiece;
            newHoldPiece = pieceToPlace;
        } else {
            pieceForHoldMove = parentNode.holdPiece;
            newHoldPiece = pieceToPlace;
        }

        const { placements: placementsHold } = this.getLegalPlacements(parentNode.board, pieceForHoldMove);
        for (const placement of placementsHold) {
            this.createAndAddChildNode(parentNode, placement, true, newHoldPiece);
            nodesAddedThisExpand++;
        }
        this.totalNodesInSearch += nodesAddedThisExpand;
    }

    createAndAddChildNode(parentNode, placement, holdUsed, newHoldPiece) {
        const boardAfterPlace = parentNode.board.placeMino(placement);
        const { newBoard, linesCleared } = boardAfterPlace.clearLines();

        const isTspin = placement.isTspin;
        const isMiniTspin = placement.isMiniTspin;
        const combo = linesCleared > 0 ? parentNode.comboCount + 1 : 0;
        const moveWasSpecialForB2B = (isTspin && linesCleared > 0) || (linesCleared >= 4);
        let b2b_after_move = parentNode.b2b;
        if (moveWasSpecialForB2B) b2b_after_move = true;
        else if (linesCleared > 0) b2b_after_move = false;

        const placementResult = {
            linesCleared: linesCleared, isTspin: isTspin, isMiniTspin: isMiniTspin,
            b2bActive: parentNode.b2b, combo: combo, holdUsed: holdUsed,
            wastedT: (placement.pieceType === 'T' && (linesCleared === 0 || !(isTspin || isMiniTspin))),
            perfectClear: newBoard.isPerfectClear()
        };
        
        // Create Node with Integer ID
        const newNodeID = this.makeID();
        const newNode = new Node(newNodeID, newBoard, placement, parentNode.id, parentNode.depth + 1, combo, b2b_after_move, newHoldPiece, holdUsed);
        
        const { acc_eval, transient_eval } = this.evaluate(newNode, placementResult);
        newNode.acc_eval = parentNode.acc_eval + acc_eval;
        newNode.transient_eval = transient_eval;

        this.nodeMap[newNodeID] = newNode;
        parentNode.childrenIDs.push(newNodeID);
        this.propagateEvaluation(newNodeID);
    }

    evaluate(node, placementResult) {
        let acc_eval = 0;
        const board = node.board;
        const weights = this.weights;
        
        if (placementResult.perfectClear) acc_eval += weights.perfect_clear;
        if (true) { 
            if (placementResult.b2bActive && placementResult.linesCleared > 0) acc_eval += weights.b2b_clear;
            if (placementResult.combo > 0) {
                const combo_idx = Math.min(placementResult.combo, weights.COMBO_GARBAGE.length - 1);
                acc_eval += weights.combo_garbage * weights.COMBO_GARBAGE[combo_idx];
            }
            if (placementResult.isTspin) {
                if (placementResult.linesCleared === 1) acc_eval += weights.tspin1;
                else if (placementResult.linesCleared === 2) acc_eval += weights.tspin2;
                else if (placementResult.linesCleared === 3) acc_eval += weights.tspin3;
            } else if (placementResult.isMiniTspin) {
                if (placementResult.linesCleared === 1) acc_eval += weights.mini_tspin1;
                else if (placementResult.linesCleared === 2) acc_eval += weights.mini_tspin2;
            } else {
                if (placementResult.linesCleared === 1) acc_eval += weights.clear1;
                else if (placementResult.linesCleared === 2) acc_eval += weights.clear2;
                else if (placementResult.linesCleared === 3) acc_eval += weights.clear3;
                else if (placementResult.linesCleared === 4) acc_eval += weights.clear4;
            }
        }
                if (placementResult.wastedT) acc_eval += weights.wasted_t;
        if (node.place && node.place.isSoftDrop) acc_eval += weights.soft_drop;

        // --- Template Bonus ---
        if (this.activeTemplate && node.place) {
            const p = node.place;
            // リスト内のいずれかの手と一致するかチェック (上から優先)
            for (let i = 0; i < this.activeTemplate.moves.length; i++) {
                const move = this.activeTemplate.moves[i];
                const targetY = move.y - this.activeTemplateOffset;
                if (move.t === p.pieceType && move.x === p.x && targetY === p.y && move.r === p.rotation) {
                    if (targetY >= 0) {
                        // 一致する手があれば超高評価。リストの上位(iが小さい)ほど点数を高くする
                        acc_eval += 1000000000 - (i * 10000);
                        break; 
                    }
                }
            }
        }
        // ----------------------

        // Cache Check (Zobrist Hash = Integer)
        const boardHash = board.getHash();
        if (evaluationCache.has(boardHash)) {
            const transient_eval = evaluationCache.get(boardHash);
            return { acc_eval, transient_eval };
        }

        let transient_eval = 0;
        if (node.b2b) transient_eval += weights.back_to_back;

        const heights = board.getColumnHeights();
        const highest_point = Math.max(0, ...heights);
        transient_eval += weights.top_quarter * Math.max(0, highest_point - 15);
        transient_eval += weights.top_half * Math.max(0, highest_point - 10);
        transient_eval += weights.height * highest_point;
        transient_eval += weights.jeopardy * Math.max(0, highest_point - 10); 
        
        const { t_slot_score, rowTransitions } = board.getTslotsAndRowTransitions(weights);
        transient_eval += t_slot_score;
        transient_eval += weights.row_transitions * rowTransitions;

        const { depth: well_d, well_col } = board.getWell(weights, heights);
        transient_eval += weights.well_depth * well_d;
        if (well_d > 0 && well_col >= 0 && well_col < weights.well_column.length) transient_eval += weights.well_column[well_col];
        const { bumpiness, bumpiness_sq } = board.getBumpiness(well_col, heights);
        transient_eval += bumpiness * weights.bumpiness;
        transient_eval += bumpiness_sq * weights.bumpiness_sq;
        const { cavities, overhangs } = board.getCavitiesAndOverhangs(heights);
        transient_eval += weights.cavity_cells * cavities;
        transient_eval += weights.cavity_cells_sq * cavities * cavities;
        transient_eval += weights.overhang_cells * overhangs;
        transient_eval += weights.overhang_cells_sq * overhangs * overhangs;

        const { covered, covered_sq } = board.getCoveredCells(heights);
        transient_eval += weights.covered_cells * covered;
        transient_eval += weights.covered_cells_sq * covered_sq;

        evaluationCache.set(boardHash, transient_eval);
        return { acc_eval, transient_eval };
    }

    propagateEvaluation(startNodeID) {
        let currentNode = this.nodeMap[startNodeID];
        if (!currentNode) return;
        let parentID = currentNode.parentID;

        while (parentID !== -1) {
            const parentNode = this.nodeMap[parentID];
            if (!parentNode) break; 
            let maxChildEval = -Infinity;
            // childrenIDs is array of integers
            for (const childID of parentNode.childrenIDs) {
                const childNode = this.nodeMap[childID];
                if (childNode) maxChildEval = Math.max(maxChildEval, childNode.getTotalEval());
            }
            if (maxChildEval === -Infinity) break;
            const newTransient = maxChildEval - parentNode.acc_eval;
            if (newTransient > parentNode.transient_eval) {
                parentNode.transient_eval = newTransient;
                if (parentNode.parentID === this.rootID) this.updateBestDepth1Node(parentNode.id);
                parentID = parentNode.parentID;
            } else {
                break;
            }
        }
    }
    
    updateBestDepth1Node(depth1NodeID) {
        if(this.bestNodeIDAtDepth1 === -1) { this.bestNodeIDAtDepth1 = depth1NodeID; return; }
        const currentBest = this.nodeMap[this.bestNodeIDAtDepth1];
        const newCandidate = this.nodeMap[depth1NodeID];
        if (!currentBest || !newCandidate) return; 
        if (newCandidate.getTotalEval() > currentBest.getTotalEval()) this.bestNodeIDAtDepth1 = depth1NodeID;
    }
    
    findBestChildNodeID(nodeID) {
        const parentNode = this.nodeMap[nodeID];
        if (!parentNode || parentNode.childrenIDs.length === 0) return -1;
        let bestChildID = -1;
        let maxEval = -Infinity;
        for (const childID of parentNode.childrenIDs) {
            const childNode = this.nodeMap[childID];
            if (childNode) {
                const evalSum = childNode.getTotalEval();
                if (evalSum > maxEval) { maxEval = evalSum; bestChildID = childID; }
            }
        }
        return bestChildID;
    }

    select(nodeID) {
        let currentNode = this.nodeMap[nodeID];
        while (currentNode.expanded) {
            if (currentNode.childrenIDs.length === 0) return currentNode;
            const children = currentNode.childrenIDs.map(id => this.nodeMap[id]).filter(Boolean); 
            if (children.length === 0) return currentNode; 
            
            const evals = children.map(c => c.getTotalEval());
            const Emin = Math.min(...evals);
            const indexedEvals = evals.map((e, i) => ({ eval: e, index: i }));
            indexedEvals.sort((a, b) => b.eval - a.eval); 
            const ranks = new Int32Array(children.length);
            indexedEvals.forEach((item, rank_minus_1) => { ranks[item.index] = rank_minus_1 + 1; });

            let totalWeight = 0;
            const weights = children.map((child, i) => {
                const E_I = evals[i];
                const rank_I = ranks[i];
                const eval_part = Math.pow(E_I - Emin + 1.0, 2) + 10.0;
                const rank_part = Math.pow(rank_I - 1.0, 2) + 1.0;
                const weight = eval_part / rank_part;
                totalWeight += weight;
                return weight;
            });
            let rand = Math.random() * totalWeight;
            let selectedChild = null;
            for (let i = 0; i < weights.length; i++) {
                rand -= weights[i];
                if (rand <= 0) { selectedChild = children[i]; break; }
            }
            if (!selectedChild) selectedChild = children[children.length - 1];
            currentNode = selectedChild;
        }
        return currentNode;
    }

    // Prune and Reroot: Vectorized optimization
    pruneAndReroot(chosenNodeID) {
        const oldRootNode = this.nodeMap[chosenNodeID];
        if (!oldRootNode) {
            // Reset if invalid
            this.nodeMap = new Array(SEARCH_ITERATION_LIMIT + 1000);
            this.nodeIdCounter = 0;
            this.rootID = -1; 
            return;
        }
        
        // Create a NEW array to serve as vector
        const new_nodeMap = new Array(SEARCH_ITERATION_LIMIT + 1000);
        let newIdCounter = 0;

        // Queue for BFS copying
        // stores { oldID, newID, newDepth }
        const queue = [{ oldID: chosenNodeID, newID: newIdCounter++, newDepth: 0 }];
        
        // Map old IDs to new IDs to fix parent/child references
        const idMapping = new Map();
        
        while (queue.length > 0) {
            const { oldID, newID, newDepth } = queue.shift();
            const oldNode = this.nodeMap[oldID];
            if (!oldNode) continue;

            idMapping.set(oldID, newID);
            
            // Shallow copy node properties
            const newNode = new Node(
                newID, oldNode.board, oldNode.place, 
                -1, // parentID fixed later 
                newDepth, oldNode.comboCount, oldNode.b2b, oldNode.holdPiece, oldNode.holdUsedThisTurn
            );
            newNode.acc_eval = oldNode.acc_eval;
            newNode.transient_eval = oldNode.transient_eval;
            newNode.expanded = oldNode.expanded;
            newNode.childrenIDs = []; // Will fill

            new_nodeMap[newID] = newNode;

            // Process children
            for (const oldChildID of oldNode.childrenIDs) {
                if (this.nodeMap[oldChildID] !== undefined) {
                    const newChildID = newIdCounter++;
                    queue.push({ oldID: oldChildID, newID: newChildID, newDepth: newDepth + 1 });
                    newNode.childrenIDs.push(newChildID);
                }
            }
        }

        // Fix parent IDs
        for(let i=0; i<newIdCounter; i++) {
            const node = new_nodeMap[i];
            // If it was the chosen node (now root 0), parent is -1.
            // Otherwise, look up new parent ID.
            // Note: We only copied the chosen branch. The old parent of chosenNode is not in mapping.
            // We need a way to find parent. But BFS guarantees we visit parent first.
            // Actually simpler: We can just set parentID inside the loop if we pass it in queue.
        }
        // Re-loop to fix parents using mapping (slower but correct)
        // Optimization: Pass parentID in queue
        // Let's re-do the queue slightly to handle parentID efficiently
        
        // Clear and Reset
        // Simple approach: Just reset mapping logic. 
        // Since we construct childrenIDs in the loop above, we just need to set parentID.
        // The Root (0) has parent -1.
        for(let i=0; i<newIdCounter; i++) {
            const node = new_nodeMap[i];
            for(const childID of node.childrenIDs) {
                new_nodeMap[childID].parentID = node.id;
            }
        }
        new_nodeMap[0].parentID = -1;

        this.nodeMap = new_nodeMap;
        this.nodeIdCounter = newIdCounter;
        this.rootID = 0; // New root is always at index 0
        this.bestNodeIDAtDepth1 = -1; // Reset best choice
    }

    getLegalPlacements(board, pieceType) {
        // Zobrist Hash for Cache Key
        const boardHash = board.getHash();
        const cacheKey = pieceType + ':' + boardHash;

                if (lfgCache.has(cacheKey)) return lfgCache.get(cacheKey);

        const placements = [];
        const { landed, landed_tspin, hard_drop_reachable } = findLegalMoves(board, pieceType, SPAWN_X, SPAWN_Y, SPAWN_ROT);
        for (let r = 0; r < 4; r++) {
            if (lfg_isEmpty(landed[r])) continue;
            for (let y = 0; y < BOARD_HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    if (lfg_get(landed[r], x, y)) {
                        const p = new Placement(x, y, r, pieceType, false, false);
                        if (!lfg_get(hard_drop_reachable[r], x, y)) p.isSoftDrop = true;
                        placements.push(p);
                    }
                }
            }
        }
        for (let r = 0; r < 4; r++) {
            if (lfg_isEmpty(landed_tspin[r])) continue;
            for (let y = 0; y < BOARD_HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    if (lfg_get(landed_tspin[r], x, y)) {
                        const p = new Placement(x, y, r, pieceType, true, false);
                        if (!lfg_get(hard_drop_reachable[r], x, y)) p.isSoftDrop = true;
                        placements.push(p);
                    }
                }
            }
        }
        
        const result = { placements };
        lfgCache.set(cacheKey, result);
        return result;
    }
}

// --- Worker Logic ---
let isThinking = false;
let aiAgent = new AIAgent();
let currentQueue = [];
let lastUpdateTime = 0; // ★通信間引き用の時間を記録する変数を追加

function thinkingLoop() {
    if (!isThinking) return;

    // ★修正: 回数固定ではなく、時間いっぱいまで計算を回す
    const start = performance.now();
    while (performance.now() - start < 100) {
        aiAgent.searchStep(5000, currentQueue); // 小分けに実行
        if (aiAgent.totalNodesInSearch >= SEARCH_ITERATION_LIMIT) break;
    }

    // ★修正: 画面更新用のメッセージは 50ms に1回だけ送る (通信負荷の削減)
    const now = performance.now();
    if (now - lastUpdateTime > 50) {
        self.postMessage({ 
            type: 'nodeCount', 
            count: aiAgent.totalNodesInSearch,
            template: aiAgent.activeTemplate ? aiAgent.activeTemplate.name : null
        });
        lastUpdateTime = now;
    }

    setTimeout(thinkingLoop, 0);
}

self.onmessage = (e) => {
    // ★activeTemplates を受け取る★
    const { type, boardString, nextString, holdPiece, canHold, isB2B, ren, activeTemplates } = e.data;
    if (type === 'start') {
        try {
            const layout = JSON.parse(boardString);
            const board = TetrisBoard.fromSimulatorBoard(layout);
            
            currentQueue = nextString.split('');
            let hold = null;
            if (holdPiece !== undefined) {
                hold = holdPiece;
            } else if (aiAgent.rootID !== -1 && aiAgent.nodeMap[aiAgent.rootID]) {
                hold = aiAgent.nodeMap[aiAgent.rootID].holdPiece;
            }

            // ★activeTemplates を渡す★
            aiAgent.initSearch(board, currentQueue, hold, isB2B, ren, activeTemplates);
            if (canHold !== undefined && aiAgent.rootID !== -1 && aiAgent.nodeMap[aiAgent.rootID]) {
                aiAgent.nodeMap[aiAgent.rootID].holdUsedThisTurn = !canHold;
            }

            if (!isThinking) {
                isThinking = true;
                thinkingLoop();
            }
        } catch (err) {
            console.error("AI Worker Error (start):", err);
        }

    } else if (type === 'stop') {
        const bestPlacement = aiAgent.getBestMove();
        if (bestPlacement) {
            let finalX = bestPlacement.x;
            if (bestPlacement.pieceType === 'I') {
                finalX -= 1;
            }
            self.postMessage({
                type: 'debug',
                message: 'Move: ' + bestPlacement.pieceType + ' (x:' + finalX + ', y:' + bestPlacement.y + ', r:' + bestPlacement.rotation + ')'
            });
            self.postMessage({
                piece: bestPlacement.pieceType,
                x: finalX,
                y: bestPlacement.y,
                rotation: bestPlacement.rotation,
            });
            aiAgent.advanceTreeToBestMove();
            if (currentQueue.length > 0) {
                currentQueue.shift();
            }
        } else {
            self.postMessage(null);
            isThinking = false;
        }
    }
};
`;

const virtualController = (() => {

    let container, canvas, ctx, editControls;

    let mode = 'play';
    let layouts = {};
    let buttons = {};
    let selectedButtonId = null;
    let isDraggingButton = false;
    let isDraggingSlider = false;
    const activeTouches = {};

   
    const defaultLayout = {
        portrait: {
            'left':      { label: '←', x: 0.12, y: 0.82, r: 0.08 },
            'right':     { label: '→', x: 0.32, y: 0.82, r: 0.08 },
            'softDrop':  { label: '↓', x: 0.22, y: 0.92, r: 0.07 },
            'hardDrop':  { label: '↑', x: 0.22, y: 0.72, r: 0.07 },
            'rotateCCW': { label: 'L',  x: 0.65, y: 0.85, r: 0.10 },
            'rotateCW':  { label: 'R',  x: 0.85, y: 0.85, r: 0.10 },
            'hold':      { label: 'H',  x: 0.75, y: 0.68, r: 0.09 },
        },
        landscape: {
            'left':      { label: '←', x: 0.10, y: 0.75, r: 0.08 },
            'right':     { label: '→', x: 0.25, y: 0.75, r: 0.08 },
            'softDrop':  { label: '↓', x: 0.175,y: 0.90, r: 0.07 },
            'hardDrop':  { label: '↑', x: 0.175,y: 0.60, r: 0.07 },
            'rotateCCW': { label: 'L',  x: 0.80, y: 0.85, r: 0.10 },
            'rotateCW':  { label: 'R',  x: 0.90, y: 0.65, r: 0.10 },
            'hold':      { label: 'H',  x: 0.75, y: 0.60, r: 0.09 },
        }
    };
    
    function init() {
        container = document.getElementById('virtual-controller-container');
        canvas = document.getElementById('virtualControllerCanvas');
        ctx = canvas.getContext('2d');
        editControls = document.getElementById('vc-edit-controls');

        loadLayouts();
        handleResize();

        window.addEventListener('resize', handleResize);
        window.addEventListener('orientationchange', handleResize);

        canvas.addEventListener('touchstart', handleStart, { passive: false });
        canvas.addEventListener('touchmove', handleMove, { passive: false });
        canvas.addEventListener('touchend', handleEnd, { passive: false });
        canvas.addEventListener('touchcancel', handleEnd, { passive: false });
        

        let isMouseDown = false;
        const convertMouseEvent = (e) => ({ changedTouches: [{ clientX: e.clientX, clientY: e.clientY, identifier: -1 }], preventDefault: () => {} });
        canvas.addEventListener('mousedown', (e) => { isMouseDown = true; handleStart(convertMouseEvent(e)); });
        canvas.addEventListener('mousemove', (e) => { if (isMouseDown) handleMove(convertMouseEvent(e)); });
        window.addEventListener('mouseup', (e) => { if (isMouseDown) { isMouseDown = false; handleEnd(convertMouseEvent(e)); } });
    }

    function show() { if (container) container.style.display = 'block'; handleResize(); }
    function hide() { if (container) container.style.display = 'none'; }

    function startEditMode() {
        show();
        mode = 'edit';
        editControls.style.display = 'flex';
        selectedButtonId = null;
        draw();
    }

    function endEditMode() {
        mode = 'play';
        editControls.style.display = 'none';
        saveLayouts();
        if (gameState !== 'PLAYING') {
            hide();
        }
        draw();
    }
    
    function handleResize() {
        if (!canvas) return;
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const orientation = (canvas.width > canvas.height) ? 'landscape' : 'portrait';
       
        if (!layouts[orientation] || Object.keys(layouts[orientation]).length === 0) {
            layouts[orientation] = JSON.parse(JSON.stringify(defaultLayout[orientation]));
        }
        
        buttons = layouts[orientation];
       
        for(const id in buttons) {
            if (buttons[id].isPressed === undefined) {
                buttons[id].isPressed = false;
            }
        }
        
        draw();
    }

    function draw() {
        if (!ctx) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const shortSide = Math.min(canvas.width, canvas.height);

        for (const id in buttons) {
            const btn = buttons[id];
            const x = btn.x * canvas.width;
            const y = btn.y * canvas.height;
            const r = btn.r * shortSide;

            ctx.beginPath();
            ctx.arc(x, y, r, 0, 2 * Math.PI);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 3;
            if (btn.isPressed || (mode === 'edit' && id === selectedButtonId)) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.fill();
            }
            ctx.stroke();

            ctx.fillStyle = 'white';
            ctx.font = `bold ${r * 0.7}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(btn.label, x, y);
        }

        if (mode === 'edit' && selectedButtonId) {
            drawSizeSlider(shortSide);
        }
    }

    function drawSizeSlider(shortSide) {
        const centerX = canvas.width / 2;
        const y = canvas.height / 2;
        const sliderWidth = shortSide * 0.5;
        const minR = 0.04, maxR = 0.20;

        ctx.beginPath();
        ctx.moveTo(centerX - sliderWidth / 2, y);
        ctx.lineTo(centerX + sliderWidth / 2, y);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 5;
        ctx.stroke();

        const btn = buttons[selectedButtonId];
        const ratio = (btn.r - minR) / (maxR - minR);
        const handleX = (centerX - sliderWidth / 2) + sliderWidth * ratio;
        
        ctx.beginPath();
        ctx.arc(handleX, y, shortSide * 0.03, 0, 2 * Math.PI);
        ctx.fillStyle = 'white';
        ctx.fill();
    }

    function handleStart(e) {
        e.preventDefault();
        const touches = e.changedTouches;
        const shortSide = Math.min(canvas.width, canvas.height);

        for (let i = 0; i < touches.length; i++) {
            const touch = touches[i];
            const touchX = touch.clientX, touchY = touch.clientY;

            if (mode === 'play') {
                const buttonId = getButtonAt(touchX, touchY, shortSide);
                if (buttonId) {
                    pressButton(buttonId);
                    activeTouches[touch.identifier] = buttonId;
                }
            } else {
                const sliderHit = checkSliderHit(touchX, touchY, shortSide);
                if (sliderHit) {
                    isDraggingSlider = true;
                    activeTouches[touch.identifier] = 'slider';
                    updateSlider(touchX, shortSide);
                    return;
                }
                const buttonId = getButtonAt(touchX, touchY, shortSide);
                if (buttonId) {
                    selectedButtonId = buttonId;
                    isDraggingButton = true;
                    activeTouches[touch.identifier] = buttonId;
                } else {
                    selectedButtonId = null;
                }
            }
        }
        draw();
    }

    function handleMove(e) {
        e.preventDefault();
        const touches = e.changedTouches;
        const shortSide = Math.min(canvas.width, canvas.height);

        for (let i = 0; i < touches.length; i++) {
            const touch = touches[i];
            const touchId = touch.identifier;
            const touchX = touch.clientX, touchY = touch.clientY;

            if (mode === 'play') {
                const prevButtonId = activeTouches[touchId];
                const currentButtonId = getButtonAt(touchX, touchY, shortSide);
                if (prevButtonId !== currentButtonId) {
                    if (prevButtonId) releaseButton(prevButtonId);
                    if (currentButtonId) pressButton(currentButtonId);
                    activeTouches[touchId] = currentButtonId;
                }
            } else {
                if (isDraggingSlider && activeTouches[touchId] === 'slider') {
                    updateSlider(touchX, shortSide);
                } else if (isDraggingButton && activeTouches[touchId] === selectedButtonId) {
                    const btn = buttons[selectedButtonId];
                    btn.x = touchX / canvas.width;
                    btn.y = touchY / canvas.height;
                }
            }
        }
        draw();
    }

    function handleEnd(e) {
        e.preventDefault();
        const touches = e.changedTouches;
        for (let i = 0; i < touches.length; i++) {
            const touchId = touches[i].identifier;
            if (mode === 'play') {
                const buttonId = activeTouches[touchId];
                if (buttonId) releaseButton(buttonId);
            } else {
                if (isDraggingButton) isDraggingButton = false;
                if (isDraggingSlider) isDraggingSlider = false;
            }
            delete activeTouches[touchId];
        }
        draw();
    }

    function getButtonAt(x, y, shortSide) {
     
        const buttonIds = Object.keys(buttons).reverse();
        for (const id of buttonIds) {
            const btn = buttons[id];
            const btnX = btn.x * canvas.width;
            const btnY = btn.y * canvas.height;
            const btnR = btn.r * shortSide;
            if (Math.sqrt((x - btnX) ** 2 + (y - btnY) ** 2) <= btnR) {
                return id;
            }
        }
        return null;
    }

    function pressButton(id) {
        const btn = buttons[id];
        if (btn && !btn.isPressed) {
            btn.isPressed = true;

            if (['hardDrop', 'rotateCW', 'rotateCCW', 'hold'].includes(id)) {
                if(players.length > 0) players[0].handlePress(id);
            }
        }
    }
    
    function releaseButton(id) {
        const btn = buttons[id];
        if (btn) btn.isPressed = false;
    }

    function checkSliderHit(x, y, shortSide) {
        if (!selectedButtonId) return false;
        const centerX = canvas.width / 2, sliderY = canvas.height / 2;
        const sliderWidth = shortSide * 0.5, handleRadius = shortSide * 0.03;
        const minR = 0.04, maxR = 0.20;
        const ratio = (buttons[selectedButtonId].r - minR) / (maxR - minR);
        const handleX = (centerX - sliderWidth / 2) + sliderWidth * ratio;
        return Math.sqrt((x - handleX) ** 2 + (y - sliderY) ** 2) <= handleRadius;
    }

    function updateSlider(touchX, shortSide) {
        if (!selectedButtonId) return;
        const centerX = canvas.width / 2, sliderWidth = shortSide * 0.5;
        const sliderStart = centerX - sliderWidth / 2;
        const clampedX = Math.max(sliderStart, Math.min(touchX, sliderStart + sliderWidth));
        const newRatio = (clampedX - sliderStart) / sliderWidth;
        const minR = 0.04, maxR = 0.20;
        buttons[selectedButtonId].r = minR + (maxR - minR) * newRatio;
    }

    function saveLayouts() {
        try {
            localStorage.setItem('tetrisVirtualPadLayouts', JSON.stringify(layouts));
        } catch (e) {
            console.error("Failed to save virtual pad layouts:", e);
        }
    }

    function loadLayouts() {
        try {
            const savedLayouts = JSON.parse(localStorage.getItem('tetrisVirtualPadLayouts'));
            if (savedLayouts && savedLayouts.portrait && savedLayouts.landscape) {
                layouts = savedLayouts;
            } else {
                layouts = JSON.parse(JSON.stringify(defaultLayout));
            }
        } catch (e) {
            console.error("Failed to load virtual pad layouts:", e);
            layouts = JSON.parse(JSON.stringify(defaultLayout));
        }
    }

    async function copyLayoutsToClipboard() {
        try {
            await navigator.clipboard.writeText(JSON.stringify(layouts, null, 2));
            alert('ボタン配置をクリップボードにコピーしました。');
        } catch (err) {
            alert('コピーに失敗しました。');
            console.error('Failed to copy layouts: ', err);
        }
    }

    async function importLayoutsFromClipboard() {
        if (!confirm('クリップボードからボタン配置を読み込みますか？現在の配置は上書きされます。')) return;
        try {
            const text = await navigator.clipboard.readText();
            const newLayouts = JSON.parse(text);
            if (newLayouts && newLayouts.portrait && newLayouts.landscape) {
                layouts = newLayouts;
                saveLayouts();
                handleResize();
                alert('ボタン配置をインポートしました。');
            } else {
                alert('無効なデータ形式です。');
            }
        } catch (err) {
            alert('インポートに失敗しました。');
            console.error('Failed to paste layouts: ', err);
        }
    }
    
    return {
        init,
        show,
        hide,
        startEditMode,
        endEditMode,
        isButtonPressed: (action) => buttons[action]?.isPressed || false,
        copyLayoutsToClipboard,
        importLayoutsFromClipboard
    };
})();

const RESOLUTION_SCALE = 2;
const BLOCK_SIZE = 28;
const EDITOR_BLOCK_SIZE = 50;
const BOARD_WIDTH = 10;
const BOARD_VISIBLE_HEIGHT = 20;
const BOARD_HEIGHT = 40; 
const HOLD_AREA_WIDTH = 5 * BLOCK_SIZE;
const PLAYFIELD_WIDTH = BOARD_WIDTH * BLOCK_SIZE;
const NEXT_AREA_WIDTH = 5 * BLOCK_SIZE;
const PADDING = 20;
const PLAYER_CANVAS_WIDTH = HOLD_AREA_WIDTH + PLAYFIELD_WIDTH + NEXT_AREA_WIDTH + PADDING * 2;
const CANVAS_HEIGHT = (BOARD_VISIBLE_HEIGHT + 0.5) * BLOCK_SIZE;
const PLAYFIELD_X_OFFSET = HOLD_AREA_WIDTH + PADDING;
const AXIS_THRESHOLD = 0.8;

const AI_TEMPLATE_CONFIG = [
    { id: 'meisou', label: '迷走砲' },
    { id: 'sangaku_2', label: '山岳積み2号' }
];
// デフォルトのレイアウト生成関数
function generateDefaultLayout() {
    const blockSize = 28;
    // 従来の定数計算に基づく配置
    const p1OriginX = 0;
    const p2OriginX = (5 * blockSize + 10 * blockSize + 5 * blockSize + 20 * 2);
    // PLAYER_CANVAS_WIDTH

    const createPlayerLayout = (offsetX) => ({
        board: { x: offsetX + (5 * blockSize + 20), y: 0.5 * blockSize },
        hold: { x: offsetX + (5 * blockSize / 2), y: 70 },
        next: Array.from({ length: 8 }).map((_, i) => ({
                    x: offsetX + 
(5 * blockSize + 20 + 10 * blockSize + 20 + 5 * blockSize / 2),
            y: 70 + (i * blockSize * 2.5)
        }))
    });
    return {
        backgroundImage: null, // 設定されている場合、個別背景やUIラベルを描画しない
        blockSize: blockSize,
        uiBlockSize: blockSize,
        p1: createPlayerLayout(p1OriginX),
        p2: createPlayerLayout(p2OriginX)
    };
}  

// AIの判定と一致させるためのゴーストブロック用相対座標定義
const GHOST_SHAPE_DEFINITIONS = {
    'I': [[[0,0], [-1,0], [1,0], [2,0]], [[1,0], [1,-1], [1,1], [1,2]], [[0,1], [-1,1], [1,1], [2,1]], [[0,0], [0,-1], [0,1], [0,2]]],
    'O': [[[0,0], [1,0], [0,-1], [1,-1]], [[0,0], [1,0], [0,-1], [1,-1]], [[0,0], [1,0], [0,-1], [1,-1]], [[0,0], [1,0], [0,-1], [1,-1]]],
    'T': [[[0,0], [-1,0], [1,0], [0,-1]], [[0,0], [0,-1], [1,0], [0,1]], [[0,0], [1,0], [-1,0], [0,1]], [[0,0], [0,1], [-1,0], [0,-1]]],
    'S': [[[0,0], [-1,0], [0,-1], [1,-1]], [[0,0], [0,-1], [1,0], [1,1]], [[0,0], [1,0], [0,1], [-1,1]], [[0,0], [0,1], [-1,0], [-1,-1]]],
    'Z': [[[0,0], [1,0], [0,-1], [-1,-1]], [[0,0], [0,1], [1,0], [1,-1]], [[0,0], [-1,0], [0,1], [1,1]], [[0,0], [0,-1], [-1,0], [-1,1]]],
    'J': [[[0,0], [-1,0], [1,0], [-1,-1]], [[0,0], [0,-1], [0,1], [1,-1]], [[0,0], [1,0], [-1,0], [1,1]], [[0,0], [0,1], [0,-1], [-1,1]]],
    'L': [[[0,0], [1,0], [-1,0], [1,-1]], [[0,0], [0,1], [0,-1], [1,1]], [[0,0], [-1,0], [1,0], [-1,1]], [[0,0], [0,-1], [0,1], [-1,-1]]]
};

let gameSettings = {
    das: 140,
    arr: 30,
    sdf: 20,
    lineClearDelay: 0,
    gravity: 9999999,
    lockDelay: 9999999,
    garbageGrace: 1000,
    garbageRandomness: 0.3,
    maxNext: 8,
    showEffects: true,
    showTimer: false,
    touchControlsEnabled: 'ontouchstart' in window,
    touchControlType: 'button',
    aiMoveDelay: 30,
    aiSdfDelay: 30,
    drawMoveDelay: 30,
    aiTemplates: { meisou: true, sangaku_2: 
true },
    aiHintEnabled: false,
    debugEnabled: false,
    pieceForPieceMode: false,
   
 layout: generateDefaultLayout() 
};
const DRAW_SHAPE_MAP = {
    "1,0;2,0;3,0": { type: "I", rot: 0, offset: [0, 0] },
    "0,1;0,2;0,3": { type: "I", rot: 1, offset: [2, -1] },
    "0,1;1,0;1,1": { type: "O", rot: 0, offset: [0, -1] },
    "-1,1;0,1;1,1": { type: "T", rot: 0, offset: [0, -1] },
    "0,1;0,2;1,1": { type: "T", rot: 1, offset: [0, -1] },
    "1,0;1,1;2,0": { type: "T", rot: 2, offset: [-1, 0] },
    "-1,1;0,1;0,2": { type: "T", rot: 3, offset: [0, -1] },
    "-1,1;-2,1;0,1": { type: "L", rot: 0, offset: [1, -1] },
    "0,1;0,2;1,2": { type: "L", rot: 1, offset: [0, -1] },
    "0,1;1,0;2,0": { type: "L", rot: 2, offset: [-1, 0] },
    "1,0;1,1;1,2": { type: "L", rot: 3, offset: [-1, -1] },
    "0,1;1,1;2,1": { type: "J", rot: 0, offset: [-1, -1] },
    "0,1;0,2;1,0": { type: "J", rot: 1, offset: [0, -1] },
    "1,0;2,0;2,1": { type: "J", rot: 2, offset: [-1, 0] },
    "-1,2;0,1;0,2": { type: "J", rot: 3, offset: [0, -1] 
},
    "-1,1;0,1;1,0": { type: "S", rot: 0, offset: [0, -1] },
    "0,1;1,1;1,2": { type: "S", rot: 1, offset: [0, -1] },
    "1,0;1,1;2,1": { type: "Z", rot: 0, offset: [-1, -1] },
    "-1,1;-1,2;0,1": { type: "Z", rot: 1, offset: [1, -1] },
};
const COLORS = { 'I': '#00f0f0', 'O': '#f0f000', 'T': '#a000f0', 'L': '#f0a000', 'J': '#0000f0', 'S': '#00f000', 'Z': '#f00000', 'G': '#999999', 'E': '#808080' };
const SCAN_COLOR_PALETTE = {
    'NULL': ['#000000', '#302838'],
    'G':    ['#999999', '#D8D8D8'],
    'I':    ['#019899', '#0199D5'],
    'O':    ['#999A02', '#F9B900'],
    'T':    ['#980099', '#871E88'],
    'L':    ['#996700', '#F56100'],
    'J':    ['#0000BB', '#004BA5'],
    'S':    ['#10971F', '#5CB523'],
    'Z':    ['#990000', '#DA1822']
};
const hexToRgb = (hex) => {
    const r = parseInt(hex.slice(1, 3), 16);
const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return { r, g, b };
};
const PARSED_SCAN_COLORS = {};
for (const key in SCAN_COLOR_PALETTE) {
    PARSED_SCAN_COLORS[key] = SCAN_COLOR_PALETTE[key].map(hexToRgb);
}


const SCAN_COLORS = { ...COLORS, 'O': '#999A02', 'L': '#f0a000' };
const activeSkinColors = { ...COLORS };
const MINO_SKINS = { default: {} };
['I', 'O', 'T', 'L', 'J', 'S', 'Z', 'G', 'E', 'BG'].forEach(k => MINO_SKINS.default[k] = new Image());
let activeSkin = MINO_SKINS.default;

const EDITOR_COLORS = {...COLORS, 'EMPTY': '#000000'};
const TETROMINOS = {
    'I': { shape: [[0, 0], [1, 0], [2, 0], [3, 0]], center: [1.5, 0.5] }, 'O': { shape: [[0, 0], [1, 0], [0, -1], [1, -1]], center: [0.5, -0.5] },
    'T': { shape: [[0, 0], [-1, 0], [0, -1], [1, 0]], center: [0, 0] }, 'L': { shape: [[-1, 0], [0, 0], [1, 0], [1, -1]], center: [0, 0] },
    'J': { shape: [[0, 0], [-1, 0], [1, 0], [-1, -1]], center: [0, 0] }, 'S': { shape: [[1, -1], [-1, 0], [0, 0], [0, -1]], center: [0, 0] },
    'Z': { shape: [[0, 0], [1, 0], [0, -1], [-1, -1]], center: [0, 0] }
};
const SRS_OFFSETS = { "JLSTZ": { "0_1": [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]], "1_0": [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]], "1_2": [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]], "2_1": [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]], "2_3": [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]], "3_2": [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]], "3_0": [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]], "0_3": [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]], }, "I": { "0_1": [[0, 0], [-2, 0], [1, 0], [-2, -1], [1, 2]], "1_0": [[0, 0], [2, 0], [-1, 0], [2, 1], [-1, -2]], "1_2": [[0, 0], [-1, 0], [2, 0], [-1, 2], [2, -1]], "2_1": [[0, 0], [1, 0], [-2, 0], [1, -2], [-2, 1]], "2_3": [[0, 0], [2, 0], [-1, 0], [2, 1], [-1, -2]], "3_2": [[0, 0], [-2, 0], [1, 0], [-2, -1], [1, 2]], "3_0": [[0, 0], [1, 0], [-2, 0], [1, -2], [-2, 1]], "0_3": [[0, 0], [-1, 0], [2, 0], [-1, 2], [2, -1]], } };

let players = [], gameMode = '1P', gameState = 'EDITING', lastTime = 0, mainCanvas, ctx, aiWorkerBlob, gameStartTime = 0;
let gameHistoryLog = [];
let analysisData = []; // { time, p1_R, p2_R, offsetLines }
function updateAiDebugDisplay(payload) {
    const display = document.getElementById('ai-debug-display');

    if (!display || !gameSettings.debugEnabled) return;
// 盤面データをJavaScriptの2D配列形式の文字列に変換します
    let boardArrayString = '[\n';
    for (let y = 0; y < payload.board.length; y++) {
        const row = payload.board[y];
        // 各セルを 'null' または引用符付きの文字列 ('G'など) に変換します
        const rowString = row.map(cell => cell === null ? 'null' : `"${cell}"`).join(', ');
        boardArrayString += `  [${rowString}]`;
        if (y < payload.board.length - 1) {
            boardArrayString += ',\n'; // 最終行以外はカンマと改行を追加
        }
    }
    boardArrayString += '\n]';

    // 表示用のHTMLを生成します。盤面部分はtextareaに置き換えます。
    display.innerHTML = `
        PlayerID: ${payload.playerId}<br>
        REN: ${payload.ren}, B2B: ${payload.isB2B}<br>
        Hold: ${payload.holdPiece || 'none'} (CanHold: ${payload.canHold})<br>
        Next: ${payload.minoSequence.join(', ')}<br>
        Board (2D Array):<br>
        <textarea readonly style="width: 95%; height: 150px; font-family: monospace; font-size: 10px; background: #222; color: #eee; border: 1px solid #555; resize: vertical;"></textarea>
    `;

    // innerHTMLで設定した後、textareaのvalueに文字列を代入することで、
    // 改行が正しく反映され、コピー可能な状態になります。
    display.querySelector('textarea').value = boardArrayString;
}

let keyBindings = {
        p1: {
        left:      { type: 'key', value: 'a',           label: 'a' },
        right:     { type: 'key', value: 'd',           label: 'd' },
        softDrop:  { type: 'key', value: 's',           label: 's' },
    
        hardDrop:  { type: 'key', value: ' ',           label: 'Space' },
        rotateCW:  { type: 'key', value: 'e',           label: 'e' },
        rotateCCW: { type: 'key', value: 'q',           label: 'q' },
        hold:      { type: 'key', value: 'w',     
      label: 'w' },
        retry:     { type: 'key', value: 'r',           label: 'r' },
        exit:      { type: 'key', value: 'escape',      label: 'Esc' },
    },
    p2: {
        left:      { type: 'key', value: 'arrowleft',   label: 'ArrowLeft' },
        right:     { type: 'key', value: 'arrowright',  label: 'ArrowRight' },
        softDrop:  { type: 'key', value: 'arrowdown',   label: 'ArrowDown' },
        hardDrop:  { type: 'key', value: 'enter',      
 label: 'Enter' },
        rotateCW:  { type: 'key', value: 'arrowup',     label: 'ArrowUp' },
        rotateCCW: { type: 'key', value: '.',           label: '.'
},
        hold:      { type: 'key', value: '/',           label: '/' },
        retry:     { type: 'key', value: 'backspace',   label: 'BackSpace' },
        exit:      { type: 'key', value: 'delete',      label: 'Del' },
    }
};
const keyActionLabels = {
    left: '左移動', right: '右移動', softDrop: 'ソフトドロップ',
    rotateCW: '右回転', rotateCCW: '左回転',
    hardDrop: 'ハードドロップ', hold: 'ホールド',
    retry: 'リトライ', exit: '中断'
};
let isBindingKey = false, bindingPlayer = null, bindingAction = null;
let gamepads = {}, prevGamepads = {};

const editorData = {
    p1: { board: null, nextQueue: [], hold: null, viewY: BOARD_HEIGHT - BOARD_VISIBLE_HEIGHT, activeColor: 'I', nextInsertionIndex: -1 },
    p2: { board: null, nextQueue: [], hold: null, viewY: BOARD_HEIGHT - BOARD_VISIBLE_HEIGHT, activeColor: 'I', nextInsertionIndex: -1 },
    rule: { description: '', code: '' }
};

let scanState = { image: null, bottomLeft: null, topRight: null, currentMousePos: {x: 0, y: 0}, targetPlayerId: null, parsedColors: null };

function* createMinoGenerator(customQueue) {
    if (customQueue && customQueue.length > 0) {
        yield* customQueue;
    }
    const bag = [];
    const pieces = Object.keys(TETROMINOS);
    while (true) {
        if (bag.length === 0) {
            const newBag = [...pieces];
            for (let i = newBag.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newBag[i], newBag[j]] = [newBag[j], newBag[i]];
            }
            bag.push(...newBag);
        }
        yield bag.shift();
    }
}

class Player {
    constructor(id, offsetX, keyBindings, padIndex, isAi = false) {
        this.id = id;
        this.offsetX = offsetX; this.keyBindings = keyBindings; this.padIndex = padIndex;
        this.isAi = isAi;
        this.isAiThinking = false;
        this.aiWorker = null;
        
        this.aiType = gameSettings.aiType || 'simplified'; 

        if (this.isAi) {
            // AIタイプによって読み込むスクリプトを変える
            let scriptToLoad = aiWorkerScript_Simplified;
            if (this.aiType === 'default') {
                scriptToLoad = aiWorkerScript;//strongly simplified
            }

            const blob = new Blob([scriptToLoad], { type: 'application/javascript' });
            this.aiWorker = new Worker(URL.createObjectURL(blob));

                        this.aiWorker.onmessage = (e) => {
                if (e.data && e.data.type === 'debug') {
                    const debugDisplay = document.getElementById('ai-tree-debug-display');
if (debugDisplay && gameSettings.debugEnabled) {
                        debugDisplay.dataset.status = e.data.message;
const count = debugDisplay.dataset.count || 0;
                        
                        debugDisplay.style.display = 'block';
                        debugDisplay.innerHTML = `Status: <span style="color: ${e.data.message.includes('RESET') ? '#ff4444' : '#44ff44'}">${e.data.message}</span><br>Nodes: ${count}`;
                    }
                                } else if (e.data && e.data.type === 'nodeCount') {
                    const debugDisplay = document.getElementById('ai-tree-debug-display');
if (debugDisplay && gameSettings.debugEnabled) {
                        debugDisplay.dataset.count = e.data.count;
const status = debugDisplay.dataset.status || 'Waiting...';
                        
                        debugDisplay.style.display = 'block';
                        const color = status.includes('RESET') ? '#ff4444' : (status.includes('REUSED') ? '#44ff44' : 'white');
                        const templateInfo = e.data.template ? `<br>Template: <span style="color: #00ffff">${e.data.template}</span>` : '';
                        debugDisplay.innerHTML = `Status: <span style="color: ${color}">${status}</span><br>Nodes: ${e.data.count}${templateInfo}`;
                    }
                } else if (gameState === 'PLAYING' && this.isAiThinking) {
                    this.executeAiMove(e.data);
                }
            };
}
        
        // AIヒント用Workerの初期化
        this.hintAiWorker = null;
        this.aiHintGhosts = []; // ヒント表示用座標配列
        if (this.id === '1' && gameSettings.aiHintEnabled && !this.isAi) {
            const blob = new Blob([aiWorkerScript_Simplified], { type: 'application/javascript' });
            this.hintAiWorker = new Worker(URL.createObjectURL(blob));
            this.hintAiWorker.onmessage = (e) => {
                if (e.data && e.data.type === 'stop') {
                    // 最善手の座標を受け取り、ゴーストブロック座標に変換して保存
                    if (e.data.piece) {
                        const { piece, x, y, rotation } = e.data;
                        const offsets = GHOST_SHAPE_DEFINITIONS[piece][rotation];
                        this.aiHintGhosts = offsets.map(o => ({
                            x: x + o[0],
                            y: y + o[1],
                            pieceType: piece
                        }));
                    } else {
                        this.aiHintGhosts = [];
                    }
                }
            };
        }

        this.isDrawingOnBoard = false;
        this.drawnBlocks = new Map();
        this.customGhosts = [];

        this.keys = {};
        const pData = editorData[`p${id}`];


        this.initialHold = pData.hold;
        this.board = pData.board.map(row => [...row]);
        this.minoGenerator = createMinoGenerator(pData.nextQueue);
        this.opponent = null;
        this.holdDisabled = false;
        this.ruleWorker = null;
        this.activeRuleHooks = {};
        this.reset();
    }

reset() {
        if (this.id === '1') analysisData = []; // P1リセット時に分析データも初期化
        this.pieceCount = 0;
        this.linesClearedLastLock = 0;
        this.player = { x: 0, y: 0, pieceType: null, rotation: 0 };
this.nextQueue = [];
        this.fullMinoSequence = [];
        for (let i = 0; i < gameSettings.maxNext; i++) {
            const newMino = this.minoGenerator.next().value;
            this.nextQueue.push(newMino);
            this.fullMinoSequence.push(newMino);
}
                this.isExecutingSequence = false;
        this.drawnBlocks.clear();
        this.isDrawingOnBoard = false;
        this.customGhosts = [];
        this.aiHintGhosts = [];
this.holdPiece = this.initialHold;this.canHold = true;
this.gravityTimer = gameSettings.gravity; this.lockTimer = 0;

        this.dasTimer = 0; this.arrTimer = 0; this.sdfTimer = 0; this.dasDirection = 0;
        this.isGrounded = false; this.gameOver = false; this.isClearingLine = false; this.lineClearDelayTimer = 0;
        this.gameClear = false;

        this.stats = {
            tSpinSingle: 0, tSpinDouble: 0, tSpinTriple: 0,
            miniTSpinSingle: 0, miniTSpinDouble: 0,
            perfectClear: 0, tetris: 0, ren: -1
        };

        this.viewY = BOARD_HEIGHT - BOARD_VISIBLE_HEIGHT;
        this.pendingGarbage = 0;this.garbageQueue = []; this.ren = -1; this.isB2B = false;
        this.lastMoveWasRotation = false;
        this.lastSrsKickIndex = -1;
        this.specialMoveText = [];
        this.specialMoveTextTimer = 0;
        this.customUIText = null;
        this.elapsedTimeText = '0:00.000';
        this.lastGarbageHoleX = -1;
        this.spawnNewPiece();
    }

    
        
    spawnNewPiece() {
        this.player.pieceType = this.nextQueue.shift();
        const newMino = this.minoGenerator.next().value;
        this.nextQueue.push(newMino);
        this.fullMinoSequence.push(newMino);

        
        this.player.rotation = 0;
        this.canHold = true;
        this.lastMoveWasRotation = false;
                this.player.x = Math.floor(BOARD_WIDTH / 2) - Math.floor(TETROMINOS[this.player.pieceType].center[0]) -1;

        const shape = this.getShape(this.player.pieceType, this.player.rotation);
        this.player.y = 20;
if (this.checkCollision(this.player.x, this.player.y, shape)) {
            this.player.y = 19;
if (this.checkCollision(this.player.x, this.player.y, shape)) {

                 this.gameOver = true;
}
        }
        this.requestAiHint(); // 新しいピースが出現したらヒントをリクエスト
    }

    // AIヒントを計算リクエストするメソッド
    requestAiHint() {
        if (!this.hintAiWorker || this.gameOver) return;
        
        let boardString = '[\n';
        for (let y = 0; y < this.board.length; y++) {
            const row = this.board[y];
            const rowString = row.map(cell => cell === null ? 'null' : `"${cell}"`).join(', ');
            boardString += `  [${rowString}]`;
            if (y < this.board.length - 1) boardString += ',\n';
        }
        boardString += '\n]';

        let nextString;
        let holdPieceToSend = this.holdPiece;
        if (!holdPieceToSend) {
            holdPieceToSend = this.player.pieceType;
            nextString = this.nextQueue.join('');
        } else {
            const nextPiecesForWorker = [this.player.pieceType, ...this.nextQueue];
            nextString = nextPiecesForWorker.join('');
        }

        const payload = {
            type: 'start',
            boardString: boardString,
            nextString: nextString,
            holdPiece: holdPieceToSend,
            canHold: this.canHold,
            isB2B: this.isB2B,
            ren: this.ren + 1,
            activeTemplates: gameSettings.aiTemplates
        };
        this.hintAiWorker.postMessage(payload);
        this.hintAiWorker.postMessage({ type: 'stop' });
    }

    isActionPressed(action) {
        const binding = this.keyBindings[action];
        if (binding?.type === 'key' && this.keys[binding.value]) return true;
        
        if (this.padIndex !== null && gamepads[this.padIndex]) {
            if (binding?.type === 'pad_button' && gamepads[this.padIndex].buttons[binding.value]) return true;
            if (binding?.type === 'pad_axis') {
                const [axis, dir] = [parseInt(binding.value[0]), binding.value[1]];
                const axisValue = gamepads[this.padIndex].axes[axis];
                if ((dir === '+' && axisValue > AXIS_THRESHOLD) || (dir === '-' && axisValue < -AXIS_THRESHOLD)) return true;
            }
        }
        

        if (this.id === '1' && gameSettings.touchControlsEnabled && gameSettings.touchControlType === 'button') {
            if (virtualController.isButtonPressed(action)) return true;
        }

        return false;
    }
    handlePress(action) {
        if (action === 'retry') { document.getElementById('retryBtn').click(); return; }
        if (action === 'exit') { document.getElementById('backToEditorBtn').click(); return; }

        if (this.gameOver || this.isClearingLine || this.isExecutingSequence) return;
switch (action) {
            case 'rotateCCW': this.rotate(-1); break;
case 'rotateCW':  this.rotate(1); break;

            case 'hardDrop':  this.hardDrop(); break;
            case 'hold':      this.hold(); break;
}
}
    
update(dt) {
        if (gameStartTime > 0) {
            const totalMilliseconds = performance.now() - gameStartTime;
const minutes = Math.floor(totalMilliseconds / 60000);
            const seconds = Math.floor((totalMilliseconds % 60000) / 1000);
            const milliseconds = Math.floor(totalMilliseconds % 1000);
this.elapsedTimeText = `${minutes}:${String(seconds).padStart(2, '0')}.${String(milliseconds).padStart(3, '0')}`;
        }

        if (this.gameOver || this.gameClear || this.isExecutingSequence) return;
if (this.specialMoveTextTimer > 0) {
            this.specialMoveTextTimer -= dt;
}
    
this.processGarbageQueue();
        const left = this.isActionPressed('left');
        const right = this.isActionPressed('right');

        const horizDir = left ? -1 : (right ? 1 : 0);
        if (horizDir !== 0) {
            if (this.dasDirection !== horizDir) { 
                this.dasTimer = 0;
                this.arrTimer = 0;
                if (!this.isClearingLine) this.move(horizDir, 0);
            } else { 
                this.dasTimer += dt;
                if (this.dasTimer >= gameSettings.das) {
                    if (gameSettings.arr === 0) {
                        if (!this.isClearingLine) {
                            let successfulMoves = 0;
                            while (!this.checkCollision(this.player.x + horizDir, this.player.y, this.getShape(this.player.pieceType, this.player.rotation))) {
                                this.player.x += horizDir;
                                successfulMoves++;
                            }
                            if (successfulMoves > 0) {
                               this.lockTimer = 0;
                               this.lastMoveWasRotation = false;
                            }
                        }
                    } else {
                        this.arrTimer += dt;
                        if (this.arrTimer >= gameSettings.arr) {
                            if (!this.isClearingLine) this.move(horizDir, 0);
                            this.arrTimer -= gameSettings.arr;
                        }
                    }
                }
            }
        }
        this.dasDirection = horizDir;

        if (this.isClearingLine) {
            this.lineClearDelayTimer -= dt;
if (this.lineClearDelayTimer <= 0) { 
                this.isClearingLine = false;
this.riseGarbage(); 
                if (this.nextQueue[0] === 'E') {
                    if (this.holdPiece) {
                        this.player.pieceType = this.holdPiece;
this.holdPiece = null;
                        this.canHold = false;
                        
                        this.player.rotation = 0;
                        this.lockTimer = 0;
                        this.lastMoveWasRotation = false;
this.player.x = Math.floor(BOARD_WIDTH / 2) - Math.floor(TETROMINOS[this.player.pieceType].center[0]) -1;
                        const shape = this.getShape(this.player.pieceType, this.player.rotation);
                        this.player.y = 20;
if (this.checkCollision(this.player.x, this.player.y, shape)) {
                            this.player.y = 19;
if (this.checkCollision(this.player.x, this.player.y, shape)) {
                                 this.gameOver = true;
}
                        }
                        return;
} else {
                        this.gameOver = true;
return;
                    }
                }
                this.spawnNewPiece();
}
            return;
}

        if (this.isAi) {
            if (!this.isAiThinking) {
                if (gameSettings.pieceForPieceMode && this.opponent && this.pieceCount >= this.opponent.pieceCount) {
                    return;
                }
                this.requestAiMove();
            }
            return;
        }

        if (this.activeRuleHooks.onUpdate) {
            const playerStateProxy = {
                id: this.id,
                stats: this.stats,
            };
this.ruleWorker.postMessage({
                command: 'update',
                data: {
                    playerStateProxy: {
                        id: this.id,
                    
    stats: this.stats,
                        board: this.board,
                        holdPiece: this.holdPiece,
                        currentPiece: this.player.pieceType,
                        nextQueue: this.nextQueue,
                    
    fullMinoSequence: this.fullMinoSequence
                    },
                    is2P: gameMode === '2P'
                }
      });
}
        if (this.gameOver || this.gameClear) return;
if (this.isActionPressed('softDrop')) {
             if (gameSettings.sdf > 0) {
                this.sdfTimer += dt;
                if (this.sdfTimer >= gameSettings.sdf) {
                    this.move(0, 1);
                    this.sdfTimer -= gameSettings.sdf;
                }
             } else { 
                const ghostY = this.getGhostY();
                if (this.player.y < ghostY) {
                    this.player.y = ghostY;
                    this.lockTimer = 0;
                }
             }
        } else {
            this.sdfTimer = 0;
        }
        
        this.isGrounded = this.checkCollision(this.player.x, this.player.y + 1, this.getShape(this.player.pieceType, this.player.rotation));
        if (this.isGrounded) {
            this.lockTimer += dt;
            if (this.lockTimer >= gameSettings.lockDelay) {
                this.lockPiece();
            }
        } else {
            this.lockTimer = 0;
            if (!this.isActionPressed('softDrop')) {
                 if (gameSettings.gravity > 0) {
                    this.gravityTimer -= dt;
                    if (this.gravityTimer <= 0) {
                        this.move(0, 1, false);
                        this.gravityTimer += gameSettings.gravity;
                    }
                 } else { 
                    this.player.y = this.getGhostY();
 }
            }
        }
    }
        draw() {
        const layout = gameSettings.layout;
        const pLayout = (this.id === '1') ? layout.p1 : layout.p2;
        const bSize = layout.blockSize;
        const uiBSize = layout.uiBlockSize || bSize;
        const useCustomBG = !!layout.backgroundImage;
        // UI描画 (Hold, Next)
        this.drawUI(pLayout, uiBSize, useCustomBG);
        // 盤面の描画位置へ移動
        ctx.save();
        ctx.translate(pLayout.board.x, pLayout.board.y);

        // 背景描画
        if (!useCustomBG) {
            if (activeSkin['BG'] && activeSkin['BG'].src) {
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(0, 0, BOARD_WIDTH * bSize, BOARD_VISIBLE_HEIGHT * bSize);
                
                for (let y = 0; y < BOARD_VISIBLE_HEIGHT; y++) {
                    for (let x = 0; x < BOARD_WIDTH; x++) {
                        ctx.drawImage(activeSkin['BG'], x * bSize, y * bSize, bSize, bSize);
                    }
                }
            } else {
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(0, 0, BOARD_WIDTH * bSize, BOARD_VISIBLE_HEIGHT * bSize);
            }
            
            // Grid
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 0.5;
            for (let y = 0; y < BOARD_VISIBLE_HEIGHT; y++) {
                for (let x = 0; x < BOARD_WIDTH; x++) {
                    ctx.strokeRect(x * bSize, y * bSize, bSize, bSize);
                }
            }
            // Border
            ctx.strokeStyle = '#4b4b7c';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, BOARD_WIDTH * bSize, BOARD_VISIBLE_HEIGHT * bSize);
        }

        // Blocks
        for (let y = 0; y < BOARD_VISIBLE_HEIGHT; y++) {
            for (let x = 0; x < BOARD_WIDTH; x++) {
                const boardY = y + this.viewY;
                if (this.board[boardY]?.[x]) {
                    this.drawBlock(this.board[boardY][x], x * bSize, y * bSize, 1.0, bSize);
                }
            }
        }

        const occupiedCells = new Set();
        let shape, ghostY;
        
        // プレイヤー操作ミノ等の描画ブロック
        if (!this.gameOver && !this.gameClear && !this.isClearingLine && this.player.pieceType) { 
            shape = this.getShape(this.player.pieceType, this.player.rotation);
            ghostY = this.getGhostY(); 
            
            // ゴースト描画
            if (ghostY > this.player.y) {
                this.drawPiece(shape, this.player.x, ghostY, this.player.pieceType, 0.4, bSize);
                shape.forEach(b => {
                    const bx = Math.floor(this.player.x + b[0]);
                    const by = Math.floor(ghostY + b[1]);
                    occupiedCells.add(`${bx},${by}`);
                });
            }

            // 本体描画 (条件分岐の外に出して常に描画するように修正)
            this.drawPiece(shape, this.player.x, this.player.y, this.player.pieceType, 1.0, bSize);
            shape.forEach(b => {
                const bx = Math.floor(this.player.x + b[0]);
                const by = Math.floor(this.player.y + b[1]);
                occupiedCells.add(`${bx},${by}`);
            });

            // AI Hint Ghosts (最善手ゴースト)
            if (this.aiHintGhosts.length > 0 && !this.gameOver) {
                ctx.lineWidth = 2;
                this.aiHintGhosts.forEach(block => {
                    const screenY = block.y - this.viewY;
                    if (screenY >= 0 && screenY < BOARD_VISIBLE_HEIGHT) {
                        const px = block.x * bSize;
                        const py = screenY * bSize;
                        // 透明な白で塗りつぶし
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                        ctx.fillRect(px, py, bSize, bSize);
                        // 枠線を描画
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.strokeRect(px, py, bSize, bSize);
                    }
                });
            }

            // Custom Ghosts
            if (this.customGhosts.length > 0) {
                const ghostMap = new Map();
                this.customGhosts.forEach(ghost => {
                    const key = `${ghost.x},${ghost.y}`;
                    ghostMap.set(key, ghost.pieceType);
                });
                ghostMap.forEach((pieceType, key) => {
                    const [x, y] = key.split(',').map(Number);
                    if (occupiedCells.has(key) || (y >= 0 && y < BOARD_HEIGHT && this.board[y][x])) {
                        return;
                    }
                    const screenY = y - this.viewY;
                    if (screenY >= 0 && screenY < BOARD_VISIBLE_HEIGHT) {
                        this.drawBlock(pieceType, x * bSize, screenY * bSize, 0.2, bSize);
                    }
                });
            }

            // Drawn Blocks
            if (this.drawnBlocks.size > 0) {
                ctx.fillStyle = '#FFFFFF';
                ctx.globalAlpha = 0.8;
                for (const key of this.drawnBlocks.keys()) {
                    const [x, y] = key.split(',').map(Number);
                    const screenY = y - this.viewY;
                    if (screenY >= 0 && screenY < BOARD_VISIBLE_HEIGHT) {
                        ctx.fillRect(x * bSize, screenY * bSize, bSize, bSize);
                    }
                }
                ctx.globalAlpha = 1.0;
            }
        } // ★ここ！この「}」が抜けていたため、メソッドが閉じられていませんでした
        
        this.drawSpecialMoveText(bSize);
        if (this.gameOver) this.drawMessage("GAME OVER", bSize);
        else if (this.gameClear) this.drawMessage("CLEAR!", bSize);
        ctx.restore();
    }

    
    getShape(p, r) { if(!p) return []; const o=TETROMINOS[p].shape; if(r===0||p==='O')return o; const c=TETROMINOS[p].center;return o.map(b=>{let [x,y]=[b[0]-c[0],b[1]-c[1]]; for(let i=0;i<r;i++){[x,y]=[-y,x];} return [x+c[0]+(p==='O'?0.5:0),y+c[1]+(p==='O'?0.5:0)];});}
    checkCollision(x,y,s) { for(const b of s) { const bx=Math.floor(x+b[0]), by=Math.floor(y+b[1]); if(bx<0||bx>=BOARD_WIDTH||by>=BOARD_HEIGHT||(by>=0&&this.board[by]?.[bx])) return true; } return false; }
    rotate(d) { if(this.gameOver||!this.player.pieceType||this.player.pieceType==='O')return; const oR=this.player.rotation, nR=(oR+d+4)%4; const oD=(this.player.pieceType==='I'?SRS_OFFSETS.I:SRS_OFFSETS.JLSTZ)[`${oR}_${nR}`]; const nS=this.getShape(this.player.pieceType,nR); for(let i=0;i<oD.length;i++){const t=oD[i];const oX=t[0],oY=-t[1]; if(!this.checkCollision(this.player.x+oX,this.player.y+oY,nS)){this.player.x+=oX;this.player.y+=oY;this.player.rotation=nR;this.lockTimer=0;this.lastMoveWasRotation=true;this.lastSrsKickIndex=i;return;}}}
    move(dx,dy,isPlayer=true) { if(this.gameOver||!this.player.pieceType)return; const s=this.getShape(this.player.pieceType,this.player.rotation); if(!this.checkCollision(this.player.x+dx,this.player.y+dy,s)){this.player.x+=dx;this.player.y+=dy;if(isPlayer){this.lockTimer=0;this.lastMoveWasRotation=false;}}}
    getGhostY() {if(!this.player.pieceType) return this.player.y; const s=this.getShape(this.player.pieceType,this.player.rotation); let y=this.player.y; while(!this.checkCollision(this.player.x,y+1,s))y++; return y;}
    
    hardDrop() {
        if (this.gameOver) return;
        const originalY = this.player.y;
        this.player.y = this.getGhostY();
        if (this.player.y > originalY) {
            this.lastMoveWasRotation = false;
        }
        this.lockPiece();
    }
    
hold() {
        if (this.gameOver || !this.canHold || this.holdDisabled) return;

        if (!this.holdPiece && this.nextQueue[0] === 'E') {
            return;
        }

        this.canHold = false;
        this.lastMoveWasRotation = false;
        if (this.holdPiece) {
            [this.player.pieceType, this.holdPiece] = [this.holdPiece, this.player.pieceType];
            this.player.rotation = 0;
            this.lockTimer = 0;
            
            this.player.x = Math.floor(BOARD_WIDTH / 2) - Math.floor(TETROMINOS[this.player.pieceType].center[0]) -1;
            const shape = this.getShape(this.player.pieceType, this.player.rotation);
            this.player.y = 20;
                        if (this.checkCollision(this.player.x, this.player.y, shape)) {
                this.player.y = 19;
if (this.checkCollision(this.player.x, this.player.y, shape)) {
                     this.gameOver = true;
}
            }
            this.requestAiHint(); // ホールド後もヒントを再計算
        } else {
            this.holdPiece = this.player.pieceType;
this.spawnNewPiece();
        }
    }

lockPiece() {
        if (!this.player.pieceType) return;
        
        let tspinResult = this.checkForTSpin();

        const shape = this.getShape(this.player.pieceType, this.player.rotation);
        this.specialMoveText = [];
        let moveText = '';

        for (const b of shape) { const bx = Math.floor(this.player.x + b[0]), by = Math.floor(this.player.y + b[1]);
if (by >= 0) this.board[by][bx] = this.player.pieceType; }
        
        if (gameState === 'PLAYING') {
            logCurrentGameState(this);
}

        this.linesClearedLastLock = this.clearLines();
if (gameState === 'PLAYING') {
            if (this.linesClearedLastLock > 0) {
                logCurrentGameState(this);
}
}

const lines = this.linesClearedLastLock;
const isPC = lines > 0 && this.board.every(row => row.every(cell => cell === null));
        
        let attack = 0;
        let isAction = false;
        let moveInfo = { name: '', isPC: false, clearedLines: lines, isB2B: false, ren: this.ren, TSpinType: tspinResult };
if (isPC) {
            attack = 10;
            isAction = true;
this.stats.perfectClear++;
            if (lines === 4) {
                this.stats.tetris++;
}
            moveInfo.isPC = true;
            this.ren++;
            this.isB2B = true;
this.specialMoveText.push("PERFECT CLEAR");
        } else if (lines > 0) {
            isAction = true; this.ren++;
            
            if (tspinResult === 'TSPIN') {
                attack = [0, 2, 4, 6][lines];
                moveText = ['', 'T-Spin Single', 'T-Spin Double', 'T-Spin Triple'][lines];
                moveInfo.name = moveText;
                if (lines === 1) this.stats.tSpinSingle++;
                if (lines === 2) this.stats.tSpinDouble++;
                if (lines === 3) this.stats.tSpinTriple++;
            } else if (tspinResult === 'MINI_TSPIN') {
                attack = [0, 0, 1, 2, 4][lines];
                moveText = ['', 'T-Spin Mini Single', 'T-Spin Mini Double'][lines] || 'T-Spin Mini';
                moveInfo.name = moveText;
                if (lines === 1) this.stats.miniTSpinSingle++;
                if (lines === 2) this.stats.miniTSpinDouble++;
            } else {
                attack = [0, 0, 1, 2, 4][lines];
                moveText = ['', 'Single', 'Double', 'Triple', 'Tetris'][lines];
                moveInfo.name = moveText;
                if (lines === 4) this.stats.tetris++;
            }
            
            const isB2BEligible = (lines === 4) || (tspinResult && lines > 0);
            if (isB2BEligible) {
                if (this.isB2B) {
                    attack++;
                    this.specialMoveText.push("Back-to-Back");
                    moveInfo.isB2B = true;
                }
                this.isB2B = true;
            } else {
                this.isB2B = false;
            }
            const renBonus = [0,0,1,1,2,2,3,3,4,4,4,4,4,5][Math.min(this.ren, 13)];
            if(renBonus > 0) {
                attack += renBonus;
            }
            if (this.ren >= 1) {
                 this.specialMoveText.push(`${this.ren} REN`);
            }
            this.stats.ren = this.ren;
        } else if (tspinResult) {
            isAction = false; 
            this.ren = -1;
            this.isB2B = false; 
            moveText = (tspinResult === 'MINI_TSPIN') ? 'T-Spin Mini' : 'T-Spin';
        }
        
        if (!isAction) {
            this.ren = -1;
            this.stats.ren = -1;
        }
        if (moveText) this.specialMoveText.push(moveText);

        if (gameStartTime > 0) {
            analysisData.push({
                time: performance.now() - gameStartTime,
                type: 'action',
                playerId: this.id,
                attack: attack,
                lines: lines
            });
        }

        if (this.opponent && attack > 0) {
            let remainingAttack = attack;
            // 相殺量の計算と記録
            let offsetEvent = 0;
            if (this.pendingGarbage > 0) { const offset = Math.min(this.pendingGarbage, remainingAttack);
                offsetEvent += offset;
this.pendingGarbage -= offset; remainingAttack -= offset;
            }
                if (remainingAttack > 0) { for (let i=0; i < this.garbageQueue.length && remainingAttack > 0; i++) { const offset = Math.min(this.garbageQueue[i].lines, remainingAttack);
                offsetEvent += offset;
                this.garbageQueue[i].lines -= offset; remainingAttack -= offset; } this.garbageQueue = this.garbageQueue.filter(g => g.lines > 0);
            }
            // 理論検証用データの記録（相殺が発生した瞬間）
            if (offsetEvent > 0 && gameStartTime > 0) {
                analysisData.push({
                    time: performance.now() - gameStartTime,
                    type: 'offset',
                    amount: offsetEvent // ライン数 (理論上のリソース減少量は amount * 20)
                });
            }

                if (remainingAttack > 0) { this.opponent.addGarbage(remainingAttack);
            }
}
        
        if (this.activeRuleHooks.onPieceLock) {
            const playerStateProxy = { id: this.id, stats: this.stats };
this.ruleWorker.postMessage({
                command: 'pieceLock',
                data: {
                    playerStateProxy: {
                        id: this.id,
                    
    stats: this.stats,
                        board: this.board,
                        holdPiece: this.holdPiece,
                        currentPiece: this.player.pieceType,
                        nextQueue: this.nextQueue,
                    
    fullMinoSequence: this.fullMinoSequence
                    },
                    moveInfo: moveInfo,
                    is2P: gameMode === '2P'
         }
            });
            return;
}
        
        this.finishLockPiece();
    }
    
        finishLockPiece() {
        this.pieceCount++;
        if (this.gameOver || this.gameClear) return;
        if (this.specialMoveText.length > 0) {
            this.specialMoveTextTimer = 1500;
}

        if (this.nextQueue[0] === 'E') {    
            if (this.holdPiece) {
                this.player.pieceType = this.holdPiece;
this.holdPiece = null;
                this.canHold = false;
                
                this.player.rotation = 0;
                this.lockTimer = 0;
                this.lastMoveWasRotation = false;
this.player.x = Math.floor(BOARD_WIDTH / 2) - Math.floor(TETROMINOS[this.player.pieceType].center[0]) -1;
                const shape = this.getShape(this.player.pieceType, this.player.rotation);
                this.player.y = 20;
if (this.checkCollision(this.player.x, this.player.y, shape)) {
                    this.player.y = 19;
if (this.checkCollision(this.player.x, this.player.y, shape)) {
                         this.gameOver = true;
}
                }
                return;
} else {
                this.gameOver = true;
return;
            }
        }

        this.lockTimer = 0;
if (this.linesClearedLastLock > 0) { this.isClearingLine = true; this.lineClearDelayTimer = gameSettings.lineClearDelay;
} 
        else { this.riseGarbage(); this.spawnNewPiece();
}
    }
    
    checkForTSpin() {
        if (this.player.pieceType !== 'T' || !this.lastMoveWasRotation) return null;
        const centerX = this.player.x + TETROMINOS['T'].center[0];
        const centerY = this.player.y + TETROMINOS['T'].center[1];
        const corners = [[-1, -1], [1, -1], [-1, 1], [1, 1]];
        let occupiedCorners = 0;
        corners.forEach(([cx, cy]) => {
            const boardX = Math.round(centerX + cx);
            const boardY = Math.round(centerY + cy);
            if (boardX < 0 || boardX >= BOARD_WIDTH || boardY < 0 || boardY >= BOARD_HEIGHT || this.board[boardY]?.[boardX]) occupiedCorners++;
        });
        if (occupiedCorners < 3) return null;
        const frontCornerDefs = { 0: [[-1, -1], [1, -1]], 1: [[1, -1], [1, 1]], 2: [[-1, 1], [1, 1]], 3: [[-1, -1], [-1, 1]] };
        const frontCorners = frontCornerDefs[this.player.rotation];
        let occupiedFrontCorners = 0;
        frontCorners.forEach(([cx, cy]) => {
            const boardX = Math.round(centerX + cx);
            const boardY = Math.round(centerY + cy);
            if (boardX < 0 || boardX >= BOARD_WIDTH || boardY < 0 || boardY >= BOARD_HEIGHT || this.board[boardY]?.[boardX]) occupiedFrontCorners++;
        });
                if (occupiedFrontCorners === 2 || this.lastSrsKickIndex === 4) return 'TSPIN';
        return 'MINI_TSPIN';
    }

    clearLines() {
        const clearedLinesY = [];
        for (let y = 0; y < this.board.length; y++) {
            if (this.board[y].every(c => c !== null)) {
                clearedLinesY.push(y);
            }
        }

        if (clearedLinesY.length === 0) {
            return 0;
        }

        this.customGhosts = this.customGhosts.filter(ghost => !clearedLinesY.includes(ghost.y));

        this.customGhosts.forEach(ghost => {
            const linesClearedBelow = clearedLinesY.filter(clearedY => clearedY > ghost.y).length;
            if (linesClearedBelow > 0) {
                ghost.y += linesClearedBelow;
            }
        });

        const newBoard = this.board.filter((row, y) => !clearedLinesY.includes(y));
        const clearedCount = clearedLinesY.length;

        for (let i = 0; i < clearedCount; i++) {
            newBoard.unshift(Array(BOARD_WIDTH).fill(null));
        }
        this.board = newBoard;

        return clearedCount;
    }
    addGarbage(lines) { if (this.opponent) { this.garbageQueue.push({ lines, receivedTime: performance.now() });} }
    processGarbageQueue() { const now = performance.now(); for (let i = this.garbageQueue.length - 1; i >= 0; i--) { if (now - this.garbageQueue[i].receivedTime > gameSettings.garbageGrace) { this.pendingGarbage += this.garbageQueue[i].lines; this.garbageQueue.splice(i, 1); } } }
    
    riseGarbage() {
        if (this.pendingGarbage <= 0) return;
        
        if (this.lastGarbageHoleX === -1) {
            this.lastGarbageHoleX = Math.floor(Math.random() * BOARD_WIDTH);
        }
        
        for (let i = 0; i < this.pendingGarbage; i++) {
            if (this.board[0].some(cell => cell !== null)) {
                this.gameOver = true;
                return;
            }
            if (Math.random() < gameSettings.garbageRandomness) {
                this.lastGarbageHoleX = Math.floor(Math.random() * BOARD_WIDTH);
            }
            
            this.board.shift();
            const newRow = Array(BOARD_WIDTH).fill('G');
            newRow[this.lastGarbageHoleX] = null;
            this.board.push(newRow);
        }
        this.pendingGarbage = 0;

}

    drawBlock(p, x, y, alpha = 1.0, bSize = BLOCK_SIZE) {
        if (y < -bSize) return;
        const skinImage = activeSkin[p];
        ctx.globalAlpha = alpha;
        if (skinImage && skinImage.src) {
            ctx.drawImage(skinImage, x, y, bSize, bSize);
        } else {
            ctx.fillStyle = activeSkinColors[p] || '#FFF';
            ctx.fillRect(x, y, bSize, bSize);
        }
        ctx.strokeStyle = '#444';
        ctx.lineWidth = 0.5;
        ctx.strokeRect(x, y, bSize, bSize);
        ctx.globalAlpha = 1.0;
    }

    drawPiece(s, x, y, p, alpha, bSize) {
        s.forEach(b => {
            const px = Math.floor(x + b[0]) * bSize;
            const py = (Math.floor(y + b[1]) - this.viewY) * bSize;
            this.drawBlock(p, px, py, alpha, bSize);
        });
    }

    drawUI(layout, bSize, useCustomBG) {
        ctx.textAlign = 'center';
        ctx.fillStyle = '#FFF'; 
        ctx.font = `bold ${bSize * 0.8}px "Orbitron"`;

        // HOLD
        if (!this.holdDisabled) {
            if (!useCustomBG) ctx.fillText('HOLD', layout.hold.x, layout.hold.y - bSize);
            if (this.holdPiece) {
                const s = this.getShape(this.holdPiece, 0);
                s.forEach(b => {
                    // 中心合わせ
                    const cx = layout.hold.x;
                    const cy = layout.hold.y;
                    const px = cx - (TETROMINOS[this.holdPiece].center[0] * bSize) + (b[0] * bSize);
                    const py = cy - (TETROMINOS[this.holdPiece].center[1] * bSize) + (b[1] * bSize);
                    this.drawBlock(this.holdPiece, px, py, 1.0, bSize);
                });
            }
        }

        // Garbage Meter (盤面の左横)
        // カスタム背景時は描画しない、または位置調整が必要だが、ここでは標準位置(盤面左)依存とする
        if (!useCustomBG) {
            const meterX = layout.board.x - 12;
            const meterWidth = 8; 
            const meterMaxHeight = BOARD_VISIBLE_HEIGHT * bSize;
            const pendingHeight = Math.min(this.pendingGarbage, BOARD_VISIBLE_HEIGHT) * bSize;
            
            if (pendingHeight > 0) { 
                ctx.fillStyle = 'red'; 
                ctx.fillRect(meterX, layout.board.y + meterMaxHeight - pendingHeight, meterWidth, pendingHeight);
            }
            const queuedLines = this.garbageQueue.reduce((sum, g) => sum + g.lines, 0);
            const queuedHeight = Math.min(queuedLines, BOARD_VISIBLE_HEIGHT - this.pendingGarbage) * bSize;
            if (queuedHeight > 0) { 
                ctx.fillStyle = 'yellow';
                ctx.fillRect(meterX, layout.board.y + meterMaxHeight - pendingHeight - queuedHeight, meterWidth, queuedHeight);
            }
        }

        // Custom UI Text
        if (this.customUIText !== null) {
            ctx.font = `bold ${bSize * 1.6}px "Orbitron"`;
            ctx.fillStyle = '#FFFFFF';
            ctx.fillText(this.customUIText, layout.board.x + (BOARD_WIDTH * bSize)/2, layout.board.y + 150);
        }

        // Timer
        if (gameSettings.showTimer && !useCustomBG) {
            ctx.fillStyle = '#FFFFFF';
            ctx.font = `bold ${bSize * 0.8}px "Orbitron"`;
            const charSpacing = bSize * 0.6;
            const totalWidth = this.elapsedTimeText.length * charSpacing;

            let startX = Math.max(5, layout.hold.x - (totalWidth / 2) + 30);
            const timerY = layout.hold.y + 490;

            for (let i = 0; i < this.elapsedTimeText.length - 1; i++) {
                const char = this.elapsedTimeText[i];
                                const charX = startX + (i * charSpacing);
                ctx.fillText(char, charX, timerY);
            }
        }

        // NEXT
        ctx.fillStyle = '#FFF';
        ctx.font = `bold ${bSize * 0.8}px "Orbitron"`;
        if (!useCustomBG) ctx.fillText('NEXT', layout.next[0].x, layout.next[0].y - bSize);
        
        for (let i = 0; i < Math.min(gameSettings.maxNext, layout.next.length); i++) {
            const pT = this.nextQueue[i];
            if (!pT) continue;
            if (pT === 'E') break;
            const s = this.getShape(pT, 0);
            const pos = layout.next[i];
            s.forEach(b => {
                const px = pos.x - (TETROMINOS[pT].center[0] * bSize) + (b[0] * bSize);
                const py = pos.y - (TETROMINOS[pT].center[1] * bSize) + (b[1] * bSize);
                this.drawBlock(pT, px, py, 1.0, bSize);
            });
        }
    }
    
        drawSpecialMoveText(bSize) {
        if (this.specialMoveTextTimer <= 0 || this.specialMoveText.length === 0 || !gameSettings.showEffects) return;
        
        // 盤面中央（ctx.translateで盤面左上が(0,0)になっているため、相対座標を使用）
        const centerX = (BOARD_WIDTH * bSize) / 2;
        const startY = (BOARD_VISIBLE_HEIGHT * bSize) / 2 - (this.specialMoveText.length * 18);
        
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        for (let i = 0; i < this.specialMoveText.length; i++) {
            const text = this.specialMoveText[i];
            const y = startY + (i * 35);
            
            ctx.font = `bold ${bSize}px "Orbitron"`;
            ctx.fillStyle = '#FFFFFF';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 4;

            ctx.strokeText(text, centerX, y);
            ctx.fillText(text, centerX, y);
        }
        ctx.textBaseline = 'alphabetic';
    }

        drawMessage(t, bSize) { 
        // 盤面中央（ctx.translateで盤面左上が(0,0)になっているため、相対座標を使用）
        const cX = (BOARD_WIDTH * bSize) / 2;
        const cY = (BOARD_VISIBLE_HEIGHT * bSize) / 2;
        
        ctx.fillStyle = 'rgba(0,0,0,0.75)';
        ctx.fillRect(0, 0, BOARD_WIDTH * bSize, BOARD_VISIBLE_HEIGHT * bSize); 
        ctx.fillStyle = '#FFF'; 
        ctx.textAlign = 'center'; 
        ctx.textBaseline = 'middle';
        ctx.font = `bold ${bSize * 1.5}px "Orbitron"`;
        ctx.fillText(t, cX, cY); 
        ctx.textBaseline = 'alphabetic';
    }

requestAiMove() {
        this.isAiThinking = true; 
        const debugPayload = {
            playerId: this.id,
            board: this.board,
            minoSequence: [this.player.pieceType, ...this.nextQueue],
            holdPiece: this.holdPiece,
            canHold: this.canHold,
            isB2B: this.isB2B,
            ren: this.ren
        };
        updateAiDebugDisplay(debugPayload);

        let boardString = '[\n';
        for (let y = 0; y < this.board.length; y++) {
            const row = this.board[y];
            const rowString = row.map(cell => cell === null ? 'null' : `"${cell}"`).join(', ');
            boardString += `  [${rowString}]`;
            if (y < this.board.length - 1) {
                boardString += ',\n';
            }
        }
        boardString += '\n]';
        let aiWorkerStartPayload;
        if (this.aiType === 'default') {
            let nextPiecesForWorker;
            if (this.holdPiece) {
                nextPiecesForWorker = [this.holdPiece, this.player.pieceType, ...this.nextQueue];
            } else {
                nextPiecesForWorker = [this.player.pieceType, ...this.nextQueue];
            }
            const nextString = nextPiecesForWorker.join('');
            aiWorkerStartPayload = {
                type: 'start',
                boardString: boardString,
                nextString: nextString,
                isB2B: this.isB2B,
                ren: this.ren + 1,
            };
        } else {
            let nextString;
            let holdPieceToSend = this.holdPiece;

            if (!holdPieceToSend) {
                holdPieceToSend = this.player.pieceType;
                nextString = this.nextQueue.join('');
            } else {
                const nextPiecesForWorker = [this.player.pieceType, ...this.nextQueue];
                nextString = nextPiecesForWorker.join('');
            }

                        aiWorkerStartPayload = {
                type: 'start',
                boardString: boardString,
                nextString: nextString,
                holdPiece: holdPieceToSend,
                canHold: this.canHold,
                isB2B: this.isB2B,
                ren: this.ren + 1,
                activeTemplates: gameSettings.aiTemplates
            };
        }
        if (this.aiWorker) {
            this.aiWorker.postMessage(aiWorkerStartPayload);
            this.aiWorker.postMessage({ type: 'stop' });
        }
    }


    getMinoShape_forAI(type, rotation) {
        rotation = rotation % 4;
        switch (type) {
            case 'I':
                if (rotation == 0) return [[0,0], [-1,0], [1,0], [2,0]];
                if (rotation == 1) return [[1,0], [1,-1], [1,1], [1,2]];
                if (rotation == 2) return [[0,1], [-1,1], [1,1], [2,1]];
                if (rotation == 3) return [[0,0], [0,-1], [0,1], [0,2]];
                break;
            case 'O':
                return [[0,0], [1,0], [0,-1], [1,-1]];
            case 'T':
                if (rotation == 0) return [[0,0], [-1,0], [1,0], [0,-1]];
                if (rotation == 1) return [[0,0], [0,-1], [1,0], [0,1]];
                if (rotation == 2) return [[0,0], [1,0], [-1,0], [0,1]];
                if (rotation == 3) return [[0,0], [0,1], [-1,0], [0,-1]];
                break;
            case 'S':
                if (rotation == 0) return [[0,0], [-1,0], [0,-1], [1,-1]];
                if (rotation == 1) return [[0,0], [0,-1], [1,0], [1,1]];
                if (rotation == 2) return [[0,0], [1,0], [0,1], [-1,1]];
                if (rotation == 3) return [[0,0], [0,1], [-1,0], [-1,-1]];
                break;
            case 'Z':
                if (rotation == 0) return [[0,0], [1,0], [0,-1], [-1,-1]];
                if (rotation == 1) return [[0,0], [0,1], [1,0], [1,-1]];
                if (rotation == 2) return [[0,0], [-1,0], [0,1], [1,1]];
                if (rotation == 3) return [[0,0], [0,-1], [-1,0], [-1,1]];
                break;
            case 'J':
                if (rotation == 0) return [[0,0], [-1,0], [1,0], [-1,-1]];
                if (rotation == 1) return [[0,0], [0,-1], [0,1], [1,-1]];
                if (rotation == 2) return [[0,0], [1,0], [-1,0], [1,1]];
                if (rotation == 3) return [[0,0], [0,1], [0,-1], [-1,1]];
                break;
            case 'L':
                if (rotation == 0) return [[0,0], [1,0], [-1,0], [1,-1]];
                if (rotation == 1) return [[0,0], [0,1], [0,-1], [1,1]];
                if (rotation == 2) return [[0,0], [-1,0], [1,0], [-1,1]];
                if (rotation == 3) return [[0,0], [0,-1], [0,1], [-1,-1]];
                break;
        }
        return [[0,0]];
    }

    srsOffsets_forAI = {
        common: {
            '0->1': [[0,0], [-1,0], [-1,1], [0,-2], [-1,-2]],
            '1->0': [[0,0], [1,0], [1,-1], [0,2], [1,2]],
            '1->2': [[0,0], [1,0], [1,-1], [0,2], [1,2]],
            '2->1': [[0,0], [-1,0], [-1,1], [0,-2], [-1,-2]],
            '2->3': [[0,0], [1,0], [1,1], [0,-2], [1,-2]],
            '3->2': [[0,0], [-1,0], [-1,-1], [0,2], [-1,2]],
            '3->0': [[0,0], [-1,0], [-1,-1], [0,2], [-1,2]],
            '0->3': [[0,0], [1,0], [1,1], [0,-2], [1,-2]],
        },
        I: {
            '0->1': [[0,0], [-2,0], [1,0], [-2,-1], [1,2]],
            '1->0': [[0,0], [2,0], [-1,0], [2,1], [-1,-2]],
            '1->2': [[0,0], [-1,0], [2,0], [-1,2], [2,-1]],
            '2->1': [[0,0], [1,0], [-2,0], [1,-2], [-2,1]],
            '2->3': [[0,0], [2,0], [-1,0], [2,1], [-1,-2]],
            '3->2': [[0,0], [-2,0], [1,0], [-2,-1], [1,2]],
            '3->0': [[0,0], [1,0], [-2,0], [1,-2], [-2,1]],
            '0->3': [[0,0], [-1,0], [2,0], [-1,2], [2,-1]],
        }
    };

    checkCollision_forAI(type, x, y, r, currentBoard) {
        const shape = this.getMinoShape_forAI(type, r);
        for (const [dx, dy] of shape) {
            const nx = x + dx;
            const ny = y + dy;
            if (nx < 0 || nx >= BOARD_WIDTH || ny < 0 || ny >= BOARD_HEIGHT || (ny >= 0 && currentBoard[ny][nx])) {
                return true;
            }
        }
        return false;
    }

    tryRotate_forAI(type, x, y, r, direction, currentBoard) {
        const newR = (r + direction + 4) % 4;
        const offsetTable = (type === 'I' ? this.srsOffsets_forAI.I : this.srsOffsets_forAI.common);
        const offsetData = offsetTable[`${r}->${newR}`];

        for (const [ox, oy] of offsetData) {
            const newX = x + ox;
            const newY = y - oy;
            if (!this.checkCollision_forAI(type, newX, newY, newR, currentBoard)) {
                return { x: newX, y: newY, r: newR };
            }
        }
        return null;
    }

    checkTSpinCondition_forAI(target, minoType, currentBoard) {
        if (minoType !== 'T') {
            return false;
        }
        const { x, y } = target;
        const offsets = [[-1, -1], [1, -1], [-1, 1], [1, 1]];
        let filledCorners = 0;
        for (const [dx, dy] of offsets) {
            const nx = x + dx;
            const ny = y + dy;
            if (nx < 0 || nx >= BOARD_WIDTH || ny < 0 || ny >= BOARD_HEIGHT || (ny >= 0 && currentBoard[ny][nx])) {
                filledCorners++;
            }
        }
        return filledCorners >= 3;
    }

    findShortestPath_forAI(start, target, minoType, currentBoard) {
        const queue = [[start.x, start.y, start.r, []]];
        const visited = new Set();
        visited.add(`${start.x},${start.y},${start.r}`);

        let shortestPath = null;
        let preferredPath = null;

        const isTSpinPriority = this.checkTSpinCondition_forAI(target, minoType, currentBoard);

        while (queue.length > 0) {
            const [x, y, r, path] = queue.shift();

            if (preferredPath && path.length >= preferredPath.length) {
                continue;
            }
            if (!isTSpinPriority && shortestPath && path.length >= shortestPath.length) {
                continue;
            }

            if (x === target.x && r === target.r) {
                let finalY = y;
                while (!this.checkCollision_forAI(minoType, x, finalY + 1, r, currentBoard)) {
                    finalY++;
                }
                if (finalY === target.y) {
                    const finalPath = [...path, '↑'];
                    if (!shortestPath) {
                        shortestPath = finalPath;
                    }

                    if (isTSpinPriority && !preferredPath) {
                        const isGrounded = this.checkCollision_forAI(minoType, x, y + 1, r, currentBoard);
                        if (path.length > 0) {
                            const lastMove = path[path.length - 1];
                            if ((lastMove === 'R' || lastMove === 'L') && isGrounded) {
                                const tempBoard = currentBoard.map(row => [...row]);
                                const shape = this.getMinoShape_forAI(minoType, r);
                                for (const [dx, dy] of shape) {
                                    const nx = x + dx;
                                    const ny = finalY + dy;
                                    if (ny >= 0 && ny < BOARD_HEIGHT && nx >= 0 && nx < BOARD_WIDTH) {
                                        tempBoard[ny][nx] = 1;
                                    }
                                }
                                let linesCleared = 0;
                                const checkedRows = new Set();
                                for (const [, dy] of shape) {
                                    const ny = finalY + dy;
                                    if (ny >= 0 && ny < BOARD_HEIGHT && !checkedRows.has(ny)) {
                                        checkedRows.add(ny);
                                        if (tempBoard[ny].every(cell => cell === 1)) {
                                            linesCleared++;
                                        }
                                    }
                                }
                                if (linesCleared > 0) {
                                    preferredPath = finalPath;
                                }
                            }
                        }
                    }
                    continue;
                }
            }


            const actions = ['R', 'L', '←', '→', '↓'];
            for (const action of actions) {
                let nextState = null;
                let newPath = [...path, action];

                switch (action) {
                    case '←':
                        nextState = { x: x - 1, y: y, r: r };
                        break;
                    case '→':
                        nextState = { x: x + 1, y: y, r: r };
                        break;
                    case '↓':
                        nextState = { x: x, y: y + 1, r: r };
                        break;
                    case 'R':
                        nextState = this.tryRotate_forAI(minoType, x, y, r, 1, currentBoard);
                        break;
                    case 'L':
                        nextState = this.tryRotate_forAI(minoType, x, y, r, -1, currentBoard);
                        break;
                }

                if (nextState) {
                    const stateKey = `${nextState.x},${nextState.y},${nextState.r}`;
                    if (!visited.has(stateKey) && !this.checkCollision_forAI(minoType, nextState.x, nextState.y, nextState.r, currentBoard)) {
                        visited.add(stateKey);
                        queue.push([nextState.x, nextState.y, nextState.r, newPath]);
                    }
                }
            }
        }

        const foundPath = preferredPath || shortestPath;
        if (foundPath) {
            return foundPath;
        }
        
        let alternativeTarget = null;
        if (minoType === 'I' || minoType === 'S' || minoType === 'Z') {
            const { x: tx, y: ty, r: tr } = target;
            if (minoType === 'I') {
                if (tr === 0) alternativeTarget = { x: tx, y: ty - 1, r: 2 };
                else if (tr === 2) alternativeTarget = { x: tx, y: ty + 1, r: 0 };
                else if (tr === 1) alternativeTarget = { x: tx + 1, y: ty, r: 3 };
                else if (tr === 3) alternativeTarget = { x: tx - 1, y: ty, r: 1 };
            } else if (minoType === 'S') {
                if (tr === 0) alternativeTarget = { x: tx, y: ty - 1, r: 2 };
                else if (tr === 2) alternativeTarget = { x: tx, y: ty + 1, r: 0 };

                else if (tr === 1) alternativeTarget = { x: tx + 1, y: ty, r: 3 };

                else if (tr === 3) alternativeTarget = { x: tx - 1, y: ty, r: 1 };

            } else if (minoType === 'Z') {
                if (tr === 0) alternativeTarget = { x: tx, y: ty - 1, r: 2 };

                else if (tr === 2) alternativeTarget = { x: tx, y: ty + 1, r: 0 };

                else if (tr === 1) alternativeTarget = { x: tx + 1, y: ty, r: 3 };

                else if (tr === 3) alternativeTarget = { x: tx - 1, y: ty, r: 1 };
 
            }
        }

        if (alternativeTarget) {
            const queue2 = [[start.x, start.y, start.r, []]];
            const visited2 = new Set([`${start.x},${start.y},${start.r}`]);
            while (queue2.length > 0) {
                 const [x, y, r, path] = queue2.shift();

                 if (x === alternativeTarget.x && r === alternativeTarget.r) {
                     let finalY = y;

                     while (!this.checkCollision_forAI(minoType, x, finalY + 1, r, currentBoard)) {
                         finalY++;

                     }
                     if (finalY === alternativeTarget.y) {
                         return [...path, '↑'];

                     }
                 }
                 const actions = ['R', 'L', '←', '→', '↓'];

                 for (const action of actions) {
                     let nextState = null;

                     let newPath = [...path, action];
                     switch (action) {
                         case '←': nextState = { x: x - 1, y: y, r: r };

                         break;
                         case '→': nextState = { x: x + 1, y: y, r: r }; break;

                         case '↓': nextState = { x: x, y: y + 1, r: r }; break;

                         case 'R': nextState = this.tryRotate_forAI(minoType, x, y, r, 1, currentBoard); break;

                         case 'L': nextState = this.tryRotate_forAI(minoType, x, y, r, -1, currentBoard); break;

                     }
                     if (nextState) {
                         const stateKey = `${nextState.x},${nextState.y},${nextState.r}`;

                         if (!visited2.has(stateKey) && !this.checkCollision_forAI(minoType, nextState.x, nextState.y, nextState.r, currentBoard)) {
                             visited2.add(stateKey);

                             queue2.push([nextState.x, nextState.y, nextState.r, newPath]);
                         }
                     }
                 }
            }
        }

        return null;

    }
async executeAiMove(move) {


        
        if (this.gameOver || !move) {
            this.isAiThinking = false;
            return;
        }

        if (this.player.pieceType !== move.piece) {
            if (this.canHold) {
                this.hold();
                await new Promise(resolve => setTimeout(resolve, gameSettings.aiMoveDelay));
            } else {
                this.isAiThinking = false;
                return;
            }
        }

        const startState = { x: this.player.x, y: this.player.y, r: this.player.rotation };
const targetState = { x: move.x, y: move.y, r: move.rotation };
        const minoType = this.player.pieceType;
if (minoType === 'I') {
            targetState.x += 1;
startState.x += 1;
        }
        
                const debugDisplay = document.getElementById('ai-tree-debug-display');
if (debugDisplay && gameSettings.debugEnabled) {
            debugDisplay.style.display = 'block';
debugDisplay.innerHTML += `<br><span style="color:#ff88ff">AI Path: ${minoType} ${startState.x},${startState.y},${startState.r} -> ${targetState.x},${targetState.y},${targetState.r}</span>`;
        }

        const pathfinderBoard = this.board.map(row => row.map(cell => (cell === null ? 0 : 1)));
const path = this.findShortestPath_forAI(startState, targetState, minoType, pathfinderBoard);

        if (path) {
            for (const action of path) {
                                switch (action) {
                    case '←': this.player.x--;
break;
                    case '→': this.player.x++; break;
                    case '↓': this.player.y++; break;
                    case 'R': {
                        const offset = minoType === 'I' ? 1 : 0;
                        const newState = this.tryRotate_forAI(minoType, this.player.x + offset, this.player.y, this.player.rotation, 1, pathfinderBoard);
if (newState) {
                            this.player.x = newState.x - offset;
this.player.y = newState.y;
                            this.player.rotation = newState.r;
                        }
                        break;
}
                    case 'L': {
                        const offset = minoType === 'I' ? 1 : 0;
                        const newState = this.tryRotate_forAI(minoType, this.player.x + offset, this.player.y, this.player.rotation, -1, pathfinderBoard);
if (newState) {
                            this.player.x = newState.x - offset;
this.player.y = newState.y;
                            this.player.rotation = newState.r;
                        }
                        break;
}
                    case '↑':
                        this.player.y = this.getGhostY();
                        break;
                }
                let delay = gameSettings.aiMoveDelay;
                if (action === '↓') {
                    delay = gameSettings.aiSdfDelay;
                }
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }

        if (path && path.length > 0) {
            const lastMeaningfulAction = path.at(-1) === '↑' && path.length > 1 ? path.at(-2) : path.at(-1);
            this.lastMoveWasRotation = lastMeaningfulAction === 'R' || lastMeaningfulAction === 'L';
        } else {
            this.lastMoveWasRotation = false;
}

        this.player.rotation = move.rotation;
        this.player.x = move.x;
        this.player.y = move.y;
        
        this.lockPiece();
this.isAiThinking = false;
    }

    win() {
        this.gameClear = true;
        if (this.opponent) {
            this.opponent.gameOver = true;
        }
    }

    lose() {
        this.gameOver = true;
        if (this.opponent) {
            this.opponent.gameClear = true;
        }
    }

    setCustomUIText(text) {
        this.customUIText = String(text);
    }
    
    placeBlock(x, y, type) {
        if (x >= 0 && x < BOARD_WIDTH && y >= 0 && y < BOARD_HEIGHT) {
            this.board[y][x] = type;
        }
    }

    displayGhostBlock(x, y, type) {
        if (x >= 0 && x < BOARD_WIDTH && y >= 0 && y < BOARD_HEIGHT) {
            const pieceType = Object.keys(COLORS).includes(type) ? type : null;
            this.customGhosts.push({x, y, pieceType});
        }
    }

    clearAllGhostBlocks() {
        this.customGhosts = [];
    }
    
    setPiece(type, piece, index = 0) {
        const isValidPiece = Object.keys(TETROMINOS).includes(piece) ||
            piece === null || piece === 'E';
        if (!isValidPiece) return;

        if (type === 'hold') {
            this.holdPiece = piece;
} else if (type === 'next') {
            if (index === 0) {
                this.player.pieceType = piece;
            } else if (index > 0 && index - 1 < this.nextQueue.length) {
                this.nextQueue[index - 1] = piece;
            }
}
    }

    async executeDrawMove(path) {
        if (this.isExecutingSequence) return;
this.isExecutingSequence = true;

        for (const action of path) {
            if (this.gameOver || this.gameClear) break;
                        switch (action) {
                case '←': this.move(-1, 0); break;
                case '→': this.move(1, 0); break;
                case '↓': this.move(0, 1); break;
                case 'R': this.rotate(1); break;
                case 'L': this.rotate(-1); break;
                case '↑': this.hardDrop(); break;
            }
            await new Promise(resolve => setTimeout(resolve, gameSettings.drawMoveDelay));
        }

        this.isExecutingSequence = false;
}
    
    async processDrawing() {
        if (this.drawnBlocks.size !== 4) {
            this.drawnBlocks.clear();
return;
        }

        const blocks = Array.from(this.drawnBlocks.keys()).map(k => {
            const [x, y] = k.split(',').map(Number);
            return { x, y };
        });
blocks.sort((a, b) => a.y - b.y || a.x - b.x);

        const anchor = blocks[0];
const relativeCoords = blocks.slice(1).map(b => `${b.x - anchor.x},${b.y - anchor.y}`);
        const key = relativeCoords.sort().join(';');

        const shapeInfo = DRAW_SHAPE_MAP[key];
        this.drawnBlocks.clear();
if (!shapeInfo) return;

        const targetPieceType = shapeInfo.type;
        const targetState = {
            x: anchor.x - shapeInfo.offset[0],
            y: anchor.y - shapeInfo.offset[1],
            r: shapeInfo.rot
        };

        let path = null;
        let startState = null;
        let pieceForPathfinding = null;
        let holdIsNeeded = false;

        if (this.player.pieceType === targetPieceType) {
            pieceForPathfinding = this.player.pieceType;
            startState = { x: this.player.x, y: this.player.y, r: this.player.rotation };
            holdIsNeeded = false;
        } else if (this.canHold && (this.holdPiece === targetPieceType || (!this.holdPiece && this.nextQueue[0] === targetPieceType))) {
            pieceForPathfinding = targetPieceType;
            holdIsNeeded = true;
            
            const spawnX = Math.floor(BOARD_WIDTH / 2) - Math.floor(TETROMINOS[pieceForPathfinding].center[0]) - 1;
            const tempShape = this.getShape(pieceForPathfinding, 0);
            let spawnY = 19;
            if (this.checkCollision(spawnX, spawnY, tempShape)) {
                spawnY = 18;
            }
            startState = { x: spawnX, y: spawnY, r: 0 };
        }
        
        if (startState) {
            if (pieceForPathfinding === 'I') {
                startState.x += 1;
targetState.x += 1;
            }

                        const debugDisplay = document.getElementById('ai-tree-debug-display');
if (debugDisplay) {
                debugDisplay.style.display = 'block';
debugDisplay.innerHTML = `<span style="color:#88ffff">Draw Path: ${pieceForPathfinding} ${startState.x},${startState.y},${startState.r} -> ${targetState.x},${targetState.y},${targetState.r}</span>`;
            }
            
            const pathfinderBoard = this.board.map(row => row.map(cell => (cell === null ? 0 : 1)));
path = this.findShortestPath_forAI(startState, targetState, pieceForPathfinding, pathfinderBoard);
        }
        
        if (path) {
            if (holdIsNeeded) {
                this.hold();
                await new Promise(resolve => setTimeout(resolve, gameSettings.drawMoveDelay));
            }
            await this.executeDrawMove(path);
        }
    }
}
function setupEditors() { ['p1', 'p2'].forEach(setupPlayerEditor);

}


function setupPlayerEditor(playerId) {
    editorData[playerId].board = Array.from({ length: BOARD_HEIGHT }, () => Array(BOARD_WIDTH).fill(null));
    const nextIcons = document.getElementById(`${playerId}-next-icons`);
    nextIcons.innerHTML = '';
    Object.keys(TETROMINOS).forEach(key => {
        const icon = document.createElement('div');
icon.className = 'mino-icon';
        if (activeSkin[key] && activeSkin[key].src) {
            icon.style.backgroundImage = `url(${activeSkin[key].src})`;
            icon.style.backgroundSize = 'cover';
        } else {
            icon.style.backgroundColor = activeSkinColors[key];
        }
        icon.addEventListener('click', () => {
            const data = editorData[playerId];
            if (data.nextInsertionIndex === 'hold') {
                data.hold = key;
           
     data.nextInsertionIndex = 0;
            } else if (data.nextInsertionIndex === -1) {
                data.nextQueue.push(key);
                data.nextInsertionIndex = data.nextQueue.length;
            } else {
                data.nextQueue.splice(data.nextInsertionIndex, 0, key);
                data.nextInsertionIndex++;
            }
            updateNextQueueDisplay(playerId);
        });
        nextIcons.appendChild(icon);
    });
    
    const endIcon = document.createElement('div');
    endIcon.className = 'mino-icon';
    if (activeSkin['E'] && activeSkin['E'].src) {
        endIcon.style.backgroundImage = `url(${activeSkin['E'].src})`;
        endIcon.style.backgroundSize = 'cover';
    } else {
        endIcon.style.backgroundColor = activeSkinColors['E'];
    }
    endIcon.style.color = '#FFFFFF';
    endIcon.style.display = 'flex';
    endIcon.style.alignItems = 'center';
endIcon.style.justifyContent = 'center';
    endIcon.style.fontFamily = 'var(--font-display)';
    endIcon.style.fontSize = '14px';
    endIcon.style.fontWeight = 'bold';
endIcon.textContent = 'END';
endIcon.addEventListener('click', () => {
        const data = editorData[playerId];
        if (data.nextInsertionIndex === 'hold' || data.nextQueue.length === 0) {
            return;
        }
        const key = 'E';
        if (data.nextInsertionIndex === -1) {
            data.nextQueue.push(key);
            data.nextInsertionIndex = data.nextQueue.length;
        } else {
            data.nextQueue.splice(data.nextInsertionIndex, 0, key);
            data.nextInsertionIndex++;
        }
        updateNextQueueDisplay(playerId);
    });
    nextIcons.appendChild(endIcon);
    
     document.getElementById(`${playerId}-next-delete-left`).addEventListener('click', () => {
        const data = editorData[playerId];
        const index = data.nextInsertionIndex;
        if (index === 'hold' || (index === -1 && data.nextQueue.length === 0)) {
            return;
        }
        if (index === 0) {
            data.hold = null;
        } else if (index > 0) {
            data.nextQueue.splice(index - 1, 1);
            data.nextInsertionIndex--;
        } else { // index is -1 (end of queue)
            data.nextQueue.pop();
            data.nextInsertionIndex = data.nextQueue.length;
        }
        updateNextQueueDisplay(playerId);
    });
    document.getElementById(`${playerId}-next-clear`).addEventListener('click', () => {
        editorData[playerId].nextQueue = [];
        editorData[playerId].hold = null;
        editorData[playerId].nextInsertionIndex = 0;
        updateNextQueueDisplay(playerId);
    });
    const palette = document.getElementById(`${playerId}-palette`);
    palette.innerHTML = '';

    const autoSwatch = document.createElement('div');
    autoSwatch.className = 'color-swatch';
    autoSwatch.style.display = 'flex';
    autoSwatch.style.alignItems = 'center';
    autoSwatch.style.justifyContent = 'center';
    autoSwatch.style.fontFamily = 'var(--font-display)';
    autoSwatch.style.backgroundColor = '#FFFFFF';
    autoSwatch.style.color = '#000000';
    autoSwatch.style.fontSize = '12px';
    autoSwatch.style.fontWeight = 'bold';
    autoSwatch.textContent = 'AUTO';
    autoSwatch.addEventListener('click', () => {
        editorData[playerId].activeColor = 'AUTO';
        palette.querySelector('.active')?.classList.remove('active');
        autoSwatch.classList.add('active');
    });
palette.appendChild(autoSwatch);

    Object.keys(EDITOR_COLORS).filter(key => key !== 'E').forEach(key => { const swatch = document.createElement('div'); swatch.className = 'color-swatch';
    if (key === 'EMPTY') {
        swatch.style.backgroundColor = '#333';
        swatch.style.border = '1px dashed #fff';
        swatch.title = 'Eraser';
    } else if (activeSkin[key] && activeSkin[key].src) {
        swatch.style.backgroundImage = `url(${activeSkin[key].src})`;
        swatch.style.backgroundSize = 'cover';
    } else {
        swatch.style.backgroundColor = EDITOR_COLORS[key];
    }
    if (key === editorData[playerId].activeColor) swatch.classList.add('active'); swatch.addEventListener('click', () => { editorData[playerId].activeColor = key; palette.querySelector('.active')?.classList.remove('active'); swatch.classList.add('active'); }); palette.appendChild(swatch); });
const canvas = document.getElementById(`field-editor-canvas-${playerId}`);
    
    canvas.width = BOARD_WIDTH * EDITOR_BLOCK_SIZE; canvas.height = BOARD_VISIBLE_HEIGHT * EDITOR_BLOCK_SIZE;
    let isDrawing = false;
let isEraserMode = false;

    function checkForAndReplaceTetromino(playerId) {
        const board = editorData[playerId].board;
        const whiteBlocks = [];
        for (let r = 0; r < BOARD_HEIGHT; r++) {
            for (let c = 0; c < BOARD_WIDTH; c++) {
                if (board[r][c] === 'W') {
                    whiteBlocks.push({ y: r, x: c });
                }
            }
        }

        if (whiteBlocks.length !== 4) return;

        whiteBlocks.sort((a, b) => a.y !== b.y ? a.y - b.y : a.x - b.x);
        const anchor = whiteBlocks[0];

        const relativeCoords = whiteBlocks.slice(1).map(block => `${block.x - anchor.x},${block.y - anchor.y}`);
        const key = relativeCoords.sort().join(';');
        
        const createKey = (coords) => coords.map(c => `${c[0]},${c[1]}`).sort().join(';');

        const shapeMap = {
            [createKey([[1,0],[2,0],[3,0]])]: 'I', [createKey([[0,1],[0,2],[0,3]])]: 'I',
            [createKey([[0,1],[1,0],[1,1]])]: 'O',
            [createKey([[0,1],[1,1],[0,2]])]: 'T', [createKey([[0,1],[0,2],[-1,1]])]: 'T',
            [createKey([[-1,1],[0,1],[1,1]])]: 'T', [createKey([[1,0],[2,0],[1,1]])]: 'T',
            [createKey([[0,1],[1,2],[0,2]])]: 'L', [createKey([[1,0],[1,1],[1,2]])]: 'L',
            [createKey([[-1,1],[0,1],[-2,1]])]: 'L', [createKey([[1,0],[2,0],[0,1]])]: 'L',
            [createKey([[0,1],[-1,2],[0,2]])]: 'J', [createKey([[0,1],[0,2],[1,0]])]: 'J',
            [createKey([[2,1],[0,1],[1,1]])]: 'J', [createKey([[1,0],[2,0],[2,1]])]: 'J',
            [createKey([[0,1],[1,1],[1,2]])]: 'S', [createKey([[1,0],[0,1],[-1,1]])]: 'S',
            [createKey([[-1,1],[0,1],[-1,2]])]: 'Z', [createKey([[1,0],[2,1],[1,1]])]: 'Z',
        };

        const minoType = shapeMap[key];

        if (minoType) {
            whiteBlocks.forEach(block => {
                board[block.y][block.x] = minoType;
            });
        }
    }

    const getCoordsFromEvent = e => {
        const rect = canvas.getBoundingClientRect();
const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
const relativeX = (clientX - rect.left) / rect.width;
        const relativeY = (clientY - rect.top) / rect.height;
const x = Math.floor(relativeX * BOARD_WIDTH);
        const y = Math.floor(relativeY * BOARD_VISIBLE_HEIGHT);
        return { x, y };
    };
const applyDraw = (x, y) => {
        if (x < 0 || x >= BOARD_WIDTH || y < 0 || y >= BOARD_VISIBLE_HEIGHT) return;

        const selectedColor = editorData[playerId].activeColor;
        const boardY = y + editorData[playerId].viewY;
        const board = editorData[playerId].board;

        if (selectedColor === 'AUTO') {
            const currentCell = board[boardY][x];
            if (isEraserMode) {
                if (currentCell === 'W') {
                    board[boardY][x] = null;
                }
            } else {
                if (currentCell === null) {
                    const whiteBlockCount = board.flat().filter(cell => cell === 'W').length;
                    if (whiteBlockCount < 4) {
                        board[boardY][x] = 'W';
                        if (whiteBlockCount + 1 === 4) {
                            checkForAndReplaceTetromino(playerId);
                        }
                    }
                }
            }
        } else {
            if (isEraserMode) {
                board[boardY][x] = null;
            } else {
                board[boardY][x] = (selectedColor === 'EMPTY') ? null : selectedColor;
            }
        }
        drawEditorField(playerId);
    };

    const handleDrawStart = e => {
        e.preventDefault();
isDrawing = true;
        const { x, y } = getCoordsFromEvent(e);
        const selectedColor = editorData[playerId].activeColor;

        if (selectedColor === 'AUTO') {
            if (x >= 0 && x < BOARD_WIDTH && y >= 0 && y < BOARD_VISIBLE_HEIGHT) {
                const boardY = y + editorData[playerId].viewY;
                const currentCellColor = editorData[playerId].board[boardY][x];
                isEraserMode = (currentCellColor === 'W');
            }
        } else {
            if (x >= 0 && x < BOARD_WIDTH && y >= 0 && y < BOARD_VISIBLE_HEIGHT) {
                const boardY = y + editorData[playerId].viewY;
                const currentCellColor = editorData[playerId].board[boardY][x];
                isEraserMode = (selectedColor === 'EMPTY' || currentCellColor === selectedColor);
            }
        }
        applyDraw(x, y);
    };
const handleDrawMove = e => {
        if (!isDrawing) return;
        e.preventDefault();
const { x, y } = getCoordsFromEvent(e);
        applyDraw(x, y);
    };
const handleDrawEnd = () => {
        if (!isDrawing) return;
        isDrawing = false;
isEraserMode = false;
    };

    canvas.addEventListener('mousedown', handleDrawStart);
    canvas.addEventListener('mouseup', handleDrawEnd);
    canvas.addEventListener('mouseleave', handleDrawEnd);
    canvas.addEventListener('mousemove', handleDrawMove);
    canvas.addEventListener('touchstart', handleDrawStart, { passive: false });
    canvas.addEventListener('touchend', handleDrawEnd, { passive: false });
    canvas.addEventListener('touchcancel', handleDrawEnd, { passive: false });
    canvas.addEventListener('touchmove', handleDrawMove, { passive: false });

    
    document.getElementById(`${playerId}-field-shift-up`).addEventListener('click', () => shiftField(playerId, 'up'));
    document.getElementById(`${playerId}-field-shift-down`).addEventListener('click', () => shiftField(playerId, 'down'));
    document.getElementById(`${playerId}-field-clear`).addEventListener('click', () => { editorData[playerId].board.forEach(row => row.fill(null)); drawEditorField(playerId); });
    document.getElementById(`${playerId}-field-line-clear`).addEventListener('click', () => lineClearField(playerId));
    drawEditorField(playerId);
}

function lineClearField(playerId) {
    const data = editorData[playerId];
    const oldBoard = data.board;
    
    // 完全に空(nullのみ)でもなく、完全に埋まって(nullなし)もいない行だけを残す
    const keptRows = oldBoard.filter(row => {
        const isFull = row.every(cell => cell !== null);
        const isEmpty = row.every(cell => cell === null);
        return !isFull && !isEmpty;
    });

    // 新しいボードを作成（上部をnullで埋め、下部に残った行を詰める）
    const newBoard = Array.from({ length: BOARD_HEIGHT }, () => Array(BOARD_WIDTH).fill(null));
    const fillStartIndex = BOARD_HEIGHT - keptRows.length;
    
    for (let i = 0; i < keptRows.length; i++) {
        newBoard[fillStartIndex + i] = keptRows[i];
    }
    
    data.board = newBoard;
    drawEditorField(playerId);
}

function shiftField(playerId, direction) {
    const board = editorData[playerId].board;
    if (direction === 'up') {
        board.shift();
        board.push(Array(BOARD_WIDTH).fill(null));
    } else {
        board.pop();
        board.unshift(Array(BOARD_WIDTH).fill(null));
    }
    drawEditorField(playerId);
}

function updateNextQueueDisplay(playerId) {
    const qd = document.getElementById(`${playerId}-next-queue`);
    qd.innerHTML = '';
    const data = editorData[playerId];

    const createGap = (index) => {
        const gap = document.createElement('div');
        gap.style.width = '8px';
        gap.style.height = '38px';
        gap.style.cursor = 'pointer';
        gap.style.display = 'flex';
        gap.style.alignItems = 'center';
        gap.style.justifyContent = 'center';
        gap.style.userSelect = 'none';
        gap.addEventListener('click', (e) => {
            e.stopPropagation();
            data.nextInsertionIndex = index;
            updateNextQueueDisplay(playerId);
        });
        if (data.nextInsertionIndex === index) {
            gap.style.backgroundColor = 'rgba(255, 255, 255, 0.3)';
            gap.style.borderRadius = '2px';
            gap.innerHTML = '<span style="color: white; font-weight: bold; line-height: 1;">|</span>';
        }
        return gap;
    };

    const holdContainer = document.createElement('div');
    holdContainer.style.display = 'flex';
    holdContainer.style.alignItems = 'center';
    holdContainer.style.gap = '5px';
    holdContainer.style.padding = '0 8px';
    holdContainer.style.borderRight = '2px solid var(--primary-color)';

    const holdSlot = document.createElement('div');
    holdSlot.className = 'mino-icon';
    holdSlot.style.width = '38px';
    holdSlot.style.height = '38px';
    holdSlot.style.cursor = 'pointer';
    holdSlot.style.boxSizing = 'border-box';
    if (data.hold) {
        if (activeSkin[data.hold] && activeSkin[data.hold].src) {
            holdSlot.style.backgroundImage = `url(${activeSkin[data.hold].src})`;
            holdSlot.style.backgroundSize = 'cover';
            holdSlot.style.border = 'none';
        } else {
            holdSlot.style.backgroundColor = activeSkinColors[data.hold];
        }
} else {
        holdSlot.style.backgroundColor = 'transparent';
        holdSlot.style.border = '2px dashed #555';
}
    if (data.nextInsertionIndex === 'hold') {
        holdSlot.style.borderColor = '#FFF';
        holdSlot.style.boxShadow = '0 0 8px #FFF';
    }
    holdSlot.addEventListener('click', (e) => {
        e.stopPropagation();
        data.nextInsertionIndex = 'hold';
        updateNextQueueDisplay(playerId);
    });
    const holdLabel = document.createElement('span');
    holdLabel.textContent = "H";
    holdLabel.style.fontFamily = 'var(--font-display)';
    holdContainer.appendChild(holdLabel);
    holdContainer.appendChild(holdSlot);
    qd.appendChild(holdContainer);
    
    const nextContainer = document.createElement('div');
    nextContainer.style.display = 'flex';
    nextContainer.style.alignItems = 'center';
    nextContainer.style.gap = '5px';
    nextContainer.style.paddingLeft = '8px';
    nextContainer.style.flexWrap = 'wrap';

   nextContainer.appendChild(createGap(0));
    data.nextQueue.forEach((key, i) => {
        const icon = document.createElement('div');
        icon.className = 'mino-icon';
        if (activeSkin[key] && activeSkin[key].src) {
            icon.style.backgroundImage = `url(${activeSkin[key].src})`;
            icon.style.backgroundSize = 'cover';
        } else {
            icon.style.backgroundColor = activeSkinColors[key];
        }
        icon.style.width = '38px';
        icon.style.height = '38px';
        if (key === 'E') {
            icon.textContent = 'END';
            icon.style.color = 'white';
      
      icon.style.display = 'flex';
            icon.style.alignItems = 'center';
            icon.style.justifyContent = 'center';
            icon.style.fontFamily = 'var(--font-display)';
            icon.style.fontSize = '12px';
            icon.style.fontWeight = 'bold';
        }
        nextContainer.appendChild(icon);
        nextContainer.appendChild(createGap(i + 1));
    });
    qd.appendChild(nextContainer);

    qd.onclick = (e) => {
        if (e.target === qd || e.target === nextContainer) {
            data.nextInsertionIndex = data.nextQueue.length;
            updateNextQueueDisplay(playerId);
        }
    };
}

function drawEditorField(playerId) {
    const canvas = document.getElementById(`field-editor-canvas-${playerId}`),
        ctx = canvas.getContext('2d'),
        data = editorData[playerId];
if (activeSkin['BG'] && activeSkin['BG'].src) {
        ctx.fillStyle = '#0f0f18';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        for (let y = 0; y < BOARD_VISIBLE_HEIGHT; y++) {
            for (let x = 0; x < BOARD_WIDTH; x++) {
                ctx.drawImage(activeSkin['BG'], x * EDITOR_BLOCK_SIZE, y * EDITOR_BLOCK_SIZE, EDITOR_BLOCK_SIZE, EDITOR_BLOCK_SIZE);
            }
        }
} else {
        ctx.fillStyle = '#0f0f18';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    ctx.strokeStyle = '#444';
ctx.lineWidth = 1;
    for (let y = 0; y < BOARD_VISIBLE_HEIGHT; y++) {
        for (let x = 0; x < BOARD_WIDTH; x++) {
            const pieceType = data.board[y + data.viewY]?.[x];
if (pieceType) {
                if (pieceType === 'W') {
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(x * EDITOR_BLOCK_SIZE, y * EDITOR_BLOCK_SIZE, EDITOR_BLOCK_SIZE, EDITOR_BLOCK_SIZE);
                } else if (activeSkin[pieceType] && activeSkin[pieceType].src) {
                    ctx.drawImage(activeSkin[pieceType], x * EDITOR_BLOCK_SIZE, y * EDITOR_BLOCK_SIZE, EDITOR_BLOCK_SIZE, EDITOR_BLOCK_SIZE);
                } else {
                    ctx.fillStyle = activeSkinColors[pieceType];
ctx.fillRect(x * EDITOR_BLOCK_SIZE, y * EDITOR_BLOCK_SIZE, EDITOR_BLOCK_SIZE, EDITOR_BLOCK_SIZE);
                }
}
            ctx.strokeRect(x * EDITOR_BLOCK_SIZE, y * EDITOR_BLOCK_SIZE, EDITOR_BLOCK_SIZE, EDITOR_BLOCK_SIZE);
}
    }
}


function bindKey(binding) {
    if (!isBindingKey || !bindingPlayer || !bindingAction) return;
    
    keyBindings[bindingPlayer][bindingAction] = binding;
    isBindingKey = false;
    bindingAction = null;
    const tabToReopen = bindingPlayer === 'p1' ? 'p1-keys' : 'p2-keys';
    openUnifiedSettingsModal(tabToReopen);
}

function loadKeyBindings() {
    try {
        const savedBindings = JSON.parse(localStorage.getItem('tetrisKeyBindings'));
        if (savedBindings) {
            if (savedBindings.p1) Object.assign(keyBindings.p1, savedBindings.p1);
            if (savedBindings.p2) Object.assign(keyBindings.p2, savedBindings.p2);
        }
    } catch (e) { console.error("Failed to load key bindings from localStorage:", e); }
}

function saveGameSettings() {
    try {
        localStorage.setItem('tetrisGameSettings', JSON.stringify(gameSettings));
    } catch (e) { console.error("Failed to save game settings to localStorage:", e); }
}
    
function loadGameSettings() {
    try {
        const saved = localStorage.getItem('tetrisGameSettings');
if (saved) {
            const parsed = JSON.parse(saved);
            Object.assign(gameSettings, parsed);
}
    } catch(e) { console.error('Failed to load settings from localStorage:', e);
}
}

const SKIN_STORAGE_KEY = 'tetrisCustomSkins';

function saveSkinsToLocalStorage() {
    try {
        const skinsToSave = {};
        const validTypes = ['I', 'O', 'T', 'L', 'J', 'S', 'Z', 'G', 'E', 'BG'];
        validTypes.forEach(key => {
            if (activeSkin[key] && activeSkin[key].src) {
                skinsToSave[key] = activeSkin[key].src;
            }
        });
        localStorage.setItem(SKIN_STORAGE_KEY, JSON.stringify(skinsToSave));
    } catch (e) {
        console.error("Failed to save skins to localStorage:", e);
    }
}

function loadSkinsFromLocalStorage() {
    try {
        const savedSkins = localStorage.getItem(SKIN_STORAGE_KEY);
        if (savedSkins) {
            const parsedSkins = JSON.parse(savedSkins);
            const validTypes = ['I', 'O', 'T', 'L', 'J', 'S', 'Z', 'G', 'E', 'BG'];
            let skinsLoaded = false;
            Object.keys(parsedSkins).forEach(key => {
                if (validTypes.includes(key) && parsedSkins[key]) {
                    activeSkin[key] = new Image();
                    activeSkin[key].src = parsedSkins[key];
                    skinsLoaded = true;
                }
            });
            return skinsLoaded;
        }
    } catch (e) {
        console.error("Failed to load skins from localStorage:", e);
    }
    return false;
}

function resetSkins() {
    if (!confirm('保存されているカスタムスキンをすべて削除し、デフォルトに戻しますか？')) return;
    try {
        localStorage.removeItem(SKIN_STORAGE_KEY);
        activeSkin = MINO_SKINS.default;
        ['I', 'O', 'T', 'L', 'J', 'S', 'Z', 'G', 'E', 'BG'].forEach(k => MINO_SKINS.default[k] = new Image());
        activeSkin = MINO_SKINS.default;
        
        ['p1', 'p2'].forEach(setupPlayerEditor);
        ['p1', 'p2'].forEach(updateNextQueueDisplay);
        ['p1', 'p2'].forEach(drawEditorField);
        
        alert('スキンをリセットしました。');
    } catch (e) {
        console.error("Failed to reset skins:", e);
        alert('スキンのリセットに失敗しました。');
    }
}

function populateGeneralSettingsTab() {
    const list = document.getElementById('settings-list');
    list.innerHTML = '';
    const settingDetails = {
        das: { label: 'DAS (ms)', min: 0, max: 500, step: 10 },
        arr: { label: 'ARR (ms)', min: 0, max: 100, step: 1 },
        sdf: { label: 'SDF (ms)', min: 0, max: 100, step: 1 },
        lineClearDelay: { label: 'ライン消去時間 (ms)', min: 0, max: 2000, step: 50 },
        gravity: { label: '落下間隔時間 (ms)', min: 0, max: 9999999, step: 50 },
        lockDelay: { label: '設置猶予時間 (ms)', min: 0, max: 9999999, step: 50 },
        maxNext: { label: 'ネクスト表示数', min: 1, max: 8, step: 1 },
        garbageGrace: { label: 'おじゃま猶予時間 (ms)', min: 0, max: 5000, step: 100 },
        garbageRandomness: { label: '穴バラ率 (%)', min: 0, max: 100, step: 1 }
    };
    Object.keys(settingDetails).forEach(key => {
        const item = document.createElement('div'); item.className = 'setting-item';
        const label = document.createElement('span'); label.textContent = settingDetails[key].label;
        const input = document.createElement('input'); input.type = 'number';
        Object.assign(input, settingDetails[key]);
        let currentValue = gameSettings[key];
        if (key === 'garbageRandomness') currentValue *= 100;
        input.value = currentValue;
        input.onchange = e => {
            let val = parseFloat(e.target.value);
            if (key === 'garbageRandomness') gameSettings[key] = Math.max(0, Math.min(100, val)) / 100;
            else gameSettings[key] = Math.max(settingDetails[key].min, Math.min(settingDetails[key].max, val));
        };
        item.append(label, input); list.appendChild(item);
    });
    
    const checkboxSettings = { showEffects: 'エフェクトを表示する', showTimer: 'タイマーを表示する', touchControlsEnabled: 'タッチ操作を有効にする (P1)' };
    Object.entries(checkboxSettings).forEach(([key, text], index) => {
        const item = document.createElement('div'); item.className = 'setting-item';
        if (index === 0) { item.style.cssText = 'margin-top:20px; border-top:1px solid var(--primary-color); padding-top:15px;'; }
        const label = document.createElement('label'); const checkbox = document.createElement('input');
        checkbox.type = 'checkbox'; checkbox.id = `setting-${key}`; checkbox.checked = !!gameSettings[key];
        checkbox.onchange = e => { gameSettings[key] = e.target.checked; };
        const span = document.createElement('span'); span.textContent = text;
 

       label.append(checkbox, span); item.appendChild(label); list.appendChild(item);
    });
}

function populateKeyConfigTab(playerId) {
    const list = document.getElementById(`${playerId}-key-config-list`);
    list.innerHTML = ''; 
    Object.keys(keyBindings[playerId]).forEach(action => {
        const item = document.createElement('div'); item.className = 'key-config-item';
        const label = document.createElement('span'); label.textContent = keyActionLabels[action];
        const btn = document.createElement('button'); btn.className = 'button';
        btn.textContent = keyBindings[playerId][action].label;
        btn.onclick = () => {
            isBindingKey = true; bindingPlayer = playerId; bindingAction = action;
            btn.textContent = 
'入力待機中...';
            list.querySelectorAll('button').forEach(b => { if (b !== btn) b.disabled = true; });
        };
        item.appendChild(label); item.appendChild(btn); list.appendChild(item);
    });
    if (playerId === 'p1') {
        const drawMoveDelayInput = document.getElementById('draw-move-delay-input');
        if (drawMoveDelayInput) {
            drawMoveDelayInput.value = gameSettings.drawMoveDelay;
            drawMoveDelayInput.onchange = e => {
                const val = parseInt(e.target.value, 10);
                if (!isNaN(val)) gameSettings.drawMoveDelay = Math.max(0, Math.min(200, val));
            };
        }
        const touchModeButtons = document.querySelectorAll('#p1-touch-mode-selection .button');
        touchModeButtons.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.touchMode === gameSettings.touchControlType);
        });
        document.getElementById('p1-touch-button-controls').style.display = gameSettings.touchControlType === 'button' ? 'flex' : 'none';
        document.getElementById('p1-touch-draw-controls').style.display = gameSettings.touchControlType === 'draw' ? 'flex' : 'none';
    }
}

function populateAiSettingsTab() {
    const list = document.getElementById('ai-settings-list');
    list.innerHTML = '';

    const itemType = document.createElement('div');
    itemType.className = 'setting-item';
    const labelType = document.createElement('span');
    labelType.textContent = 'AIの種類';
    
    const selectType = document.createElement('select');
    selectType.id = 'ai-type-select';
    selectType.style.minWidth = '150px';
    selectType.style.backgroundColor = 'var(--primary-color)';
    selectType.style.color = 'var(--font-color)';
    selectType.style.border = '1px solid var(--border-color)';
    selectType.style.padding = '5px';
    selectType.style.borderRadius = '4px';

    selectType.innerHTML = `
        <option value="simplified" selected>Cold Clear (一部改変)</option>
        <option value="default">Cold Clear (旧弱体化版・テンプレ非対応)</option>
    `;

    selectType.onchange = (e) => {
        gameSettings.aiType = e.target.value;
    };
    
    if (gameSettings.aiType) {
        selectType.value = gameSettings.aiType;
    } else {
        gameSettings.aiType = 'simplified';
    }

    itemType.append(labelType, selectType);
    list.appendChild(itemType);

    const settingDetails = {
        aiMoveDelay: { label: 'AIの操作入力間隔 (ms)', min: 20, max: 500, step: 1 },
        aiSdfDelay: { label: 'AI SDF (ms)', min: 0, max: 500, step: 1 }
    };
    
        Object.keys(settingDetails).forEach(key => {
        const item = document.createElement('div');
        item.className = 'setting-item';
        const label = document.createElement('span');
        label.textContent = settingDetails[key].label;
        const input = document.createElement('input');
        input.type = 'number';
        Object.assign(input, settingDetails[key]);
        input.value = gameSettings[key];
        input.onchange = e => {
            gameSettings[key] = Math.max(settingDetails[key].min, Math.min(settingDetails[key].max, parseInt(e.target.value, 10)));
        };
                item.append(label, input);
        list.appendChild(item);
    });
    const pfpItem = document.createElement('div');
    pfpItem.className = 'setting-item';
    
    const pfpLabel = document.createElement('label');
    const pfpCheckbox = document.createElement('input');
    pfpCheckbox.type = 'checkbox';
    pfpCheckbox.checked = !!gameSettings.pieceForPieceMode;
    pfpCheckbox.onchange = e => {
        gameSettings.pieceForPieceMode = e.target.checked;
    };
    
    const pfpSpan = document.createElement('span');
    pfpSpan.textContent = 'Piece For Piece';
    
    pfpLabel.append(pfpCheckbox, pfpSpan);
    pfpItem.appendChild(pfpLabel);
    list.appendChild(pfpItem);
    const tempHeader = document.createElement('div');
    tempHeader.className = 'setting-item';
    tempHeader.style.cssText = 'margin-top:20px; border-top:1px solid var(--primary-color); padding-top:15px; font-weight:bold;';
    tempHeader.textContent = '使用するテンプレ';
    list.appendChild(tempHeader);

    AI_TEMPLATE_CONFIG.forEach(config => {
        const item = document.createElement('div');
        item.className = 'setting-item';
        
        const label = document.createElement('label');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = gameSettings.aiTemplates[config.id];
        checkbox.onchange = e => {
            gameSettings.aiTemplates[config.id] = e.target.checked;
        };
        
        const span = document.createElement('span');
        span.textContent = config.label;
        label.append(checkbox, span);
                item.appendChild(label);
        list.appendChild(item);
    });

    // AI Hint Setting
    const hintItem = document.createElement('div');
    hintItem.className = 'setting-item';
    hintItem.style.cssText = 'margin-top:10px; border-top:1px solid var(--primary-color); padding-top:10px;';
    const hintLabel = document.createElement('label');
    const hintCheckbox = document.createElement('input');
    hintCheckbox.type = 'checkbox';
    hintCheckbox.checked = !!gameSettings.aiHintEnabled;
    hintCheckbox.onchange = e => {
        gameSettings.aiHintEnabled = e.target.checked;
    };
    const hintSpan = document.createElement('span');
    hintSpan.textContent = 'AIヒントを表示 (Player 1のみ)';
    hintLabel.append(hintCheckbox, hintSpan);
    hintItem.appendChild(hintLabel);
    list.appendChild(hintItem);
}

function populateLayoutSettingsTab() {
    const list = document.getElementById('layout-settings-list');
    list.innerHTML = '';
if (!gameSettings.layout) {
        gameSettings.layout = generateDefaultLayout();
}
    const layout = gameSettings.layout;

    // --- Custom Skins (Moved from General) ---
    const skinItem = document.createElement('div');
    skinItem.className = 'setting-item';
    skinItem.style.cssText = 'flex-direction: column; align-items: flex-start; gap: 10px; margin-bottom: 20px;';
    
    const skinLabel = document.createElement('label');
    skinLabel.textContent = 'カスタムスキン (I,O,T,L,J,S,Z,G,BG.png)';
    
    const skinInput = document.createElement('input');
    skinInput.type = 'file';
    skinInput.multiple = true;
    skinInput.accept = 'image/*';
    skinInput.style.display = 'block';
    skinInput.style.minWidth = '0';
    
    skinInput.addEventListener('change', (e) => {
        const files = e.target.files;
        if (!files) return;
        
        let filesLoaded = 0;
        const totalFiles = files.length;
        
        const redrawEditors = () => {
            if (++filesLoaded === totalFiles) {
                 ['p1', 'p2'].forEach(setupPlayerEditor);
                ['p1', 'p2'].forEach(updateNextQueueDisplay);
                ['p1', 'p2'].forEach(drawEditorField);
                alert(`${totalFiles}個のスキンを読み込みました。`);
            }
        };
        
        for (const file of files) {
            const pieceType = file.name.split('.')[0].toUpperCase();
            const validTypes = ['I', 'O', 'T', 'L', 'J', 'S', 'Z', 'G', 'E', 'BG'];
            
            if (validTypes.includes(pieceType)) {
                const reader = new FileReader();
                reader.onload = (re) => {
                    activeSkin[pieceType].src = re.target.result;
                    activeSkin[pieceType].onload = () => {
                        redrawEditors();
                        saveSkinsToLocalStorage();
                    };
                    activeSkin[pieceType].onerror = () => {
                        redrawEditors();
                        saveSkinsToLocalStorage();
                    };
                };
                reader.onerror = redrawEditors;
                reader.readAsDataURL(file);
            } else {
                redrawEditors();
            }
        }
    });
    
    const skinResetButton = document.createElement('button');
    skinResetButton.className = 'button';
    skinResetButton.textContent = 'カスタムスキンをリセット';
    skinResetButton.style.marginTop = '10px';
    skinResetButton.onclick = resetSkins;
    
    skinItem.append(skinLabel, skinInput, skinResetButton);
    list.appendChild(skinItem);
    // --- Global Settings ---
    const globalHeader = document.createElement('h3');
globalHeader.textContent = '全体設定';
    globalHeader.style.marginTop = '10px';
    list.appendChild(globalHeader);

    // Block Size
    const blockSizeItem = document.createElement('div');
    blockSizeItem.className = 'setting-item';
const bsLabel = document.createElement('span'); bsLabel.textContent = 'ブロックサイズ (px)';
    const bsInput = document.createElement('input'); bsInput.type = 'number';
    bsInput.value = layout.blockSize;
bsInput.min = 10; bsInput.max = 100;
    bsInput.onchange = (e) => { layout.blockSize = parseInt(e.target.value, 10); updateScale(); };
    blockSizeItem.append(bsLabel, bsInput);
    list.appendChild(blockSizeItem);
const uiBlockSizeItem = document.createElement('div');
    uiBlockSizeItem.className = 'setting-item';
    const uibsLabel = document.createElement('span'); uibsLabel.textContent = 'UIブロックサイズ (px)';
    const uibsInput = document.createElement('input');
uibsInput.type = 'number';
    uibsInput.value = layout.uiBlockSize || layout.blockSize;
    uibsInput.min = 10; uibsInput.max = 100;
uibsInput.onchange = (e) => { layout.uiBlockSize = parseInt(e.target.value, 10); updateScale(); };
    uiBlockSizeItem.append(uibsLabel, uibsInput);
    list.appendChild(uiBlockSizeItem);
// Background Image
    const bgItem = document.createElement('div');
    bgItem.className = 'setting-item';
    bgItem.style.flexDirection = 'column'; bgItem.style.alignItems = 'flex-start';
const bgLabel = document.createElement('span'); bgLabel.textContent = '背景画像';
    const bgInput = document.createElement('input'); bgInput.type = 'file'; bgInput.accept = 'image/*';
    bgInput.style.display = 'block';
// CSSで非表示になっているため明示的に表示
    bgInput.style.marginTop = '5px';
    bgInput.onchange = (e) => {
        const file = e.target.files[0];
if (file) {
            const reader = new FileReader();
reader.onload = (evt) => {
                layout.backgroundImage = evt.target.result;
layout._bgImageCache = null;
                alert('背景画像を設定しました。');
            };
            reader.readAsDataURL(file);
        }
    };
    const bgClearBtn = document.createElement('button'); bgClearBtn.className = 'button';
bgClearBtn.textContent = '背景をクリア'; bgClearBtn.style.marginTop = '5px';
    bgClearBtn.onclick = () => { layout.backgroundImage = null; alert('背景をクリアしました。'); };
    
    bgItem.append(bgLabel, bgInput, bgClearBtn);
    list.appendChild(bgItem);
// --- Player Layouts ---
    const createCoordInputs = (label, obj, keyX, keyY) => {
        const div = document.createElement('div');
div.className = 'setting-item';
        div.style.flexWrap = 'wrap';
        
        const title = document.createElement('span');
        title.textContent = label;
        title.style.width = '100%';
        title.style.marginBottom = '5px';
const xLabel = document.createElement('span'); xLabel.textContent = 'X:';
        const xInput = document.createElement('input'); xInput.type = 'number';
        xInput.value = obj[keyX]; xInput.style.width = '60px';
xInput.onchange = (e) => { obj[keyX] = parseInt(e.target.value, 10); };

        const yLabel = document.createElement('span'); yLabel.textContent = 'Y:';
const yInput = document.createElement('input'); yInput.type = 'number';
        yInput.value = obj[keyY]; yInput.style.width = '60px';
yInput.onchange = (e) => { obj[keyY] = parseInt(e.target.value, 10); };

        div.append(title, xLabel, xInput, yLabel, yInput);
        return div;
    };
const playersList = (gameMode === '1P') ? ['p1'] : ['p1', 'p2'];
playersList.forEach(pid => {
        const pHeader = document.createElement('h3');
        pHeader.textContent = `Player ${pid.replace('p','')}`;
        list.appendChild(pHeader);
        const pLayout = layout[pid];

        // Board
        list.appendChild(createCoordInputs('盤面位置', pLayout.board, 'x', 'y'));
        
        // Hold
        list.appendChild(createCoordInputs('HOLD位置', pLayout.hold, 'x', 'y'));

        // Next (Start + Offset)
        const nextDiv = document.createElement('div');
        nextDiv.className = 'setting-item';
        nextDiv.style.flexWrap = 'wrap';
        
        const nextTitle = document.createElement('span');
        nextTitle.textContent = 'NEXT (開始位置 & 間隔)';
        nextTitle.style.width = '100%'; nextTitle.style.marginBottom = '5px';

        const nxLabel = document.createElement('span'); nxLabel.textContent = 'Start X:';
      
  const nxInput = document.createElement('input'); nxInput.type = 'number';
        nxInput.value = pLayout.next[0].x;
nxInput.style.width = '50px';

        const nyLabel = document.createElement('span'); nyLabel.textContent = 'Start Y:';
        const nyInput = document.createElement('input'); nyInput.type = 'number';
nyInput.value = pLayout.next[0].y; nyInput.style.width = '50px';

        const offsetYLabel = document.createElement('span'); offsetYLabel.textContent = 'Step Y:';
        const offsetYInput = document.createElement('input');
offsetYInput.type = 'number';
        // 推定オフセット
        const currentStep = (pLayout.next.length > 1) ?
(pLayout.next[1].y - pLayout.next[0].y) : (layout.blockSize * 2.5);
        offsetYInput.value = currentStep; offsetYInput.style.width = '50px';
const updateNextArray = () => {
            const startX = parseInt(nxInput.value, 10);
const startY = parseInt(nyInput.value, 10);
            const step = parseInt(offsetYInput.value, 10);
pLayout.next = Array.from({ length: 8 }).map((_, i) => ({
                x: startX,
                y: startY + (i * step)
            }));
};

        nxInput.onchange = updateNextArray;
        nyInput.onchange = updateNextArray;
        offsetYInput.onchange = updateNextArray;

        nextDiv.append(nextTitle, nxLabel, nxInput, nyLabel, nyInput, offsetYLabel, offsetYInput);
        list.appendChild(nextDiv);
    });

    // --- Reset Layout Button (Moved to bottom) ---
    const resetLayoutBtn = document.createElement('button');
    resetLayoutBtn.className = 'button';
    resetLayoutBtn.style.width = '100%';
    resetLayoutBtn.style.marginTop = '20px';
    resetLayoutBtn.textContent = 'レイアウト設定を全て初期化';
    resetLayoutBtn.onclick = () => {
        if (confirm('レイアウト設定を全て初期状態に戻しますか？')) {
            gameSettings.layout = generateDefaultLayout();
            updateScale();
            populateLayoutSettingsTab(); // UI Refresh
        }
    };
    list.appendChild(resetLayoutBtn);
}

function openUnifiedSettingsModal(initialTab = 'general') {
    const modal = document.getElementById('settings-modal');
    
    const p2TabBtn = document.getElementById('p2-keys-tab-btn');
if (gameMode === '2P') {
        p2TabBtn.style.display = 'block';
} else {
        p2TabBtn.style.display = 'none';
        if (initialTab === 'p2-keys') initialTab = 'general';
}

    populateGeneralSettingsTab();
    populateLayoutSettingsTab();
    populateKeyConfigTab('p1');
    populateAiSettingsTab();
    if (gameMode === '2P') {
        populateKeyConfigTab('p2');
}

    const tabs = modal.querySelectorAll('.tab-button');
    const contents = modal.querySelectorAll('.tab-content');
    
    function switchTab(tabName) {
        tabs.forEach(tab => tab.classList.toggle('active', tab.dataset.tab === tabName));
        contents.forEach(content => content.classList.toggle('active', content.id === `tab-content-${tabName}`));
    }
    
    tabs.forEach(tab => {
        tab.addEventListener('click', () => switchTab(tab.dataset.tab));
    });

    switchTab(initialTab);
    modal.style.display = 'flex';
}

function startScanProcess(file, playerId) { const reader = new FileReader(); reader.onload = e => { scanState.image = new Image(); scanState.image.onload = () => { scanState.targetPlayerId = playerId; scanState.bottomLeft = null; scanState.topRight = null; gameState = 'SCAN_BL'; document.getElementById('editor-container').style.display = 'none'; document.getElementById('game-container').style.display = 'block'; document.getElementById('scan-controls').style.display = 'flex'; 
const ar = scanState.image.naturalWidth / scanState.image.naturalHeight; const displayMaxWidth = window.innerWidth * 0.9; const displayMaxHeight = window.innerHeight * 0.8; let displayWidth = displayMaxWidth; let displayHeight = displayWidth / ar; if (displayHeight > displayMaxHeight) { displayHeight = displayMaxHeight; displayWidth = displayHeight * ar; } const canvasWidth = Math.min(2048, scanState.image.naturalWidth); mainCanvas.width = canvasWidth; mainCanvas.height = canvasWidth / ar; mainCanvas.style.width = `${displayWidth}px`; mainCanvas.style.height = `${displayHeight}px`; updateScanUI(); setTimeout(updateScale, 0);}; scanState.image.src = e.target.result; }; reader.readAsDataURL(file); }
function endScanProcess() { gameState = 'EDITING'; scanState.image = null; mainCanvas.style.width = ''; mainCanvas.style.height = ''; document.getElementById('editor-container').style.display = 'flex'; document.getElementById('game-container').style.display = 'none'; document.getElementById('scan-controls').style.display = 'none'; ['p1', 'p2'].forEach(drawEditorField); setTimeout(updateScale, 0); }
function updateScanUI() { const instructions = document.getElementById('scan-instructions'), confirmBtn = document.getElementById('scanConfirmBtn'); mainCanvas.style.cursor = 'crosshair'; if (gameState === 'SCAN_BL') { confirmBtn.style.visibility = scanState.bottomLeft ? 'visible' : 'hidden'; } else if (gameState === 'SCAN_TR') {confirmBtn.style.visibility = scanState.topRight ? 'visible' : 'hidden'; if (scanState.topRight) confirmBtn.textContent = '読込開始'; else confirmBtn.textContent = '次へ'; } }
function drawScanner() { if (!scanState.image) return; ctx.clearRect(0, 0, mainCanvas.width, mainCanvas.height); ctx.drawImage(scanState.image, 0, 0, mainCanvas.width, mainCanvas.height); if (scanState.bottomLeft) { ctx.fillStyle = 'lime'; ctx.beginPath(); ctx.arc(scanState.bottomLeft.x, scanState.bottomLeft.y, 10, 0, Math.PI * 2); ctx.fill(); } if (scanState.topRight) { const {x: blx, y: bly} = scanState.bottomLeft, {x: trx, y: try_} = scanState.topRight; ctx.strokeStyle = 'fuchsia'; ctx.lineWidth = 4; ctx.strokeRect(blx, try_, trx - blx, bly - try_); } }
function processAndLoadBoard() { const tempC = document.createElement('canvas'); tempC.width = scanState.image.naturalWidth; tempC.height = scanState.image.naturalHeight; const tempCtx = tempC.getContext('2d', { willReadFrequently: true }); tempCtx.drawImage(scanState.image, 0, 0); const sX = scanState.image.naturalWidth / mainCanvas.width, sY = scanState.image.naturalHeight / mainCanvas.height; const iBL = { x: scanState.bottomLeft.x*sX, y: scanState.bottomLeft.y*sY }, iTR = { x: scanState.topRight.x*sX, y: scanState.topRight.y*sY }; const bW_px = iTR.x - iBL.x, bH_px = iBL.y - iTR.y, blW_px = bW_px/BOARD_WIDTH, blH_px = bH_px/BOARD_VISIBLE_HEIGHT; const targetBoard = editorData[scanState.targetPlayerId].board; targetBoard.forEach(row => row.fill(null)); for (let r = 0; r < BOARD_VISIBLE_HEIGHT; r++) { for (let c = 0; c < BOARD_WIDTH; c++) { const cX = iBL.x + (c+0.5)*blW_px, cY = iTR.y + (r+0.5)*blH_px; const sampleSize = Math.max(1, Math.floor(blW_px * 0.25)); const iD = tempCtx.getImageData(cX-sampleSize/2, cY-sampleSize/2, sampleSize, sampleSize).data; let avgR=0, avgG=0, avgB=0; for(let i=0; i<iD.length; i+=4){ avgR+=iD[i]; avgG+=iD[i+1]; avgB+=iD[i+2]; } const pCount = iD.length/4; avgR/=pCount; avgG/=pCount; avgB/=pCount; targetBoard[BOARD_HEIGHT - BOARD_VISIBLE_HEIGHT + r][c] = findClosestColor(avgR, avgG, avgB); } } endScanProcess(); }

function findClosestColor(r, g, b) {
    const inputColor = { r, g, b };
    const colorDistanceSq = (c1, c2) => {
        return Math.pow(c1.r - c2.r, 2) + Math.pow(c1.g - c2.g, 2) + Math.pow(c1.b - c2.b, 2);
    };
    for (const nullColor of PARSED_SCAN_COLORS.NULL) {
        if (colorDistanceSq(inputColor, nullColor) < 6000) {
            return null;
        }
    }
    for (const gColor of PARSED_SCAN_COLORS.G) {
        if (colorDistanceSq(inputColor, gColor) < 10000) {
            return 'G';
        }
    }
    let minDistance = Infinity;
    let closestKey = null;
    const minoKeys = Object.keys(PARSED_SCAN_COLORS).filter(k => k !== 'NULL' && k !== 'G');
    for (const key of minoKeys) {
        for (const targetColor of PARSED_SCAN_COLORS[key]) {
            const distance = colorDistanceSq(inputColor, targetColor);
            if (distance < minDistance) {
                minDistance = distance;
                closestKey = key;
            }
        }
    }
    return (minDistance > 25000) ? null : closestKey;
}

function getAverageColorNonBlack(ctx, cx, cy, radius) {
    const startX = Math.floor(cx - radius);
    const startY = Math.floor(cy - radius);
    const diameter = Math.ceil(radius * 2);
    if (startX < 0 || startY < 0 || startX + diameter > ctx.canvas.width || startY + diameter > ctx.canvas.height) {
        return { r: 0, g: 0, b: 0 };
    }
    const imageData = ctx.getImageData(startX, startY, diameter, diameter).data;
    
    let totalR = 0, totalG = 0, totalB = 0, count = 0;
    const radiusSq = radius * radius;
    const blackThreshold = 50; 

    for (let y = 0; y < diameter; y++) {
        for (let x = 0; x < diameter; x++) {
            const dx = x - radius;
            const dy = y - radius;
            
            if (dx * dx + dy * dy <= radiusSq) {
                const i = (y * diameter + x) * 4;
                const r = imageData[i];
                const g = imageData[i + 1];
                const b = imageData[i + 2];
                
                if (r > blackThreshold || g > blackThreshold || b > blackThreshold) {
                    totalR += r;
                    totalG += g;
                    totalB += b;
                    count++;
                }
            }
        }
    }
    
    if (count === 0) {
        return { r: 0, g: 0, b: 0 };
    }
    
    return {
        r: totalR / count,
        g: totalG / count,
        b: totalB / count
    };
}

function findClosestMinoOnly(r, g, b) {
    const inputColor = { r, g, b };
    const colorDistanceSq = (c1, c2) => {
        return Math.pow(c1.r - c2.r, 2) + Math.pow(c1.g - c2.g, 2) + Math.pow(c1.b - c2.b, 2);
    };

    let minDistance = Infinity;
    let closestKey = 'I'; 
    
    const minoKeys = Object.keys(PARSED_SCAN_COLORS).filter(k => k !== 'NULL' && k !== 'G');
    
    for (const key of minoKeys) {
        for (const targetColor of PARSED_SCAN_COLORS[key]) {
            const distance = colorDistanceSq(inputColor, targetColor);
            if (distance < minDistance) {
                minDistance = distance;
                closestKey = key;
            }
        }
    }
    return closestKey;
}

// --- ONNX High Precision PPT Load ---
let onnxSession = null;
const ONNX_CLASS_NAMES = ['null', 'G', 'S', 'Z', 'L', 'J', 'O', 'I', 'T'];
let modelReadyResolver;
const modelReadyPromise = new Promise(resolve => modelReadyResolver = resolve);

async function initOnnxModel() {
    try {
        onnxSession = await ort.InferenceSession.create('./Load%20PPT/tetris.onnx', { executionProviders: ['wasm'] });
        console.log("ONNX Model loaded.");
        if (modelReadyResolver) modelReadyResolver(true);
    } catch (e) {
        console.error("Failed to load ONNX model:", e);
        if (modelReadyResolver) modelReadyResolver(false);
    }
}
initOnnxModel();

async function processPptImage(file) {
    if (!onnxSession) {
        await modelReadyPromise;
        if (!onnxSession) {
            alert("AIモデルの読み込みに失敗しました。");
            return;
        }
    }
    
    document.getElementById('mode-2p').click();

    // High Precision Logic
    const reader = new FileReader();
    reader.onload = async (e) => {
        const img = new Image();
        img.onload = async () => {
            const imgBitmap = await createImageBitmap(img);
            await runHighPrecisionAnalysis(imgBitmap);
        };
        img.src = e.target.result;
    };
    reader.readAsDataURL(file);
}

window.receiveExtensionImage = async (base64Data) => {
    try {
        const res = await fetch(base64Data);
        const blob = await res.blob();
        const file = new File([blob], "capture.jpg", { type: "image/jpeg" });
        processPptImage(file);
    } catch(e) {
        console.error("Extension image process failed", e);
    }
};

async function runHighPrecisionAnalysis(imgBitmap) {
    try {
        // 1. 前処理 (16:9 クロップ & 1920x1080 リサイズ)
        const { canvas: processedCanvas, cropData } = processImageTo1080p(imgBitmap);

        // 2. プレイヤー情報の抽出と解析
        const p1Config = {
            boardRect: { x: 304, y: 157, w: 670 - 304, h: 882 - 157 },
            nextCoords: [ {x:160, y:155}, {x:500, y:122}, {x:500, y:175}, {x:500, y:225}, {x:500, y:275}, {x:500, y:325} ]
        };
        const p2Config = {
            boardRect: { x: 1257, y: 157, w: 1620 - 1257, h: 882 - 157 },
            nextCoords: [ {x:790, y:155}, {x:1130, y:122}, {x:1130, y:175}, {x:1130, y:225}, {x:1130, y:275}, {x:1130, y:325} ]
        };

        // P1
        const p1Data = await analyzePlayerHighPrecision(processedCanvas, imgBitmap, cropData, p1Config);
        editorData['p1'].board = p1Data.board;
        editorData['p1'].nextQueue = p1Data.nextQueue;
        editorData['p1'].hold = p1Data.holdMino;
        drawEditorField('p1');
        updateNextQueueDisplay('p1');

        // P2 (2Pモード時)
        if (gameMode === '2P') {
            const p2Data = await analyzePlayerHighPrecision(processedCanvas, imgBitmap, cropData, p2Config);
            editorData['p2'].board = p2Data.board;
            editorData['p2'].nextQueue = p2Data.nextQueue;
            editorData['p2'].hold = p2Data.holdMino;
            drawEditorField('p2');
            updateNextQueueDisplay('p2');
        }
        
    } catch (err) {
        console.error("High Precision Analysis Error:", err);
        alert("解析中にエラーが発生しました: " + err.message);
    }
}

function processImageTo1080p(imgBitmap) {
    const srcW = imgBitmap.width;
    const srcH = imgBitmap.height;
    const targetAspect = 16 / 9;
    const srcAspect = srcW / srcH;
    let cropW, cropH, cropX, cropY;

    if (srcAspect > targetAspect) {
        cropH = srcH;
        cropW = srcH * targetAspect;
        cropX = (srcW - cropW) / 2;
        cropY = 0;
    } else {
        cropW = srcW;
        cropH = srcW / targetAspect;
        cropX = 0;
        cropY = (srcH - cropH) / 2;
    }

    const canvas = document.createElement('canvas');
    canvas.width = 1920;
    canvas.height = 1080;
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    ctx.drawImage(imgBitmap, cropX, cropY, cropW, cropH, 0, 0, 1920, 1080);
    return { canvas, cropData: { cropX, cropY, cropW, cropH } };
}

async function analyzePlayerHighPrecision(canvas, originalBitmap, cropData, config) {
    const ctx = canvas.getContext('2d');
    const boardRect = config.boardRect;
    const boardImgData = ctx.getImageData(boardRect.x, boardRect.y, boardRect.w, boardRect.h);
    const cellW = boardRect.w / 10;
    const cellH = boardRect.h / 20;
    const recognizedBoard = []; 

    // (A) 旧ロジックによる盤面スキャン (補正用)
    const classicBoard = [];
    const blockWidthPx = cellW;
    const blockHeightPx = cellH;
    for (let r = 0; r < 20; r++) {
        const row = [];
        for (let c = 0; c < 10; c++) {
            const sampleX = boardRect.x + (c + 0.5) * blockWidthPx;
            const sampleY = boardRect.y + (r + 0.5) * blockHeightPx;
            const sampleSize = Math.max(1, Math.floor(blockWidthPx * 0.25));
            const imageData = ctx.getImageData(sampleX - sampleSize / 2, sampleY - sampleSize / 2, sampleSize, sampleSize).data;
            let avgR = 0, avgG = 0, avgB = 0;
            for (let i = 0; i < imageData.length; i += 4) {
                avgR += imageData[i];
                avgG += imageData[i+1]; avgB += imageData[i+2];
            }
            const pixelCount = imageData.length / 4;
            avgR /= pixelCount; avgG /= pixelCount; avgB /= pixelCount;
            row.push(findClosestColor(avgR, avgG, avgB));
        }
        classicBoard.push(row);
    }

    // (B) ONNX 特徴量抽出と推論
    const batchFeatures = [];
    for (let r = 0; r < 20; r++) {
        const row = [];
        for (let c = 0; c < 10; c++) {
            const x = c * cellW;
            const y = r * cellH;
            const cellPixels = extractCellPixels(boardImgData, x, y, cellW, cellH);
            const feats = extractFeaturesJS(cellPixels, Math.floor(cellW), Math.floor(cellH));
            batchFeatures.push(feats);
            row.push(null);
        }
        recognizedBoard.push(row);
    }

    const flatInput = new Float32Array(batchFeatures.length * 63);
    for (let i = 0; i < batchFeatures.length; i++) {
        flatInput.set(batchFeatures[i], i * 63);
    }
    
    const tensor = new ort.Tensor('float32', flatInput, [200, 63]);
    const inputName = onnxSession.inputNames[0];
    const feeds = { [inputName]: tensor };
    const labelOutputName = onnxSession.outputNames[0]; 
    const fetches = [labelOutputName];
    const results = await onnxSession.run(feeds, fetches);
    const outputLabel = results[labelOutputName];
    const labelData = outputLabel.data;

    for (let i = 0; i < 200; i++) {
        const r = Math.floor(i / 10);
        const c = i % 10;
        const classIdx = Number(labelData[i]);
        const label = ONNX_CLASS_NAMES[classIdx];
        recognizedBoard[r][c] = (label === 'null') ? null : label;
    }

    // (C) 結果のマージ (補正処理)
    for (let r = 0; r < 20; r++) {
        const onnxRow = recognizedBoard[r];
        const isOnlyNullOrG = onnxRow.every(cell => cell === null || cell === 'G');
        if (isOnlyNullOrG) {
            const gCountOnnx = onnxRow.filter(cell => cell === 'G').length;
            if (gCountOnnx !== 10) {
                const classicRow = classicBoard[r];
                const gCountClassic = classicRow.filter(cell => cell === 'G').length;
                const nullCountClassic = classicRow.filter(cell => cell === null).length;
                if (gCountClassic === 9 && nullCountClassic === 1) {
                    recognizedBoard[r] = [...classicRow];
                }
            }
        }
    }

    // フルボード化 (40行)
    const fullBoard = Array.from({ length: 40 }, () => Array(10).fill(null));
    for(let r=0; r<20; r++) {
        fullBoard[20+r] = recognizedBoard[r];
    }

    // ガベージ・削除列処理
    let firstNonGarbageRowFromBottom = -1;
    for (let y = 39; y >= 0; y--) { if (!fullBoard[y].includes('G')) { firstNonGarbageRowFromBottom = y; break; } }
    if (firstNonGarbageRowFromBottom !== -1) { 
        for (let y = firstNonGarbageRowFromBottom - 1; y >= 0; y--) { 
            for (let x = 0; x < 10; x++) { if (fullBoard[y][x] === 'G') { fullBoard[y][x] = null; } } 
        } 
    }

    let firstEmptyRowFromBottom = -1;
    for (let y = 39; y >= 0; y--) { if (fullBoard[y].every(cell => cell === null)) { firstEmptyRowFromBottom = y; break; } }
    
    const deletedMinoColors = [];
    const pendingDeletions = [];

    if (firstEmptyRowFromBottom !== -1) {
        const limitY = 40 - 18;
        for (let y = firstEmptyRowFromBottom - 1; y >= 0; y--) {
            if (y <= limitY) {
                for (let x = 0; x < 10; x++) {
                    const piece = fullBoard[y][x];
                    if (piece && piece !== 'G') { deletedMinoColors.push(piece); }
                    if (piece) pendingDeletions.push({y, x});
                }
            }
        }
    }

    // Next/Hold スキャン
    const nextQueue = [];
    let holdMino = null;
    
    const rawCropCanvas = document.createElement('canvas');
    rawCropCanvas.width = cropData.cropW;
    rawCropCanvas.height = cropData.cropH;
    const rawCtx = rawCropCanvas.getContext('2d', { willReadFrequently: true });
    rawCtx.drawImage(originalBitmap, cropData.cropX, cropData.cropY, cropData.cropW, cropData.cropH, 0, 0, cropData.cropW, cropData.cropH);
    
    const currentScale = cropData.cropW / 1280;
    const radius = 5 * currentScale;
    
    for (let i = 0; i < config.nextCoords.length; i++) {
        const coord = config.nextCoords[i];
        const avgColor = getAverageColorNonBlack(rawCtx, coord.x * currentScale, coord.y * currentScale, radius);
        if (i === 0) {
            const isBlack = avgColor.r < 50 && avgColor.g < 50 && avgColor.b < 50;
            if (!isBlack) {
                holdMino = findClosestMinoOnly(avgColor.r, avgColor.g, avgColor.b);
            }
        } else {
            const isBlack = avgColor.r < 50 && avgColor.g < 50 && avgColor.b < 50;
            if (i === 1 && isBlack) break;
            const foundMino = findClosestMinoOnly(avgColor.r, avgColor.g, avgColor.b);
            if (foundMino) nextQueue.push(foundMino);
        }
    }

    if (deletedMinoColors.length > 0 && deletedMinoColors.every(color => color === deletedMinoColors[0])) {
        nextQueue.unshift(deletedMinoColors[0]);
        pendingDeletions.forEach(p => fullBoard[p.y][p.x] = null);
    }

    return { board: fullBoard, holdMino, nextQueue };
}

function extractCellPixels(sourceImgData, x, y, w, h) {
    const sw = sourceImgData.width;
    const ix = Math.floor(x), iy = Math.floor(y);
    const iw = Math.floor(w), ih = Math.floor(h);
    const data = new Uint8ClampedArray(iw * ih * 4);
    for (let row = 0; row < ih; row++) {
        const srcRowStart = ((iy + row) * sw + ix) * 4;
        const destRowStart = (row * iw) * 4;
        const rowPixels = sourceImgData.data.subarray(srcRowStart, srcRowStart + iw * 4);
        data.set(rowPixels, destRowStart);
    }
    return data;
}

function extractFeaturesJS(pixelsRGBA, w, h) {
    const numPixels = w * h;
    const feats = [];
    const bCh = new Float32Array(numPixels);
    const gCh = new Float32Array(numPixels);
    const rCh = new Float32Array(numPixels);
    const hCh = new Float32Array(numPixels);
    const sCh = new Float32Array(numPixels);
    const vCh = new Float32Array(numPixels);

    for (let i = 0; i < numPixels; i++) {
        const r = pixelsRGBA[i * 4];
        const g = pixelsRGBA[i * 4 + 1];
        const b = pixelsRGBA[i * 4 + 2];
        bCh[i] = b; gCh[i] = g; rCh[i] = r;
        
        const maxVal = Math.max(r, g, b);
        const minVal = Math.min(r, g, b);
        const diff = maxVal - minVal;
        const v = maxVal;
        let s = (maxVal !== 0) ? (diff / maxVal) * 255 : 0;
        let h_val = 0;
        if (maxVal === minVal) h_val = 0;
        else if (maxVal === r) h_val = (60 * (g - b) / diff + 360) % 360;
        else if (maxVal === g) h_val = (60 * (b - r) / diff + 120) % 360;
        else if (maxVal === b) h_val = (60 * (r - g) / diff + 240) % 360;
        h_val = h_val / 2;
        vCh[i] = v; sCh[i] = s; hCh[i] = h_val;
    }

    const getStats = (arr) => {
        let sum = 0;
        for(let v of arr) sum += v;
        const mean = sum / arr.length;
        let sqDiffSum = 0;
        for(let v of arr) sqDiffSum += (v - mean) ** 2;
        const std = Math.sqrt(sqDiffSum / arr.length);
        return [mean, std];
    };

    const statsB = getStats(bCh); const statsG = getStats(gCh); const statsR = getStats(rCh);
    feats.push(statsB[0], statsB[1], statsG[0], statsG[1], statsR[0], statsR[1]);
    
    const statsH = getStats(hCh); const statsS = getStats(sCh); const statsV = getStats(vCh);
    feats.push(statsH[0], statsH[1], statsS[0], statsS[1], statsV[0], statsV[1]);

    const tinyFeats = [];
    const stepX = w / 4;
    const stepY = h / 4;
    for (let ty = 0; ty < 4; ty++) {
        for (let tx = 0; tx < 4; tx++) {
            const sx = Math.floor(tx * stepX), sy = Math.floor(ty * stepY);
            const ex = Math.floor((tx + 1) * stepX), ey = Math.floor((ty + 1) * stepY);
            let sumB=0, sumG=0, sumR=0, count=0;
            for(let py=sy; py<ey; py++){
                for(let px=sx; px<ex; px++){
                    const idx = py * w + px;
                    if(idx < numPixels) { sumB += bCh[idx]; sumG += gCh[idx]; sumR += rCh[idx]; count++; }
                }
            }
            if(count===0) { tinyFeats.push(0,0,0); } else { tinyFeats.push(sumB/count, sumG/count, sumR/count); }
        }
    }
    feats.push(...tinyFeats);

    const cx = Math.floor(w/2), cy = Math.floor(h/2);
    const cw = Math.floor(w/4), ch = Math.floor(h/4);
    const startX = cx - cw, endX = cx + cw;
    const startY = cy - ch, endY = cy + ch;
    let cSumB=0, cSumG=0, cSumR=0, cCount=0;
    for(let py=startY; py<endY; py++){
        for(let px=startX; px<endX; px++){
            if(px>=0 && px<w && py>=0 && py<h){
                const idx = py * w + px;
                cSumB += bCh[idx]; cSumG += gCh[idx]; cSumR += rCh[idx]; cCount++;
            }
        }
    }
    if(cCount===0) feats.push(0,0,0); else feats.push(cSumB/cCount, cSumG/cCount, cSumR/cCount);

    return new Float32Array(feats);
}

function boardToString(board) {
    return board.map(row => 
        row.map(cell => cell === null ? '_' : cell).join('')
    ).join('');
}

function stringToBoard(str) {
    const board = [];
    if (!str || str.length !== BOARD_WIDTH * BOARD_HEIGHT) {
        console.error('Invalid board string length. Returning empty board.');
        return Array.from({ length: BOARD_HEIGHT }, () => Array(BOARD_WIDTH).fill(null));
    }
    for (let i = 0; i < BOARD_HEIGHT; i++) {
        const rowStr = str.substring(i * BOARD_WIDTH, (i + 1) * BOARD_WIDTH);
        const row = rowStr.split('').map(char => (char === '_') ? null : char);
        board.push(row);
    }
    return board;
}

// --- 圧縮ロジック (RLE & 差分) ---
const RLE_EQUAL_CHAR = 'E';

/**
 * 1次元配列をランレングス圧縮する
 * @param {Array<string>} data - 1次元配列 ('_' または 'E' を含む)
 * @returns {Array<[string, number]>} 圧縮データ [[value, count], ...]
 */
function encodeRLE(data) {
    if (!data || data.length === 0) return [];
    const rle = [];
    let lastValue = data[0];
    let count = 1;
    for (let i = 1; i < data.length; i++) {
        const currentValue = data[i];
        if (currentValue === lastValue) {
            count++;
        } else {
            rle.push([lastValue, count]);
            lastValue = currentValue;
            count = 1;
        }
    }
    rle.push([lastValue, count]); // 最後のデータを追加
    return rle;
}

/**
 * 2つの1次元配列ボードデータの差分を取得する
 * 'E' (Equal) は変更なしを示す
 * @param {Array<string>} prevBoard1D - 前のボード (1D, '_'含む)
 * @param {Array<string>} currentBoard1D - 現在のボード (1D, '_'含む)
 * @returns {Array<string>} 差分データ (1D)
 */
function getDifference(prevBoard1D, currentBoard1D) {
    const diff = [];
    const len = BOARD_WIDTH * BOARD_HEIGHT;
    for (let i = 0; i < len; i++) {
        const prev = prevBoard1D[i];
        const curr = currentBoard1D[i];

        if (prev === curr) {
            diff.push(RLE_EQUAL_CHAR); // 'E' (Equal) 変更なし
        } else {
            diff.push(curr); // 変更後の値 (例: '_', 'I', 'O'...)
        }
    }
    return diff;
}

let autoStartParams = { ss: false, nh: false, hb: false };

function getGameStateForExport(options = {}) {
    const p1Data = { ...editorData.p1, nextQueue: [...editorData.p1.nextQueue] };
    const p2Data = gameMode === '2P' ? { ...editorData.p2, nextQueue: [...editorData.p2.nextQueue] } : null;
    if (options.noHold) {
        if (p1Data.hold) { p1Data.nextQueue.unshift(p1Data.hold); p1Data.hold = null; }
        if (p2Data && p2Data.hold) { p2Data.nextQueue.unshift(p2Data.hold); p2Data.hold = null; }
    }

    const data = {
        v: 2, m: gameMode,
        p1: { b: boardToString(p1Data.board), n: p1Data.nextQueue.join(''), h: p1Data.hold || '' }
    };
if (gameMode === '2P') {
        data.p2 = { b: boardToString(p2Data.board), n: p2Data.nextQueue.join(''), h: p2Data.hold || '' };
    }
    if (options.startSim) data.ss = 1;
    if (options.noHold) data.nh = 1;
    if (options.hideBack) data.hb = 1;
    
    if (editorData.rule.description) data.rd = editorData.rule.description;
    if (editorData.rule.code) data.rc = editorData.rule.code;
    return data;
}
function applyGameState(data) {
    try {
        if (!data || (data.v !== 1 && data.v !== 2)) {
            alert('無効または非対応のデータです。');
return false;
        }
        gameMode = data.m || '1P';
        document.getElementById('mode-1p').classList.toggle('active', gameMode === '1P');
document.getElementById('mode-2p').classList.toggle('active', gameMode === '2P');
        document.getElementById('p2-editor-col').style.display = (gameMode === '2P') ? 'flex' : 'none';
        document.getElementById('swapBtn').style.display = (gameMode === '2P') ? 'inline-block' : 'none';
        
        editorData.rule.description = data.rd || '';
editorData.rule.code = data.rc || '';

        if (data.p1) {
            editorData.p1.board = stringToBoard(data.p1.b);
            editorData.p1.nextQueue = data.p1.n ? data.p1.n.split('') : [];
            editorData.p1.hold = data.p1.h || null;
            drawEditorField('p1'); updateNextQueueDisplay('p1');
        }
        if (gameMode === '2P' && data.p2) {
            editorData.p2.board = stringToBoard(data.p2.b);
            editorData.p2.nextQueue = data.p2.n ? data.p2.n.split('') : [];
            editorData.p2.hold = data.p2.h || null;
            drawEditorField('p2'); updateNextQueueDisplay('p2');
        } else if (gameMode !== '2P') {
            editorData.p2.board = Array.from({ length: BOARD_HEIGHT }, () => Array(BOARD_WIDTH).fill(null));
            editorData.p2.nextQueue = [];
            editorData.p2.hold = null;
            if (document.getElementById('p2-editor-col').style.display !== 'none') {
                 drawEditorField('p2'); updateNextQueueDisplay('p2');
            }
        }
        updateScale(); return true;
    } catch (e) {
        console.error('Failed to apply game state:', e); alert('データの読み込みに失敗しました。'); return false;
    }
}

function loadStateFromURL() {
    if (window.location.hash) {
        try {
            const base64Data = window.location.hash.substring(1);
            const binaryString = atob(base64Data);
            const bytes = Uint8Array.from(binaryString, c => c.charCodeAt(0));
            const jsonString = new TextDecoder().decode(bytes);
            const data = JSON.parse(jsonString);

            autoStartParams.ss = !!data.ss;
            autoStartParams.nh = !!data.nh;
            autoStartParams.hb = !!data.hb;

            if (applyGameState(data)) {
                //alert('URLから盤面を読み込みました。');
                if (autoStartParams.ss) {
                    setTimeout(() => document.getElementById('startGameBtn').click(), 100);
                }
            }
            history.pushState("", document.title, window.location.pathname + window.location.search);
        } catch (e) {
            console.error('Failed to load state from URL hash:', e);
            alert('URLからのデータ読み込みに失敗しました。');
            history.pushState("", document.title, window.location.pathname + window.location.search);
        }
    }
}


function generateAndDisplayLink(options = {}) {
    const stateData = getGameStateForExport(options);
    const jsonString = JSON.stringify(stateData);
    const uint8Array = new TextEncoder().encode(jsonString);
    const base64Data = btoa(String.fromCharCode.apply(null, uint8Array));
    const url = new URL(window.location);
    url.hash = base64Data;
    document.getElementById('share-link-input').value = url.href;
}

function openShareModal() {
    generateAndDisplayLink();
    document.getElementById('advanced-link-options').style.display = 'none';
    document.getElementById('share-modal').style.display = 'flex';
}
function pollGamepads() {
    const rawPads = navigator.getGamepads();
    if (!rawPads) return;

    for (let i = 0; i < rawPads.length; i++) {
        const pad = rawPads[i];
        if (!pad) {
            delete gamepads[i];
            delete prevGamepads[i];
            continue;
        };

        gamepads[i] = { buttons: pad.buttons.map(b => b.pressed), axes: [...pad.axes] };

        if (isBindingKey) {
            if (prevGamepads[i]) {
                for (let j = 0; j < pad.buttons.length; j++) {
                    if (gamepads[i].buttons[j] && !prevGamepads[i].buttons[j]) {
                        bindKey({ type: 'pad_button', value: j, label: `Pad${i}-Btn${j}` });
                        return;
                    }
                }
                for (let j = 0; j < pad.axes.length; j++) {
                    const val = gamepads[i].axes[j], prevVal = prevGamepads[i].axes[j];
                    if (Math.abs(val) > AXIS_THRESHOLD && Math.abs(prevVal) < AXIS_THRESHOLD) {
                        const dir = val > 0 ? '+' : '-';
                        bindKey({ type: 'pad_axis', value: `${j}${dir}`, label: `Pad${i}-Axis${j}${dir}` });
                        return;
                    }
                }
            }
        } else if (gameState === 'PLAYING') {
             players.forEach(p => {
                if(p.padIndex === i) {
                    Object.keys(p.keyBindings).forEach(action => {
                        const binding = p.keyBindings[action];
                        if (binding.type === 'pad_button' && gamepads[i].buttons[binding.value] && !prevGamepads[i]?.buttons[binding.value]) {
                           p.handlePress(action);
                        } 
                        else if (binding.type === 'pad_axis') {
                            const [axis, dir] = [parseInt(binding.value[0]), binding.value[1]];
                            const val = gamepads[i].axes[axis];
                            const prevVal = prevGamepads[i] ? prevGamepads[i].axes[axis] : 0;
                            const threshold = AXIS_THRESHOLD;
                            if (dir === '+' && val > threshold && prevVal < threshold) {
                                p.handlePress(action);
                            } else if (dir === '-' && val < -threshold && prevVal > -threshold) {
                                p.handlePress(action);
                            }
                        }
                    });
                }
            });
        }
    }
    Object.keys(gamepads).forEach(i => {
        prevGamepads[i] = { buttons: [...gamepads[i].buttons], axes: [...gamepads[i].axes] };
    });
}


let lastAnalysisSample = 0;
function gameLoop(currentTime) {
    if (!ctx) return;
    pollGamepads();
    const dt = currentTime - lastTime;
    lastTime = currentTime;
    ctx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
    if (gameState === 'PLAYING') {
        // ここにあった画像描画処理を削除しました
        
        players.forEach(p => p.update(dt || 0));
        players.forEach(p => p.draw());

        // 分析用データサンプリング (約200ms毎)
        if (currentTime - lastAnalysisSample > 200 && players.length > 0) {
            const countBlocks = (board) => {
                let c = 0;
                for(let y=0; y<board.length; y++) for(let x=0; x<board[y].length; x++) if(board[y][x]!==null) c++;
                return c;
            };
            const sample = {
                time: currentTime - gameStartTime,
                type: 'resource',
                p1_R: countBlocks(players[0].board),
                p2_R: players[1] ? countBlocks(players[1].board) : 0
            };
            analysisData.push(sample);
            lastAnalysisSample = currentTime;
        }

    } else if (gameState.startsWith('SCAN')) {
        drawScanner();
    }
    requestAnimationFrame(gameLoop);
}

const mainContainer = document.querySelector('.main-container');

function updateScale() {
    if (gameState.startsWith('SCAN')) {
        mainContainer.style.transform = '';
        return;
    }

    mainContainer.style.transform = 'none';

    const rect = mainContainer.getBoundingClientRect();
    const nativeWidth = rect.width;
    const nativeHeight = rect.height;
    
    if (nativeWidth === 0 || nativeHeight === 0) {
        mainContainer.style.transform = '';
        return;
    }

        const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    const scale = Math.min(
        viewportWidth / nativeWidth,
        viewportHeight / nativeHeight
    ) * 0.98;
    mainContainer.style.transform = `scale(${scale})`;
}

document.addEventListener('DOMContentLoaded', () => {
    const modeTitle = document.querySelector('.mode-selection h2');
    let debugClickCount = 0;
    let debugClickTimer = null;

    if (modeTitle) {
        modeTitle.style.userSelect = 'none'; 
        
        modeTitle.addEventListener('click', () => {
            debugClickCount++;
            
            if (debugClickTimer) clearTimeout(debugClickTimer);
            debugClickTimer = setTimeout(() => { debugClickCount = 0; }, 400);

            if (debugClickCount >= 10) {
                gameSettings.debugEnabled = !gameSettings.debugEnabled;
                alert(`デバッグモード: ${gameSettings.debugEnabled ? "ON" : "OFF"}`);
                debugClickCount = 0;
                
                const aiDebugDisplay = document.getElementById('ai-tree-debug-display');
                if (aiDebugDisplay) {
                    aiDebugDisplay.style.display = gameSettings.debugEnabled ? 'block' : 'none';
                }
            }
        });
    }

    mainCanvas = document.getElementById('mainCanvas'); ctx = mainCanvas.getContext('2d');
    
    aiWorkerBlob = new Blob([aiWorkerScript], { type: 'application/javascript' });
    
    virtualController.init();

    loadKeyBindings();
    loadGameSettings();

    if (loadSkinsFromLocalStorage()) {
        console.log('Custom skins loaded from localStorage.');
    }

    document.getElementById('shareBtn').addEventListener('click', openShareModal);
    document.getElementById('share-close').addEventListener('click', () => {
        document.getElementById('share-modal').style.display = 'none';
    });

    document.getElementById('ruleBtn').addEventListener('click', () => {
        document.getElementById('rule-description-input').value = editorData.rule.description;
        document.getElementById('rule-code-input').value = editorData.rule.code;
        document.getElementById('rule-modal').style.display = 'flex';
    });
    document.getElementById('rule-save-close').addEventListener('click', () => {
        editorData.rule.description = document.getElementById('rule-description-input').value;
editorData.rule.code = document.getElementById('rule-code-input').value;
        document.getElementById('rule-modal').style.display = 'none';
    });
    document.getElementById('rule-close').addEventListener('click', () => {
        document.getElementById('rule-modal').style.display = 'none';
    });

    document.getElementById('swapBtn').addEventListener('click', () => {
        if (gameMode !== '2P') return;
        
        const tempBoard = editorData.p1.board;
        const tempNext = editorData.p1.nextQueue;
        const tempHold = editorData.p1.hold;
        const tempNextInsertion = editorData.p1.nextInsertionIndex;

        editorData.p1.board = editorData.p2.board;
        editorData.p1.nextQueue = editorData.p2.nextQueue;
        editorData.p1.hold = editorData.p2.hold;
        editorData.p1.nextInsertionIndex = editorData.p2.nextInsertionIndex;

        editorData.p2.board = tempBoard;
        editorData.p2.nextQueue = tempNext;
        editorData.p2.hold = tempHold;
        editorData.p2.nextInsertionIndex = tempNextInsertion;

        drawEditorField('p1');
        updateNextQueueDisplay('p1');
        drawEditorField('p2');
        updateNextQueueDisplay('p2');
    });

document.getElementById('copy-link-btn').addEventListener('click', () => {
        const input = document.getElementById('share-link-input');
        input.select();
        navigator.clipboard.writeText(input.value)
            .then(() => alert('共有リンクをクリップボードにコピーしました！'))
            .catch(err => alert('コピーに失敗しました: ' + err));
    });
    


        document.getElementById('import-from-data-btn').addEventListener('click', async () => {
        try {
            const text = await navigator.clipboard.readText();
            if (!text) {
                alert('クリップボードが空です。');
                return;
            }

            let data;

                if (text.startsWith('http') && text.includes('#')) {
                const base64Data = text.substring(text.indexOf('#') + 1);
                const binaryString = atob(base64Data);
                const bytes = Uint8Array.from(binaryString, c => c.charCodeAt(0));
                const jsonString = new TextDecoder().decode(bytes);
                data = JSON.parse(jsonString);
            } else {
                data = JSON.parse(text);
            }
            
            if(applyGameState(data)) {
                 alert('クリップボードから盤面を読み込みました。');
                 document.getElementById('share-modal').style.display = 'none';
            }

        } catch (e) {
            alert('クリップボードのデータが無効か、読み込みに失敗しました。');
            console.error('Failed to import from clipboard:', e);
        }
    });
document.getElementById('mode-1p').addEventListener('click', () => { 
        gameMode = '1P'; 
        document.getElementById('mode-1p').classList.add('active'); 
        document.getElementById('mode-2p').classList.remove('active'); 
        document.getElementById('p2-editor-col').style.display = 'none'; 
        document.getElementById('swapBtn').style.display = 'none';
        setTimeout(updateScale, 0);
    });
document.getElementById('mode-2p').addEventListener('click', () => { 
        gameMode = '2P'; 
        document.getElementById('mode-2p').classList.add('active'); 
        document.getElementById('mode-1p').classList.remove('active'); 
        document.getElementById('p2-editor-col').style.display = 'flex';
        document.getElementById('swapBtn').style.display = 'inline-block';
        setTimeout(updateScale, 0);
    });
document.getElementById('advanced-link-btn').addEventListener('click', () => {
        document.getElementById('advanced-link-options').style.display = 'block';
    });
    
    const startSimCheckbox = document.getElementById('start-sim-checkbox');
    const hideBackCheckbox = document.getElementById('hide-back-btn-checkbox');
    startSimCheckbox.addEventListener('change', () => {
        if (startSimCheckbox.checked) {
            hideBackCheckbox.disabled = false;
        } else {
            hideBackCheckbox.disabled = true;
            hideBackCheckbox.checked = false;
        }
    });

    document.getElementById('generate-advanced-link-btn').addEventListener('click', () => {
        generateAndDisplayLink({
            startSim: document.getElementById('start-sim-checkbox').checked,
            noHold: document.getElementById('no-hold-checkbox').checked,
            hideBack: document.getElementById('hide-back-btn-checkbox').checked
        });
    });
document.getElementById('startGameBtn').addEventListener('click', () => {
        gameHistoryLog = [];
        let currentRunSettings = { ...gameSettings };
        gameStartTime = performance.now();
        let startTime = gameStartTime;
        
        players = [];
        const p1_isAi = document.getElementById('p1-ai-toggle').checked;
        const p2_isAi = document.getElementById('p2-ai-toggle').checked;
        
        if (gameMode === '1P') {
          
           const player = new Player('1', 0, keyBindings.p1, 0, p1_isAi);
            player.holdDisabled = autoStartParams.nh;
            players.push(player);
        } else {
            const p1 = new Player('1', 0, keyBindings.p1, 0, p1_isAi);
            p1.holdDisabled = autoStartParams.nh;
            const p2 = new Player('2', PLAYER_CANVAS_WIDTH, keyBindings.p2, 1, p2_isAi);
            p2.holdDisabled = autoStartParams.nh;
      
            p1.opponent = p2;
            p2.opponent = p1;
            players.push(p1, p2);
        }

        logCurrentGameState();

        if (editorData.rule.code) {
 try {
        const ruleWorkerScript = `
                    let userFunctions = {};
let startTime = 0;
                    let playerStates = {
                        '1': { board: [], holdPiece: null, currentPiece: null, nextQueue: [], fullMinoSequence: [], stats: {} },
                        '2': { board: [], holdPiece: null, currentPiece: null, nextQueue: [], fullMinoSequence: [], stats: {} }
                    };
const createBoardAPI = (playerId) => ({
                        hasBlock: (x, y) => {
                            const board = playerStates[playerId]?.board;
                            if (!board || y < 0 || y 
>= board.length || x < 0 || x >= (board[0] || []).length) {
                                return false;
                            }
                           
 return board[y][x] !== null;
                        },
                        placeBlock: (x, y, type) => {
                            postMessage({ command: 'api', func: 'placeBlock', args: [playerId, x, y, type] });
     
                   }
                    });
const api = {
                        win: (playerProxy) => postMessage({ command: 'api', func: 'win', args: [playerProxy.id] }),
                        lose: (playerProxy) => postMessage({ command: 'api', func: 'lose', args: [playerProxy.id] }),
                        setCustomUIText: 
(playerProxy, text) => postMessage({ 
command: 'api', func: 'setCustomUIText', args: [playerProxy.id, text] }),
                        getTime: () => performance.now() - startTime,
                        sendAttack: (receivingPlayerProxy, lines) => postMessage({ command: 'api', func: 'sendAttack', args: [receivingPlayerProxy.id, lines] }),
forceSetting: (key, value) => postMessage({ command: 'api', func: 'forceSetting', args: [key, value] }),
                
        displayGhostBlock: (playerProxy, x, y, type) => postMessage({ command: 'api', func: 'displayGhostBlock', args: [playerProxy.id, x, y, type] }),
                        clearAllGhostBlocks: (playerProxy) => postMessage({ command: 'api', func: 'clearAllGhostBlocks', args: [playerProxy.id] }),
         getPiece: (playerProxy, type, index = 0) => {
                          
  const state = playerStates[playerProxy.id];
                            if (!state) return null;
                            if (type === 'hold') return state.holdPiece;
if (type === 'next') {
                                if (index === 0) return state.currentPiece;
                                return state.nextQueue[index - 1] || null;
                            }
                            return null;
},
                        getFullSequence: (playerProxy) => {
                            const state = playerStates[playerProxy.id];
return state ? [...state.fullMinoSequence] : [];
},
                        setPiece: (playerProxy, type, piece, index) => postMessage({ command: 'api', func: 'setPiece', args: [playerProxy.id, type, piece, index] }),
                    };
self.onmessage = (e) => {
                        const { command, data } = e.data;
                        if (data && data.playerStateProxy) {
                            const { id, board, holdPiece, currentPiece, nextQueue, fullMinoSequence, stats } = data.playerStateProxy;
if (playerStates[id]) {
                                playerStates[id] = { id, board, holdPiece, currentPiece, nextQueue, fullMinoSequence, stats };
}
                        }

if (command === 'init') {
                            if (data.initialPlayerState) {
                                const { id, board, holdPiece, currentPiece, nextQueue, fullMinoSequence, stats } = data.initialPlayerState;
                                if (playerStates[id]) {
                                    playerStates[id] = { id, board, holdPiece, currentPiece, nextQueue, fullMinoSequence, stats };
                                }
                            }
                            startTime = data.startTime;
const p1Proxy = { id: '1', board: createBoardAPI('1') };
                            const p2Proxy = data.is2P ? { id: '2', board: createBoardAPI('2') } : null;
const gameApiProxy = { p1: p1Proxy, p2: p2Proxy, ...api };
const combinedCode = data.ruleCode + \`
                                return {
                                    onInit: typeof onInit === 'function' ?
onInit : undefined,
                                    onPieceLock: typeof onPieceLock === 'function' ?
onPieceLock : undefined,
                                    onUpdate: typeof onUpdate === 'function' ?
onUpdate : undefined
                                };\`;
const ruleScript = new Function('api', combinedCode);
                            userFunctions = ruleScript(gameApiProxy);
                            const availableHooks = {};
if (userFunctions.onInit) {
                                availableHooks.onInit = true;
userFunctions.onInit(gameApiProxy);
                            }
                            if (userFunctions.onUpdate) availableHooks.onUpdate = true;
if (userFunctions.onPieceLock) availableHooks.onPieceLock = true;
                            postMessage({ command: 'hooksAvailable', hooks: availableHooks });
} else if ((command === 'pieceLock' && userFunctions.onPieceLock) || (command === 'update' && userFunctions.onUpdate)) {
                            const p1Proxy = { id: '1', board: createBoardAPI('1'), stats: playerStates['1'].stats };
const p2Proxy = data.is2P ? { id: '2', board: createBoardAPI('2'), stats: playerStates['2'].stats } : null;
if (p1Proxy && p2Proxy) {
                                p1Proxy.opponent = p2Proxy;
                                p2Proxy.opponent = p1Proxy;
                            }
                            const gameApiProxy = { p1: p1Proxy, p2: p2Proxy, ...api };
                            const playerProxy = data.playerStateProxy.id === '1' ? p1Proxy : p2Proxy;

if (command === 'pieceLock') {
                                userFunctions.onPieceLock(gameApiProxy, playerProxy, data.moveInfo);
                                postMessage({ command: 'hookComplete', hook: 'pieceLock' });
} else {
                                userFunctions.onUpdate(gameApiProxy, playerProxy);
}
}
};
`;

                const ruleWorkerBlob = new Blob([ruleWorkerScript], { type: 'application/javascript' });

                players.forEach(p => {
                    p.ruleWorker = new Worker(URL.createObjectURL(ruleWorkerBlob));
                    p.ruleWorker.onmessage = (e) => {
                        const { command, func, args, hooks } = e.data;


                        if (command === 'api') {
                            const getPlayerById = (id) => players.find(player => player.id === id); // Define once

                     switch(func) {

                                case 'win': getPlayerById(args[0])?.win(); break;
                                case 'lose': getPlayerById(args[0])?.lose(); break;

                        case 'setCustomUIText': getPlayerById(args[0])?.setCustomUIText(args[1]); break;


                                case 'sendAttack':
                                    const targetPlayer = getPlayerById(args[0]);

                                   if (targetPlayer) {
                                        targetPlayer.garbageQueue.push({

                                     lines: args[1],
                                            receivedTime: performance.now()

                                });
                                    }
                                    break;
                        case 'forceSetting':
                                    if (args[0] in currentRunSettings) currentRunSettings[args[0]] = args[1];
                                break;
                                case 'displayGhostBlock': getPlayerById(args[0])?.displayGhostBlock(args[1], args[2], args[3]); break;
                                case 'clearAllGhostBlocks': getPlayerById(args[0])?.clearAllGhostBlocks(); break;
                                case 'setPiece': getPlayerById(args[0])?.setPiece(args[1], args[2], args[3]); break;
                        case 'placeBlock': getPlayerById(args[0])?.placeBlock(args[1], args[2], args[3]); break;
                            }
                        } else if (command === 'hooksAvailable') {
                            p.activeRuleHooks = hooks;
if(hooks.onInit){
                                Object.assign(gameSettings, currentRunSettings);
}
                        } else if (command === 'hookComplete' && e.data.hook === 'pieceLock') {
                            p.finishLockPiece();
                        }
                    };
                    const initialStateProxy = {
                        id: p.id,
                        board: p.board,
                        holdPiece: p.holdPiece,
                        currentPiece: p.player.pieceType,
                        nextQueue: p.nextQueue,
                        fullMinoSequence: p.fullMinoSequence,
                        stats: p.stats
                    };
p.ruleWorker.postMessage({
                        command: 'init',
                        data: {
                            ruleCode: editorData.rule.code,
                     
       startTime: startTime,
                            is2P: gameMode === '2P',
                            initialPlayerState: initialStateProxy
                        }
                    });
});
            } catch (e) {
                alert('カスタムルールWorkerの生成中にエラーが発生しました:\n' + e.message);
                console.error("Custom rule worker error:", e);
                return;
            }
        }
        
                const originalSettingsBeforeRun = { ...gameSettings };
        if(!editorData.rule.code) {
             Object.assign(gameSettings, currentRunSettings);
        }

        // --- 追加: 背景画像の設定 ---
        if (gameSettings.layout && gameSettings.layout.backgroundImage) {
            // bodyに背景画像を設定して全画面表示にする
            document.body.style.backgroundImage = `url(${gameSettings.layout.backgroundImage})`;
            document.body.style.backgroundSize = 'cover';
            document.body.style.backgroundPosition = 'center center';
            document.body.style.backgroundRepeat = 'no-repeat';
            
            // キャンバスの枠線と背景を消す
            mainCanvas.style.border = 'none';
            mainCanvas.style.backgroundColor = 'transparent';
            mainCanvas.style.boxShadow = 'none';
        } else {
            // 背景がない場合はデフォルトに戻す（念のため）
            document.body.style.backgroundImage = '';
            mainCanvas.style.border = ''; // CSSの定義に戻す
            mainCanvas.style.backgroundColor = ''; // CSSの定義に戻す
            mainCanvas.style.boxShadow = '';
        }
        // ---------------------------

        gameState = 'PLAYING'; 
        document.getElementById('editor-container').style.display = 'none'; 
        document.getElementById('game-container').style.display = 'block';
        document.getElementById('scan-controls').style.display = 'none';
        document.getElementById('game-controls').style.display = 'flex';
const ruleDescDisplay = document.getElementById('rule-description-display');
        if (editorData.rule.description) {
            ruleDescDisplay.innerText = editorData.rule.description;
ruleDescDisplay.style.display = 'block';
            const p1OffsetX = 0;
            const leftPos = p1OffsetX + PADDING;
            const topPos = 160; 
            ruleDescDisplay.style.left = `${leftPos}px`;
ruleDescDisplay.style.top = `${topPos}px`;
            ruleDescDisplay.style.maxWidth = `${HOLD_AREA_WIDTH - PADDING}px`;
        } else {
            ruleDescDisplay.style.display = 'none';
}
        
        if (autoStartParams.hb) {
            document.getElementById('backToEditorBtn').style.display = 'none';
} else {
            document.getElementById('backToEditorBtn').style.display = '';
}

        ctx.setTransform(1, 0, 0, 1, 0, 0);

        if (gameMode === '1P') {
            mainCanvas.width = PLAYER_CANVAS_WIDTH * RESOLUTION_SCALE;
mainCanvas.height = CANVAS_HEIGHT * RESOLUTION_SCALE;
            mainCanvas.style.width = PLAYER_CANVAS_WIDTH + 'px';
            mainCanvas.style.height = CANVAS_HEIGHT + 'px';
}
        else {
            const totalWidth = PLAYER_CANVAS_WIDTH * 2;
mainCanvas.width = totalWidth * RESOLUTION_SCALE; 
            mainCanvas.height = CANVAS_HEIGHT * RESOLUTION_SCALE;
            mainCanvas.style.width = totalWidth + 'px';
            mainCanvas.style.height = CANVAS_HEIGHT + 'px';
        }

        
        autoStartParams = { ss: false, nh: false, hb: false };
        ctx.scale(RESOLUTION_SCALE, RESOLUTION_SCALE);

if (gameSettings.touchControlsEnabled && gameSettings.touchControlType === 'button') {
            virtualController.show();
        }

        const aiDebugDisplay = document.getElementById('ai-debug-display');
        const aiDebugControls = document.getElementById('ai-debug-controls');
        if (players.some(p => p.isAi)) {
            if(aiDebugDisplay) aiDebugDisplay.style.display = 'none';
            if(aiDebugControls) aiDebugControls.style.display = 'none';
        } else {
            if(aiDebugDisplay) aiDebugDisplay.style.display = 'none';
            if(aiDebugControls) aiDebugControls.style.display = 'none';
        }

        setTimeout(updateScale, 0);
    });


document.getElementById('backToEditorBtn').addEventListener('click', () => {
        gameState = 'EDITING';
        gameHistoryLog = [];
        
        if (players.length > 0) {            
          players.forEach(p => {
                if (p.aiWorker) {
                    p.aiWorker.terminate();
                }
                if (p.hintAiWorker) {
                    p.hintAiWorker.terminate();
                }
                if (p.ruleWorker) {
                    p.ruleWorker.terminate();
                }
            });
        }

        
        players = [];
        loadGameSettings();

        // --- 追加: 背景とキャンバススタイルのリセット ---
        document.body.style.backgroundImage = '';
        mainCanvas.style.border = ''; // CSSの定義(枠線あり)に戻す
        mainCanvas.style.backgroundColor = ''; // CSSの定義(背景色あり)に戻す
        mainCanvas.style.boxShadow = '';
        // -----------------------------------------

        document.getElementById('game-container').style.display = 'none';
        document.getElementById('game-controls').style.display = 'none';
        document.getElementById('editor-container').style.display = 'flex';
        document.getElementById('rule-description-display').style.display = 'none';
        
        virtualController.hide();
        
        const aiDebugDisplay = document.getElementById('ai-debug-display');
        const aiDebugControls = document.getElementById('ai-debug-controls');
        if(aiDebugDisplay) aiDebugDisplay.style.display = 'none';
        if(aiDebugControls) aiDebugControls.style.display = 'none';

        setTimeout(updateScale, 0);
    });
    
    ['p1', 'p2'].forEach(pId => { 
        document.getElementById(`imageLoader-${pId}`).addEventListener('change', e => { 
            if (e.target.files && e.target.files[0]) {
                startScanProcess(e.target.files[0], e.target.dataset.player);
            }
        }); 
        document.getElementById(`pptLoader-${pId}`).addEventListener('change', e => { 
            if (e.target.files && e.target.files[0]) {
                processPptImage(e.target.files[0]);
            }
        });
    });
    document.getElementById('scanCancelBtn').addEventListener('click', endScanProcess);
    document.getElementById('scanConfirmBtn').addEventListener('click', () => { if (gameState === 'SCAN_BL' && scanState.bottomLeft) gameState = 'SCAN_TR'; else if (gameState === 'SCAN_TR' && scanState.topRight) processAndLoadBoard(); updateScanUI(); });
    mainCanvas.addEventListener('click', e => { if (!gameState.startsWith('SCAN')) return; const rect = mainCanvas.getBoundingClientRect();
    const scaleX = mainCanvas.width / rect.width;
    const scaleY = mainCanvas.height / rect.height;
    const pos = { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
    if (gameState==='SCAN_BL') scanState.bottomLeft=pos; else if (gameState==='SCAN_TR') scanState.topRight=pos; updateScanUI(); });

    const getDrawCoordsFromEvent = (e) => {
        if (!players[0]) return null;
        const rect = mainCanvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const x = Math.floor(((clientX - rect.left) / rect.width) * (mainCanvas.width / RESOLUTION_SCALE) / BLOCK_SIZE - (PLAYFIELD_X_OFFSET / BLOCK_SIZE));
        const y = Math.floor(((clientY - rect.top) / rect.height) * (mainCanvas.height / RESOLUTION_SCALE) / BLOCK_SIZE - 0.5) + players[0].viewY;
        return { x, y };
    };

    const handleDrawStartOnBoard = e => {
        if (gameState !== 'PLAYING' || !gameSettings.touchControlsEnabled || gameSettings.touchControlType !== 'draw' || !players[0] || players[0].isExecutingSequence) return;
e.preventDefault();
        players[0].isDrawingOnBoard = true;
        const coords = getDrawCoordsFromEvent(e);

        if (coords && coords.x >= 0 && coords.x < BOARD_WIDTH && coords.y >= 0 && coords.y < BOARD_HEIGHT && !players[0].board[coords.y][coords.x]) {
            players[0].drawnBlocks.set(`${coords.x},${coords.y}`, true);
        }
    };

    const handleDrawMoveOnBoard = e => {
        if (gameState !== 'PLAYING' || !gameSettings.touchControlsEnabled || gameSettings.touchControlType !== 'draw' || !players[0] || !players[0].isDrawingOnBoard) return;
        e.preventDefault();
        const coords = getDrawCoordsFromEvent(e);
        if (coords && coords.x >= 0 && coords.x < BOARD_WIDTH && coords.y >= 0 && coords.y < BOARD_HEIGHT && !players[0].board[coords.y][coords.x]) {
            if (players[0].drawnBlocks.size < 4) {
                 players[0].drawnBlocks.set(`${coords.x},${coords.y}`, true);
            }
        }
    };

    const handleDrawEndOnBoard = e => {
        if (gameState !== 'PLAYING' || !gameSettings.touchControlsEnabled || gameSettings.touchControlType !== 'draw' || !players[0] || !players[0].isDrawingOnBoard) return;
        e.preventDefault();
        players[0].isDrawingOnBoard = false;
        players[0].processDrawing();
    };

    mainCanvas.addEventListener('mousedown', handleDrawStartOnBoard);
    mainCanvas.addEventListener('mousemove', handleDrawMoveOnBoard);
    mainCanvas.addEventListener('mouseup', handleDrawEndOnBoard);
    mainCanvas.addEventListener('mouseleave', handleDrawEndOnBoard);
    mainCanvas.addEventListener('touchstart', handleDrawStartOnBoard, { passive: false });
    mainCanvas.addEventListener('touchmove', handleDrawMoveOnBoard, { passive: false });
    mainCanvas.addEventListener('touchend', handleDrawEndOnBoard, { passive: false });
    mainCanvas.addEventListener('touchcancel', handleDrawEndOnBoard, { passive: false });

    document.getElementById('settingsBtn').addEventListener('click', () => openUnifiedSettingsModal('general'));
    document.getElementById('p1-key-config-btn').addEventListener('click', () => openUnifiedSettingsModal('p1-keys'));
    document.getElementById('p2-key-config-btn').addEventListener('click', () => openUnifiedSettingsModal('p2-keys'));

    document.getElementById('settings-close').addEventListener('click', () => {
        saveGameSettings();
        try { localStorage.setItem('tetrisKeyBindings', JSON.stringify(keyBindings)); } 
        catch (e) { console.error("Failed to save key bindings to localStorage:", e); }

        document.getElementById('settings-modal').style.display = 'none';
        isBindingKey = false; bindingPlayer = null; bindingAction = null;
    });

    document.getElementById('vc-edit-layout-btn').addEventListener('click', () => {
        document.getElementById('settings-modal').style.display = 'none';
        virtualController.startEditMode();
    });

    const touchModeButtons = document.querySelectorAll('#p1-touch-mode-selection .button');
        touchModeButtons.forEach(button => {
        button.addEventListener('click', () => {
            const newMode = button.dataset.touchMode;
            gameSettings.touchControlType = newMode;
            touchModeButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            document.getElementById('p1-touch-button-controls').style.display = newMode === 'button' ? 'flex' : 'none';
            document.getElementById('p1-touch-draw-controls').style.display = newMode === 'draw' ? 'flex' : 'none';
       
 });
    });

    document.getElementById('vc-save-and-close-btn').addEventListener('click', () => {

        virtualController.endEditMode();
    });
    document.getElementById('vc-copy-layout-btn').addEventListener('click', virtualController.copyLayoutsToClipboard);
    document.getElementById('vc-paste-layout-btn').addEventListener('click', virtualController.importLayoutsFromClipboard);

    document.addEventListener('keydown', e => {
        if (isBindingKey) {
            e.preventDefault();
            let keyLabel = e.key;
            if (keyLabel === ' ') keyLabel = 'Space';
            bindKey({ type: 'key', value: e.key.toLowerCase(), label: keyLabel });
        } 
        else if (gameState === 'PLAYING') {
            players.forEach(p => {
                p.keys[e.key.toLowerCase()] = true;
                Object.keys(p.keyBindings).forEach(action => {
                    const binding = p.keyBindings[action];
                    if (binding.type === 'key' && binding.value === e.key.toLowerCase()) {
                        p.handlePress(action);
                    }
                });
            });
        }
    });
    document.addEventListener('keyup', e => {
        if (gameState === 'PLAYING') {
            players.forEach(p => p.keys[e.key.toLowerCase()] = false );
        }
    });

    const manifest = {
        "name": "Tetris Simulator", "short_name": "TetrisSim", "start_url": ".",
        "display": "standalone", "background_color": "#1a1a2e", "theme_color": "#1a1a2e",
        "description": "A Tetris simulator with a 2-player mode and a powerful board editor.",
    "icons": [
        { "src": "https://raw.githubusercontent.com/selmtoe/Tetris_Simulator/main/icons/icon-192x192.png", "type": "image/png", "sizes": "192x192" },
        { "src": "https://raw.githubusercontent.com/selmtoe/Tetris_Simulator/main/icons/icon-512x512.png", "type": "image/png", "sizes": "512x512" }
    ]
    };
    const manifestURL = 'data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(manifest))));
    document.getElementById('manifest-link').setAttribute('href', manifestURL);
    if ('serviceWorker' in navigator) {
        const swCode = `
            const CACHE_NAME = 'tetris-sim-cache-v1';
            self.addEventListener('install', event => {
                event.waitUntil(
                    caches.open(CACHE_NAME).then(cache => {
                        return cache.add(location.pathname);
                    })
                );
            });
            self.addEventListener('fetch', event => {
                event.respondWith(
                    caches.match(event.request).then(response => {
                        return response || fetch(event.request);
                    })
                );
            });
        `;
        const blob = new Blob([swCode], { type: 'application/javascript' });
        navigator.serviceWorker.register(URL.createObjectURL(blob))
            .then(reg => console.log('Service Worker registered successfully.'))
            .catch(err => console.error('Service Worker registration failed:', err));
}
    
document.getElementById('retryBtn').addEventListener('click', () => {
        if (gameState !== 'PLAYING' || !players.length) return;
        
            players.forEach(p => {
            if (p.aiWorker) {
                p.aiWorker.terminate();
            }
            if (p.hintAiWorker) {
                p.hintAiWorker.terminate();
            }
            
            if (p.ruleWorker) {
                p.ruleWorker.terminate();
            }
        });


        loadGameSettings();
        gameHistoryLog = [];
     
        let currentRunSettings = { ...gameSettings };
        gameStartTime = performance.now();
        let startTime = gameStartTime;
        const wasHoldDisabled = players[0].holdDisabled;

        players = [];
        const p1_isAi_retry 
= document.getElementById('p1-ai-toggle').checked;
        const p2_isAi_retry = document.getElementById('p2-ai-toggle').checked;

        if (gameMode === '1P') {
            const player = new Player('1', 0, keyBindings.p1, 0, p1_isAi_retry);
            player.holdDisabled = wasHoldDisabled;
            players.push(player);
        } else {
         
   const p1 = new Player('1', 0, keyBindings.p1, 0, p1_isAi_retry);
            p1.holdDisabled = wasHoldDisabled;
const p2 = new Player('2', PLAYER_CANVAS_WIDTH, keyBindings.p2, 1, p2_isAi_retry);
            p2.holdDisabled = wasHoldDisabled;
            p1.opponent = p2;
            p2.opponent = p1;
            players.push(p1, p2);
}
        
        logCurrentGameState();
        
        if (editorData.rule.code) {
             const ruleWorkerScript = `
                    let userFunctions = {};
let startTime = 0;
                    let playerStates = {
                        '1': { board: [], holdPiece: null, currentPiece: null, nextQueue: [], fullMinoSequence: [], stats: {} },
                        '2': { board: [], holdPiece: null, currentPiece: null, nextQueue: [], fullMinoSequence: [], stats: {} }
                 
   };
const createBoardAPI = (playerId) => ({
                        hasBlock: (x, y) => {
                            const board = playerStates[playerId]?.board;
                            if (!board || y 
< 0 || y 
>= board.length || x < 0 || x >= (board[0] || []).length) {
                                return false;
                            }
                       
    
 return board[y][x] !== null;
                        },
                        placeBlock: (x, y, type) => {
                            postMessage({ command: 'api', func: 'placeBlock', args: [playerId, x, y, type] });
 
    
                   }
                    });
const api = {
                        win: (playerProxy) => postMessage({ command: 'api', func: 'win', args: [playerProxy.id] }),
                        lose: (playerProxy) => postMessage({ command: 'api', func: 'lose', args: [playerProxy.id] }),
                        setCustomUIText: 
(playerProxy, text) => postMessage({ 

command: 'api', func: 'setCustomUIText', args: [playerProxy.id, text] }),
                        getTime: () => performance.now() - startTime,
                        sendAttack: (receivingPlayerProxy, lines) => postMessage({ command: 'api', func: 'sendAttack', args: [receivingPlayerProxy.id, lines] }),
forceSetting: (key, value) => postMessage({ command: 'api', func: 'forceSetting', args: [key, value] }),
                

        displayGhostBlock: (playerProxy, x, y, type) => postMessage({ command: 'api', func: 'displayGhostBlock', args: [playerProxy.id, x, y, type] }),
                        clearAllGhostBlocks: (playerProxy) => postMessage({ command: 'api', func: 'clearAllGhostBlocks', args: [playerProxy.id] }),
         getPiece: (playerProxy, type, index = 0) => {
                          

  const state = playerStates[playerProxy.id];
                            if (!state) return null;
                            if (type === 'hold') return state.holdPiece;
if (type === 'next') {
                                if (index === 0) return state.currentPiece;
return state.nextQueue[index - 1] || null;
                            }
                            return null;
},
                        getFullSequence: (playerProxy) => {
                            const state = playerStates[playerProxy.id];
return state ? [...state.fullMinoSequence] : [];
},
                        setPiece: (playerProxy, type, piece, index) => postMessage({ command: 'api', func: 'setPiece', args: [playerProxy.id, type, piece, index] }),
                    };
self.onmessage = (e) => {
                        const { command, data } = e.data;
if (data && data.playerStateProxy) {
                            const { id, board, holdPiece, currentPiece, nextQueue, fullMinoSequence, stats } = data.playerStateProxy;
if (playerStates[id]) {
                                playerStates[id] = { id, board, holdPiece, currentPiece, nextQueue, fullMinoSequence, stats };
}
                        }

if (command === 'init') {
                            if (data.initialPlayerState) {
                                const { id, board, holdPiece, currentPiece, nextQueue, fullMinoSequence, stats } = data.initialPlayerState;
                                if (playerStates[id]) {
                                    playerStates[id] = { id, board, holdPiece, currentPiece, nextQueue, fullMinoSequence, stats };
                                }
                            }
                            startTime = data.startTime;
const p1Proxy = { id: '1', board: createBoardAPI('1') };
                            const p2Proxy = data.is2P ?
{ id: '2', board: createBoardAPI('2') } : null;
const gameApiProxy = { p1: p1Proxy, p2: p2Proxy, ...api };
const combinedCode = data.ruleCode + \`
                                return {
                                    onInit: typeof onInit === 'function' ?
onInit : undefined,
                                    onPieceLock: typeof onPieceLock === 'function' ?
onPieceLock : undefined,
                                    onUpdate: typeof onUpdate === 'function' ?
onUpdate : undefined
                                };\`;
const ruleScript = new Function('api', combinedCode);
                            userFunctions = ruleScript(gameApiProxy);
                            const availableHooks = {};
if (userFunctions.onInit) {
                                availableHooks.onInit = true;
userFunctions.onInit(gameApiProxy);
                            }
                            if (userFunctions.onUpdate) availableHooks.onUpdate = true;
if (userFunctions.onPieceLock) availableHooks.onPieceLock = true;
                            postMessage({ command: 'hooksAvailable', hooks: availableHooks });
} else if ((command === 'pieceLock' && userFunctions.onPieceLock) || (command === 'update' && userFunctions.onUpdate)) {
                            const p1Proxy = { id: '1', board: createBoardAPI('1'), stats: playerStates['1'].stats };
const p2Proxy = data.is2P ? { id: '2', board: createBoardAPI('2'), stats: playerStates['2'].stats } : null;
if (p1Proxy && p2Proxy) {
                                p1Proxy.opponent = p2Proxy;
p2Proxy.opponent = p1Proxy;
                            }
                            const gameApiProxy = { p1: p1Proxy, p2: p2Proxy, ...api };
const playerProxy = data.playerStateProxy.id === '1' ? p1Proxy : p2Proxy;
if (command === 'pieceLock') {
                                userFunctions.onPieceLock(gameApiProxy, playerProxy, data.moveInfo);
                                postMessage({ command: 'hookComplete', hook: 'pieceLock' });
} else {
                                userFunctions.onUpdate(gameApiProxy, playerProxy);
}
}
};
`;
             const ruleWorkerBlob = new Blob([ruleWorkerScript], { type: 'application/javascript' });
players.forEach(p => {
                p.ruleWorker = new Worker(URL.createObjectURL(ruleWorkerBlob));
                p.ruleWorker.onmessage = (e) => {
                    const { command, func, args, hooks } = e.data;
                    
     if (command === 'api') {
                          const getPlayerById = (id) => players.find(player => player.id === id);
                            switch(func) {
                         
       case 'win': getPlayerById(args[0])?.win(); break;
 
                               case 'lose': getPlayerById(args[0])?.lose(); break;
                                case 'setCustomUIText': getPlayerById(args[0])?.setCustomUIText(args[1]); break;
                    
           
 case 'sendAttack':
                                    const targetPlayer = getPlayerById(args[0]);
                                    if (targetPlayer) {
                                        targetPlayer.garbageQueue.push({
                                            lines: args[1],
                                            receivedTime: performance.now()
                                        });
                                    }
                                    break;
                                case 'forceSetting': 
                                    if (args[0] in currentRunSettings) currentRunSettings[args[0]] = args[1];
         
           
                break;
case 'displayGhostBlock': getPlayerById(args[0])?.displayGhostBlock(args[1], args[2], args[3]); break;
                                case 'clearAllGhostBlocks': getPlayerById(args[0])?.clearAllGhostBlocks(); break;
                                case 'setPiece': getPlayerById(args[0])?.setPiece(args[1], args[2], args[3]); break;
                                case 'placeBlock': getPlayerById(args[0])?.placeBlock(args[1], args[2], args[3]); break;
}
                        } 
else if (command === 'hooksAvailable') {
                        p.activeRuleHooks = hooks;
if(hooks.onInit){
                             Object.assign(gameSettings, currentRunSettings);
}
                    } else if (command === 'hookComplete' && e.data.hook === 'pieceLock') {
                        p.finishLockPiece();
                    }
                };
                const initialStateProxy = {
                        id: p.id,
                        board: p.board,
                        holdPiece: p.holdPiece,
                        currentPiece: p.player.pieceType,
                        nextQueue: p.nextQueue,
                        fullMinoSequence: p.fullMinoSequence,
                        stats: p.stats
                    };
p.ruleWorker.postMessage({
                    command: 'init',
                    data: {
                        ruleCode: editorData.rule.code,
                        startTime: startTime,
        
                is2P: gameMode === '2P',
                        initialPlayerState: initialStateProxy
                    }
                });
});
        }
        
        if (!editorData.rule.code) {
            Object.assign(gameSettings, currentRunSettings);
        }
});
    document.getElementById('gameSettingsBtn').addEventListener('click', () => {
        openUnifiedSettingsModal('general');
    });
    setupEditors();

    loadStateFromURL();

    lastTime = performance.now(); 
    requestAnimationFrame(gameLoop);

    
    window.addEventListener('resize', updateScale);

    setTimeout(updateScale, 100);

    document.getElementById('ai-debug-execute').addEventListener('click', () => {
        const piece = document.getElementById('ai-debug-piece').value.toUpperCase();
        const x = parseInt(document.getElementById('ai-debug-x').value, 10);
        const y = parseInt(document.getElementById('ai-debug-y').value, 10);
        const rot = parseInt(document.getElementById('ai-debug-rot').value, 10);

        if (!piece || isNaN(x) || isNaN(y) || isNaN(rot)) {
            alert('Invalid debug input.');
            return;
        }

        const aiPlayer = players.find(p => p.isAi);
        if (!aiPlayer) {
            alert('No AI player found to execute the move.');
            return;
        }
        
        const move = {
             pieceType: piece,
            x: x,
            y: y,
            rotation: rot
        };

        aiPlayer.executeAiMove(move);
    });

    document.getElementById('exportFumenBtn').addEventListener('click', () => {
        if (gameHistoryLog.length === 0) {
            alert('記録するデータがありません。');
            return;
        }
        
        const compressedPages = [];
        let prevP1Board1D = null;
        let prevP2Board1D = null;

        for (let i = 0; i < gameHistoryLog.length; i++) {
            const page = gameHistoryLog[i];
            const pageData = {};

            // P1
            const currentP1Board1D = page.p1.b.split('');
            let p1BoardCompressed;
            if (i === 0) {
                // 1ページ目: 生データをRLE
                p1BoardCompressed = encodeRLE(currentP1Board1D);
            } else {
                // 2ページ目以降: 差分をRLE
                const diff = getDifference(prevP1Board1D, currentP1Board1D);
                p1BoardCompressed = encodeRLE(diff);
            }
            pageData.p1 = {
                b: p1BoardCompressed, // 圧縮データを格納
                h: page.p1.h || '',
                n: page.p1.n || ''
            };
            prevP1Board1D = currentP1Board1D; // 次の差分のために現在地を保存

            // P2 (2Pモード時)
            if (gameMode === '2P' && page.p2) {
                const currentP2Board1D = page.p2.b.split('');
                let p2BoardCompressed;
                if (i === 0) {
                    p2BoardCompressed = encodeRLE(currentP2Board1D);
                } else {
                    const diff = getDifference(prevP2Board1D, currentP2Board1D);
                    p2BoardCompressed = encodeRLE(diff);
                }
                pageData.p2 = {
                    b: p2BoardCompressed,
                    h: page.p2.h || '',
                    n: page.p2.n || ''
                };
                prevP2Board1D = currentP2Board1D;
            }
            
            compressedPages.push(pageData);
        }

        const fumenData = {
            v: 'f2',
            m: gameMode,
            p: compressedPages
        };

        let jsonString, base64Data;

        try {
            jsonString = JSON.stringify(fumenData);
            const uint8Array = new TextEncoder().encode(jsonString);
            
            let binaryString = '';
            const CHUNK_SIZE = 8192; 
            for (let i = 0; i < uint8Array.length; i += CHUNK_SIZE) {
                const chunk = uint8Array.subarray(i, i + CHUNK_SIZE);
                binaryString += String.fromCharCode.apply(null, chunk);
            }
            base64Data = btoa(binaryString);

        } catch (e) {
            console.error('譜面データのエンコードに失敗しました:', e);
            if (confirm('譜面データのエンコードに失敗しました。データが大きすぎる可能性があります。\n\n生の譜面データ(JSON)をクリップボードにコピーしますか？ (Base64ではありません)')) {
                navigator.clipboard.writeText(jsonString)
                    .then(() => {
                        alert('生の譜面データ(JSON)をクリップボードにコピーしました。');
                    })
                    .catch(err => {
                        console.error('クリップボードへのコピーに失敗しました:', err);
                        alert('クリップボードへのコピーに失敗しました。');
                    });
}
                return;
}
            
            
            gameState = 'EDITING';
            
            if (players.length > 0) {
                players.forEach(p => {
                    if (p.aiWorker) {
                        p.aiWorker.terminate();
                    }
                    if (p.hintAiWorker) {
                        p.hintAiWorker.terminate();
                    }
            
                    if (p.ruleWorker) {
                        p.ruleWorker.terminate();
                    }
                });

            }
            
            players = [];
            loadGameSettings();
            document.getElementById('game-container').style.display = 'none';
            document.getElementById('game-controls').style.display = 'none';
            document.getElementById('editor-container').style.display = 'flex';
            document.getElementById('rule-description-display').style.display = 'none';
            
            virtualController.hide();
            
            const aiDebugDisplay = document.getElementById('ai-debug-display');
            const aiDebugControls = document.getElementById('ai-debug-controls');
            if(aiDebugDisplay) aiDebugDisplay.style.display = 'none';
            if(aiDebugControls) aiDebugControls.style.display = 'none';

            setTimeout(updateScale, 0);

        
            try {
                let fumenEditorURL 
= './F/index.html';
try {
                const path = window.location.pathname;
const parentPath = path.substring(0, path.lastIndexOf('/') + 1);
fumenEditorURL = parentPath + 'F/index.html';
} catch (e) { /* fallback */ }

                window.open(`${fumenEditorURL}#${base64Data}`, '_blank');
} catch (e) {
                console.error('譜面データの生成に失敗しました:', e);
if (confirm('リンクの生成に失敗しました。データが長すぎる可能性があります。\n譜面データ（Base64）をクリップボードにコピーしますか？')) {
                navigator.clipboard.writeText(base64Data)
                    .then(() => {
                        alert('譜面データをクリップボードにコピーしました。\n譜面エディタで手動で読み込んでください。');
                    })
                

    .catch(err => {
                                            console.error('クリップボードへのコピーに失敗しました:', err);
                        alert('クリップボードへのコピーに失敗しました。');
                    });
            }
}
    });

    // 分析機能の実装
    document.getElementById('analyzeBtn').addEventListener('click', () => {
        const modal = document.getElementById('analysis-modal');
        const statsDiv = document.getElementById('analysis-stats');
        modal.style.display = 'flex';

        const container = document.getElementById('analysis-canvas-container');
        container.innerHTML = '';
        container.style.display = 'flex';
        container.style.flexDirection = 'column';
        container.style.gap = '10px';

        const canvas1 = document.createElement('canvas');
        canvas1.style.flex = '1'; canvas1.style.width = '100%'; canvas1.style.backgroundColor = '#0f0f18'; canvas1.style.border = '1px solid #4b4b7c';
        const canvas2 = document.createElement('canvas');
        canvas2.style.flex = '1'; canvas2.style.width = '100%'; canvas2.style.backgroundColor = '#0f0f18'; canvas2.style.border = '1px solid #4b4b7c';
        container.appendChild(canvas1);
        container.appendChild(canvas2);

        // Resize logic
        canvas1.width = container.clientWidth; canvas1.height = container.clientHeight / 2 - 10;
        canvas2.width = container.clientWidth; canvas2.height = container.clientHeight / 2 - 10;

        const ctx1 = canvas1.getContext('2d');
        const ctx2 = canvas2.getContext('2d');

        if (analysisData.length === 0) {
            statsDiv.innerHTML = 'データがありません';
            return;
        }

        const resources = analysisData.filter(d => d.type === 'resource');
        const actions = analysisData.filter(d => d.type === 'action');
        if (resources.length === 0) return;

        const maxTime = resources[resources.length - 1].time;
        
        // --- 共通描画関数 ---
        const drawGrid = (ctx, w, h, maxY, xLabelFunc, yLabelFunc, padding = 40) => {
            const drawW = w - padding * 2;
            const drawH = h - padding * 2;
            ctx.strokeStyle = '#4b4b7c'; ctx.lineWidth = 1; ctx.beginPath();
            ctx.moveTo(padding, h - padding); ctx.lineTo(w - padding, h - padding); // X
            ctx.moveTo(padding, h - padding); ctx.lineTo(padding, padding); // Y
            ctx.stroke();

            ctx.fillStyle = '#e0e0e0'; ctx.font = '10px "Noto Sans JP", sans-serif'; ctx.textAlign = 'right';
            const yStep = maxY / 5;
            for(let v = 0; v <= maxY; v += yStep) {
                const y = h - padding - (v / maxY) * drawH;
                ctx.fillText(yLabelFunc ? yLabelFunc(v) : v.toFixed(1), padding - 5, y + 3);
                ctx.strokeStyle = '#333'; ctx.beginPath(); ctx.moveTo(padding, y); ctx.lineTo(w - padding, y); ctx.stroke();
            }
            ctx.textAlign = 'center';
            for(let t = 0; t <= maxTime; t += 10000) {
                const x = padding + (t / maxTime) * drawW;
                ctx.fillText(Math.floor(t / 1000) + 's', x, h - padding + 15);
            }
            return { drawW, drawH, padding };
        };

        // --- Graph 1: Resources ---
        const maxR = 200;
        const layout1 = drawGrid(ctx1, canvas1.width, canvas1.height, maxR, null, (v) => Math.round(v));
        
        // Title
        ctx1.fillStyle = '#e0e0e0'; ctx1.font = '14px "Noto Sans JP", sans-serif'; ctx1.textAlign = 'left';
        ctx1.fillText('リソース推移 (ブロック数)', layout1.padding, 20);

        const plot = (ctx, data, valueKey, color, layout, maxY) => {
            ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.beginPath();
            let first = true;
            for (const d of data) {
                const x = layout.padding + (d.time / maxTime) * layout.drawW;
                const y = canvas1.height - layout.padding - (d[valueKey] / maxY) * layout.drawH;
                if (first) { ctx.moveTo(x, y); first = false; } else { ctx.lineTo(x, y); }
            }
            ctx.stroke();
        };

        plot(ctx1, resources, 'p1_R', '#ff4444', layout1, maxR);
        if (gameMode === '2P') {
            plot(ctx1, resources, 'p2_R', '#4444ff', layout1, maxR);
            ctx1.strokeStyle = '#44ff44'; ctx1.lineWidth = 1; ctx1.setLineDash([5, 5]); ctx1.beginPath();
            let first = true;
            for (const d of resources) {
                const x = layout1.padding + (d.time / maxTime) * layout1.drawW;
                const y = canvas1.height - layout1.padding - ((d.p1_R + d.p2_R) / maxR) * layout1.drawH;
                if (first) { ctx1.moveTo(x, y); first = false; } else { ctx1.lineTo(x, y); }
            }
            ctx1.stroke(); ctx1.setLineDash([]);
        }

        // --- Graph 2: APL (Moving Average) ---
        const layout2 = drawGrid(ctx2, canvas2.width, canvas2.height, 3.0, null, (v) => v.toFixed(1));
        ctx2.fillStyle = '#e0e0e0'; ctx2.font = '14px "Noto Sans JP", sans-serif'; ctx2.textAlign = 'left';
        ctx2.fillText('APL推移 (直近10回の移動平均)', layout2.padding, 20);

        // APL=1.0 line
        const y1 = canvas2.height - layout2.padding - (1.0 / 3.0) * layout2.drawH;
        ctx2.strokeStyle = '#ffff00'; ctx2.lineWidth = 1; ctx2.setLineDash([2, 2]); 
        ctx2.beginPath(); ctx2.moveTo(layout2.padding, y1); ctx2.lineTo(canvas2.width - layout2.padding, y1); ctx2.stroke(); ctx2.setLineDash([]);

        const calculateMovingAvgAPL = (pId) => {
            const pActions = actions.filter(a => a.playerId === pId && a.lines > 0);
            const points = [];
            const windowSize = 10;
            for(let i = 0; i < pActions.length; i++) {
                let sumAtk = 0; let sumLines = 0;
                for(let j = Math.max(0, i - windowSize + 1); j <= i; j++) {
                    sumAtk += pActions[j].attack;
                    sumLines += pActions[j].lines;
                }
                if (sumLines > 0) points.push({ time: pActions[i].time, apl: sumAtk / sumLines });
            }
            return points;
        };

        const p1APL = calculateMovingAvgAPL('1');
        ctx2.strokeStyle = '#ff4444'; ctx2.lineWidth = 2; ctx2.beginPath();
        let first = true;
        for (const d of p1APL) {
            const x = layout2.padding + (d.time / maxTime) * layout2.drawW;
            const y = canvas2.height - layout2.padding - (Math.min(3.0, d.apl) / 3.0) * layout2.drawH;
            if (first) { ctx2.moveTo(x, y); first = false; } else { ctx2.lineTo(x, y); }
        }
        ctx2.stroke();

        if (gameMode === '2P') {
            const p2APL = calculateMovingAvgAPL('2');
            ctx2.strokeStyle = '#4444ff'; ctx2.lineWidth = 2; ctx2.beginPath();
            first = true;
            for (const d of p2APL) {
                const x = layout2.padding + (d.time / maxTime) * layout2.drawW;
                const y = canvas2.height - layout2.padding - (Math.min(3.0, d.apl) / 3.0) * layout2.drawH;
                if (first) { ctx2.moveTo(x, y); first = false; } else { ctx2.lineTo(x, y); }
            }
            ctx2.stroke();
        }

        // --- Statistics ---
        const calcStats = (pId) => {
            const pActs = actions.filter(a => a.playerId === pId);
            const totalLines = pActs.reduce((s, a) => s + a.lines, 0);
            const totalAttack = pActs.reduce((s, a) => s + a.attack, 0);
            const pps = pActs.length / (maxTime / 1000);
            const apm = totalAttack / (maxTime / 60000);
            const avgApl = totalLines > 0 ? totalAttack / totalLines : 0;
            return { pps, apm, avgApl };
        };

        const s1 = calcStats('1');
        const totalResources = resources.map(r => r.p1_R + (gameMode === '2P' ? r.p2_R : 0));
        const avgTotalRes = totalResources.reduce((a, b) => a + b, 0) / totalResources.length;
        
        let highToLow = 0; let highCount = 0;
        let lowToHigh = 0; let lowCount = 0;
        for(let i = 0; i < totalResources.length - 5; i++) {
            const current = totalResources[i];
            const future = totalResources[i+5]; // 1 sec later (approx)
            if (current > avgTotalRes + 10) {
                highCount++;
                if (future < current) highToLow++;
            } else if (current < avgTotalRes - 10) {
                lowCount++;
                if (future > current) lowToHigh++;
            }
        }
        const decreaseRate = highCount > 0 ? (highToLow / highCount * 100) : 0;
        const increaseRate = lowCount > 0 ? (lowToHigh / lowCount * 100) : 0;

        let html = `<div style="display:flex; flex-wrap:wrap; gap:15px; justify-content:center;">`;
        const cardStyle = 'background:rgba(255,255,255,0.05); padding:10px; border-radius:5px; border:1px solid #4b4b7c;';
        
        html += `<div style="${cardStyle}"><h4 style="margin:0 0 5px 0; color:#ff4444;">Player 1</h4>PPS: ${s1.pps.toFixed(2)}<br>APM: ${s1.apm.toFixed(1)}<br>APL: ${s1.avgApl.toFixed(2)}</div>`;
        
        if (gameMode === '2P') {
            const s2 = calcStats('2');
            html += `<div style="${cardStyle}"><h4 style="margin:0 0 5px 0; color:#4444ff;">Player 2</h4>PPS: ${s2.pps.toFixed(2)}<br>APM: ${s2.apm.toFixed(1)}<br>APL: ${s2.avgApl.toFixed(2)}</div>`;
        }

        html += `<div style="${cardStyle}"><h4 style="margin:0 0 5px 0; color:#44ff44;">総リソース</h4>平均値(収束点): ${avgTotalRes.toFixed(1)}<br>高リソース時減少率: ${decreaseRate.toFixed(1)}%<br>低リソース時増加率: ${increaseRate.toFixed(1)}%</div>`;
        html += `</div>`;
        
        statsDiv.innerHTML = html;
    });

    document.getElementById('analysis-close').addEventListener('click', () => {
        document.getElementById('analysis-modal').style.display = 'none';
    });

});
function logCurrentGameState(lockingPlayer = null) {
    if (players.length === 0) return;
const isInitialCall = gameHistoryLog.length === 0;

const getPlayerData = (player, isOpponentOfLocking) => {
        if (!player) return null;
let nextPieces;
        if (isInitialCall) {
            nextPieces = [
                player.player.pieceType, 
                ...player.nextQueue.slice(0, Math.max(0, gameSettings.maxNext - 1))
            ];
} else if (lockingPlayer && isOpponentOfLocking) {
            nextPieces = [
                player.player.pieceType,
                ...player.nextQueue.slice(0, Math.max(0, gameSettings.maxNext - 1))
            ];
        } else {
            nextPieces = [
                ...player.nextQueue.slice(0, Math.max(0, gameSettings.maxNext))
            ];
}

const next = nextPieces.filter(p => p !== null && p !== 'E').join('');
return {
            b: boardToString(player.board),
            h: player.holdPiece ||
'',
            n: next
        };
};

    const p1 = players[0];
    const p2 = (gameMode === '2P' && players[1]) ? players[1] : null;

    const p1IsOpponent = (lockingPlayer && p2 && lockingPlayer.id === p2.id);
    const p2IsOpponent = (lockingPlayer && p1 && lockingPlayer.id === p1.id);

    const p1Data = getPlayerData(p1, p1IsOpponent);
    const p2Data = getPlayerData(p2, p2IsOpponent);

const pageData = { p1: p1Data };
    if (p2Data) {
        pageData.p2 = p2Data;
}
    
    gameHistoryLog.push(pageData);
}

</script>
</body>
</html>
